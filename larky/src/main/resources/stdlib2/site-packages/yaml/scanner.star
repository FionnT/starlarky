def ScannerError(MarkedYAMLError):
    """
     See below simple keys treatment.


    """
    def __init__(self, token_number, required, index, line, column, mark):
        """
        Initialize the scanner.
        """
    def check_token(self, *choices):
        """
         Check if the next token is one of the given types.

        """
    def peek_token(self):
        """
         Return the next token, but do not delete if from the queue.
         Return None if no more tokens.

        """
    def get_token(self):
        """
         Return the next token.

        """
    def need_more_tokens(self):
        """
         The current token may be a potential simple key, so we
         need to look further.

        """
    def fetch_more_tokens(self):
        """
         Eat whitespaces and comments until we reach the next token.

        """
    def next_possible_simple_key(self):
        """
         Return the number of the nearest possible simple key. Actually we
         don't need to loop through the whole dictionary. We may replace it
         with the following code:
           if not self.possible_simple_keys:
               return None
           return self.possible_simple_keys[
                   min(self.possible_simple_keys.keys())].token_number

        """
    def stale_possible_simple_keys(self):
        """
         Remove entries that are no longer possible simple keys. According to
         the YAML specification, simple keys
         - should be limited to a single line,
         - should be no longer than 1024 characters.
         Disabling this procedure will allow simple keys of any length and
         height (may cause problems if indentation is broken though).

        """
    def save_possible_simple_key(self):
        """
         The next token may start a simple key. We check if it's possible
         and save its position. This function is called for
           ALIAS, ANCHOR, TAG, SCALAR(flow), '[', and '{'.

         Check if a simple key is required at the current position.

        """
    def remove_possible_simple_key(self):
        """
         Remove the saved possible key position at the current flow level.

        """
    def unwind_indent(self, column):
        """
         In flow context, tokens should respect indentation.
         Actually the condition should be `self.indent >= column` according to
         the spec. But this condition will prohibit intuitively correct
         constructions such as
         key : {
         }
        if self.flow_level and self.indent > column:
            raise ScannerError(None, None,
                    "invalid indentation or unclosed '[' or '{'",
                    self.get_mark())

         In the flow context, indentation is ignored. We make the scanner less
         restrictive then specification requires.

        """
    def add_indent(self, column):
        """
         Check if we need to increase indentation.

        """
    def fetch_stream_start(self):
        """
         We always add STREAM-START as the first token and STREAM-END as the
         last token.

         Read the token.

        """
    def fetch_stream_end(self):
        """
         Set the current indentation to -1.

        """
    def fetch_directive(self):
        """
         Set the current indentation to -1.

        """
    def fetch_document_start(self):
        """
         Set the current indentation to -1.

        """
    def fetch_flow_sequence_start(self):
        """
         '[' and '{' may start a simple key.

        """
    def fetch_flow_sequence_end(self):
        """
         Reset possible simple key on the current level.

        """
    def fetch_flow_entry(self):
        """
         Simple keys are allowed after ','.

        """
    def fetch_block_entry(self):
        """
         Block context needs additional checks.

        """
    def fetch_key(self):
        """
         Block context needs additional checks.

        """
    def fetch_value(self):
        """
         Do we determine a simple key?

        """
    def fetch_alias(self):
        """
         ALIAS could be a simple key.

        """
    def fetch_anchor(self):
        """
         ANCHOR could start a simple key.

        """
    def fetch_tag(self):
        """
         TAG could start a simple key.

        """
    def fetch_literal(self):
        """
        '|'
        """
    def fetch_folded(self):
        """
        '>'
        """
    def fetch_block_scalar(self, style):
        """
         A simple key may follow a block scalar.

        """
    def fetch_single(self):
        """
        '\''
        """
    def fetch_double(self):
        """
        '"'
        """
    def fetch_flow_scalar(self, style):
        """
         A flow scalar could be a simple key.

        """
    def fetch_plain(self):
        """
         A plain scalar could be a simple key.

        """
    def check_directive(self):
        """
         DIRECTIVE:        ^ '%' ...
         The '%' indicator is already checked.

        """
    def check_document_start(self):
        """
         DOCUMENT-START:   ^ '---' (' '|'\n')

        """
    def check_document_end(self):
        """
         DOCUMENT-END:     ^ '...' (' '|'\n')

        """
    def check_block_entry(self):
        """
         BLOCK-ENTRY:      '-' (' '|'\n')

        """
    def check_key(self):
        """
         KEY(flow context):    '?'

        """
    def check_value(self):
        """
         VALUE(flow context):  ':'

        """
    def check_plain(self):
        """
         A plain scalar may start with any non-space character except:
           '-', '?', ':', ',', '[', ']', '{', '}',
           '#', '&', '*', '!', '|', '>', '\'', '\"',
           '%', '@', '`'.

         It may also start with
           '-', '?', ':'
         if it is followed by a non-space character.

         Note that we limit the last rule to the block context (except the
         '-' character) because we want the flow context to be space
         independent.

        """
    def scan_to_next_token(self):
        """
         We ignore spaces, line breaks and comments.
         If we find a line break in the block context, we set the flag
         `allow_simple_key` on.
         The byte order mark is stripped if it's the first character in the
         stream. We do not yet support BOM inside the stream as the
         specification requires. Any such mark will be considered as a part
         of the document.

         TODO: We need to make tab handling rules more sane. A good rule is
           Tabs cannot precede tokens
           BLOCK-SEQUENCE-START, BLOCK-MAPPING-START, BLOCK-END,
           KEY(block), VALUE(block), BLOCK-ENTRY
         So the checking code is
           if <TAB>:
               self.allow_simple_keys = False
         We also need to add the check for `allow_simple_keys == True` to
         `unwind_indent` before issuing BLOCK-END.
         Scanners for block, flow, and plain scalars need to be modified.


        """
    def scan_directive(self):
        """
         See the specification for details.

        """
    def scan_directive_name(self, start_mark):
        """
         See the specification for details.

        """
    def scan_yaml_directive_value(self, start_mark):
        """
         See the specification for details.

        """
    def scan_yaml_directive_number(self, start_mark):
        """
         See the specification for details.

        """
    def scan_tag_directive_value(self, start_mark):
        """
         See the specification for details.

        """
    def scan_tag_directive_handle(self, start_mark):
        """
         See the specification for details.

        """
    def scan_tag_directive_prefix(self, start_mark):
        """
         See the specification for details.

        """
    def scan_directive_ignored_line(self, start_mark):
        """
         See the specification for details.

        """
    def scan_anchor(self, TokenClass):
        """
         The specification does not restrict characters for anchors and
         aliases. This may lead to problems, for instance, the document:
           [ *alias, value ]
         can be interpreted in two ways, as
           [ "value" ]
         and
           [ *alias , "value" ]
         Therefore we restrict aliases to numbers and ASCII letters.

        """
    def scan_tag(self):
        """
         See the specification for details.

        """
    def scan_block_scalar(self, style):
        """
         See the specification for details.


        """
    def scan_block_scalar_indicators(self, start_mark):
        """
         See the specification for details.

        """
    def scan_block_scalar_ignored_line(self, start_mark):
        """
         See the specification for details.

        """
    def scan_block_scalar_indentation(self):
        """
         See the specification for details.

        """
    def scan_block_scalar_breaks(self, indent):
        """
         See the specification for details.

        """
    def scan_flow_scalar(self, style):
        """
         See the specification for details.
         Note that we loose indentation rules for quoted scalars. Quoted
         scalars don't need to adhere indentation because " and ' clearly
         mark the beginning and the end of them. Therefore we are less
         restrictive then the specification requires. We only need to check
         that document separators are not included in scalars.

        """
    def scan_flow_scalar_non_spaces(self, double, start_mark):
        """
         See the specification for details.

        """
    def scan_flow_scalar_spaces(self, double, start_mark):
        """
         See the specification for details.

        """
    def scan_flow_scalar_breaks(self, double, start_mark):
        """
         See the specification for details.

        """
    def scan_plain(self):
        """
         See the specification for details.
         We add an additional restriction for the flow context:
           plain scalars in the flow context cannot contain ',' or '?'.
         We also keep track of the `allow_simple_key` flag here.
         Indentation rules are loosed for the flow context.

        """
    def scan_plain_spaces(self, indent, start_mark):
        """
         See the specification for details.
         The specification is really confusing about tabs in plain scalars.
         We just forbid them completely. Do not use tabs in YAML!

        """
    def scan_tag_handle(self, name, start_mark):
        """
         See the specification for details.
         For some strange reasons, the specification does not allow '_' in
         tag handles. I have allowed it anyway.

        """
    def scan_tag_uri(self, name, start_mark):
        """
         See the specification for details.
         Note: we do not check if URI is well-formed.

        """
    def scan_uri_escapes(self, name, start_mark):
        """
         See the specification for details.

        """
    def scan_line_break(self):
        """
         Transforms:
           '\r\n'      :   '\n'
           '\r'        :   '\n'
           '\n'        :   '\n'
           '\x85'      :   '\n'
           '\u2028'    :   '\u2028'
           '\u2029     :   '\u2029'
           default     :   ''

        """
