def make_install_req_from_link(link, template):
    """
     type: (Link, InstallRequirement) -> InstallRequirement

    """
def make_install_req_from_editable(link, template):
    """
     type: (Link, InstallRequirement) -> InstallRequirement

    """
def make_install_req_from_dist(dist, template):
    """
     type: (Distribution, InstallRequirement) -> InstallRequirement

    """
def _InstallRequirementBackedCandidate(Candidate):
    """
    A candidate backed by an ``InstallRequirement``.

        This represents a package request with the target not being already
        in the environment, and needs to be fetched and installed. The backing
        ``InstallRequirement`` is responsible for most of the leg work; this
        class exposes appropriate information to the resolver.

        :param link: The link passed to the ``InstallRequirement``. The backing
            ``InstallRequirement`` will use this link to fetch the distribution.
        :param source_link: The link this candidate "originates" from. This is
            different from ``link`` when the link is found in the wheel cache.
            ``link`` would point to the wheel cache, while this points to the
            found remote link (e.g. from pypi.org).
    
    """
2021-03-02 20:50:39,597 : INFO : tokenize_signature : --> do i ever get here?
2021-03-02 20:50:39,597 : INFO : tokenize_signature : --> do i ever get here?
2021-03-02 20:50:39,597 : INFO : tokenize_signature : --> do i ever get here?
2021-03-02 20:50:39,597 : INFO : tokenize_signature : --> do i ever get here?
2021-03-02 20:50:39,597 : INFO : tokenize_signature : --> do i ever get here?
2021-03-02 20:50:39,597 : INFO : tokenize_signature : --> do i ever get here?
2021-03-02 20:50:39,597 : INFO : tokenize_signature : --> do i ever get here?
2021-03-02 20:50:39,598 : INFO : tokenize_signature : --> do i ever get here?
    def __init__(
        self,
        link,          # type: Link
        source_link,   # type: Link
        ireq,          # type: InstallRequirement
        factory,       # type: Factory
        name=None,     # type: Optional[str]
        version=None,  # type: Optional[_BaseVersion]
    ):
        """
         type: (...) -> None

        """
    def __repr__(self):
        """
         type: () -> str

        """
    def __hash__(self):
        """
         type: () -> int

        """
    def __eq__(self, other):
        """
         type: (Any) -> bool

        """
    def __ne__(self, other):
        """
         type: (Any) -> bool

        """
    def source_link(self):
        """
         type: () -> Optional[Link]

        """
    def name(self):
        """
         type: () -> str

        """
    def version(self):
        """
         type: () -> _BaseVersion

        """
    def format_for_error(self):
        """
         type: () -> str

        """
    def _prepare_abstract_distribution(self):
        """
         type: () -> AbstractDistribution

        """
    def _check_metadata_consistency(self):
        """
         type: () -> None

        """
    def _prepare(self):
        """
         type: () -> None

        """
    def _fetch_metadata(self):
        """
         type: () -> None

        """
    def dist(self):
        """
         type: () -> Distribution

        """
    def _get_requires_python_dependency(self):
        """
         type: () -> Optional[Requirement]

        """
    def iter_dependencies(self, with_requires):
        """
         type: (bool) -> Iterable[Optional[Requirement]]

        """
    def get_install_requirement(self):
        """
         type: () -> Optional[InstallRequirement]

        """
def LinkCandidate(_InstallRequirementBackedCandidate):
    """
     type: Link

    """
    def _prepare_abstract_distribution(self):
        """
         type: () -> AbstractDistribution

        """
def EditableCandidate(_InstallRequirementBackedCandidate):
    """
     type: Link

    """
    def _prepare_abstract_distribution(self):
        """
         type: () -> AbstractDistribution

        """
def AlreadyInstalledCandidate(Candidate):
    """
     type: Distribution

    """
    def __repr__(self):
        """
         type: () -> str

        """
    def __hash__(self):
        """
         type: () -> int

        """
    def __eq__(self, other):
        """
         type: (Any) -> bool

        """
    def __ne__(self, other):
        """
         type: (Any) -> bool

        """
    def name(self):
        """
         type: () -> str

        """
    def version(self):
        """
         type: () -> _BaseVersion

        """
    def is_editable(self):
        """
         type: () -> bool

        """
    def format_for_error(self):
        """
         type: () -> str

        """
    def iter_dependencies(self, with_requires):
        """
         type: (bool) -> Iterable[Optional[Requirement]]

        """
    def get_install_requirement(self):
        """
         type: () -> Optional[InstallRequirement]

        """
def ExtrasCandidate(Candidate):
    """
    A candidate that has 'extras', indicating additional dependencies.

        Requirements can be for a project with dependencies, something like
        foo[extra].  The extras don't affect the project/version being installed
        directly, but indicate that we need additional dependencies. We model that
        by having an artificial ExtrasCandidate that wraps the "base" candidate.

        The ExtrasCandidate differs from the base in the following ways:

        1. It has a unique name, of the form foo[extra]. This causes the resolver
           to treat it as a separate node in the dependency graph.
        2. When we're getting the candidate's dependencies,
           a) We specify that we want the extra dependencies as well.
           b) We add a dependency on the base candidate.
              See below for why this is needed.
        3. We return None for the underlying InstallRequirement, as the base
           candidate will provide it, and we don't want to end up with duplicates.

        The dependency on the base candidate is needed so that the resolver can't
        decide that it should recommend foo[extra1] version 1.0 and foo[extra2]
        version 2.0. Having those candidates depend on foo=1.0 and foo=2.0
        respectively forces the resolver to recognise that this is a conflict.
    
    """
2021-03-02 20:50:39,605 : INFO : tokenize_signature : --> do i ever get here?
2021-03-02 20:50:39,605 : INFO : tokenize_signature : --> do i ever get here?
2021-03-02 20:50:39,605 : INFO : tokenize_signature : --> do i ever get here?
2021-03-02 20:50:39,606 : INFO : tokenize_signature : --> do i ever get here?
    def __init__(
        self,
        base,  # type: BaseCandidate
        extras,  # type: FrozenSet[str]
    ):
        """
         type: (...) -> None

        """
    def __repr__(self):
        """
         type: () -> str

        """
    def __hash__(self):
        """
         type: () -> int

        """
    def __eq__(self, other):
        """
         type: (Any) -> bool

        """
    def __ne__(self, other):
        """
         type: (Any) -> bool

        """
    def name(self):
        """
         type: () -> str

        """
    def version(self):
        """
         type: () -> _BaseVersion

        """
    def format_for_error(self):
        """
         type: () -> str

        """
    def is_installed(self):
        """
         type: () -> bool

        """
    def is_editable(self):
        """
         type: () -> bool

        """
    def source_link(self):
        """
         type: () -> Optional[Link]

        """
    def iter_dependencies(self, with_requires):
        """
         type: (bool) -> Iterable[Optional[Requirement]]

        """
    def get_install_requirement(self):
        """
         type: () -> Optional[InstallRequirement]
         We don't return anything here, because we always
         depend on the base candidate, and we'll get the
         install requirement from that.

        """
def RequiresPythonCandidate(Candidate):
    """
     type: (Optional[Tuple[int, ...]]) -> None

    """
    def name(self):
        """
         type: () -> str
         Avoid conflicting with the PyPI package "Python".

        """
    def version(self):
        """
         type: () -> _BaseVersion

        """
    def format_for_error(self):
        """
         type: () -> str

        """
    def iter_dependencies(self, with_requires):
        """
         type: (bool) -> Iterable[Optional[Requirement]]

        """
    def get_install_requirement(self):
        """
         type: () -> Optional[InstallRequirement]

        """
