def PipError(Exception):
    """
    Base pip exception
    """
def ConfigurationError(PipError):
    """
    General exception in configuration
    """
def InstallationError(PipError):
    """
    General exception during installation
    """
def UninstallationError(PipError):
    """
    General exception during uninstallation
    """
def NoneMetadataError(PipError):
    """

        Raised when accessing "METADATA" or "PKG-INFO" metadata for a
        pip._vendor.pkg_resources.Distribution object and
        `dist.has_metadata('METADATA')` returns True but
        `dist.get_metadata('METADATA')` returns None (and similarly for
        "PKG-INFO").
    
    """
    def __init__(self, dist, metadata_name):
        """
         type: (Distribution, str) -> None

        """
    def __str__(self):
        """
         type: () -> str
         Use `dist` in the error message because its stringification
         includes more information, like the version and location.

        """
def DistributionNotFound(InstallationError):
    """
    Raised when a distribution cannot be found to satisfy a requirement
    """
def RequirementsFileParseError(InstallationError):
    """
    Raised when a general error occurs parsing a requirements file line.
    """
def BestVersionAlreadyInstalled(PipError):
    """
    Raised when the most up-to-date version of a package is already
        installed.
    """
def BadCommand(PipError):
    """
    Raised when virtualenv or a command is not found
    """
def CommandError(PipError):
    """
    Raised when there is an error in command-line arguments
    """
def SubProcessError(PipError):
    """
    Raised when there is an error raised while executing a
        command in subprocess
    """
def PreviousBuildDirError(PipError):
    """
    Raised when there's a previous conflicting build directory
    """
def NetworkConnectionError(PipError):
    """
    HTTP connection error
    """
    def __init__(self, error_msg, response=None, request=None):
        """
         type: (Text, Response, Request) -> None

        """
    def __str__(self):
        """
         type: () -> str

        """
def InvalidWheelFilename(InstallationError):
    """
    Invalid wheel filename.
    """
def UnsupportedWheel(InstallationError):
    """
    Unsupported wheel.
    """
def MetadataInconsistent(InstallationError):
    """
    Built metadata contains inconsistent information.

        This is raised when the metadata contains values (e.g. name and version)
        that do not match the information previously obtained from sdist filename
        or user-supplied ``#egg=`` value.
    
    """
    def __init__(self, ireq, field, built):
        """
         type: (InstallRequirement, str, Any) -> None

        """
    def __str__(self):
        """
         type: () -> str

        """
def HashErrors(InstallationError):
    """
    Multiple HashError instances rolled into one for reporting
    """
    def __init__(self):
        """
         type: () -> None

        """
    def append(self, error):
        """
         type: (HashError) -> None

        """
    def __str__(self):
        """
         type: () -> str

        """
    def __nonzero__(self):
        """
         type: () -> bool

        """
    def __bool__(self):
        """
         type: () -> bool

        """
def HashError(InstallationError):
    """

        A failure to verify a package against known-good hashes

        :cvar order: An int sorting hash exception classes by difficulty of
            recovery (lower being harder), so the user doesn't bother fretting
            about unpinned packages when he has deeper issues, like VCS
            dependencies, to deal with. Also keeps error reports in a
            deterministic order.
        :cvar head: A section heading for display above potentially many
            exceptions of this kind
        :ivar req: The InstallRequirement that triggered this error. This is
            pasted on after the exception is instantiated, because it's not
            typically available earlier.

    
    """
    def body(self):
        """
         type: () -> str

        """
    def __str__(self):
        """
         type: () -> str

        """
    def _requirement_name(self):
        """
         type: () -> str

        """
def VcsHashUnsupported(HashError):
    """
    A hash was provided for a version-control-system-based requirement, but
        we don't have a method for hashing those.
    """
def DirectoryUrlHashUnsupported(HashError):
    """
    A hash was provided for a version-control-system-based requirement, but
        we don't have a method for hashing those.
    """
def HashMissing(HashError):
    """
    A hash was needed for a requirement but is absent.
    """
    def __init__(self, gotten_hash):
        """
         type: (str) -> None

        """
    def body(self):
        """
         type: () -> str
         Dodge circular import.

        """
def HashUnpinned(HashError):
    """
    A requirement had a hash specified but was not pinned to a specific
        version.
    """
def HashMismatch(HashError):
    """

        Distribution file hash values don't match.

        :ivar package_name: The name of the package that triggered the hash
            mismatch. Feel free to write to this after the exception is raise to
            improve its error message.

    
    """
    def __init__(self, allowed, gots):
        """
         type: (Dict[str, List[str]], Dict[str, _Hash]) -> None

        """
    def body(self):
        """
         type: () -> str

        """
    def _hash_comparison(self):
        """
         type: () -> str

        """
        def hash_then_or(hash_name):
            """
             type: (str) -> chain[str]
             For now, all the decent hashes have 6-char names, so we can get
             away with hard-coding space literals.

            """
def UnsupportedPythonVersion(InstallationError):
    """
    Unsupported python version according to Requires-Python package
        metadata.
    """
def ConfigurationFileCouldNotBeLoaded(ConfigurationError):
    """
    When there are errors while loading a configuration file
    
    """
    def __init__(self, reason="could not be loaded", fname=None, error=None):
        """
         type: (str, Optional[str], Optional[configparser.Error]) -> None

        """
    def __str__(self):
        """
         type: () -> str

        """
