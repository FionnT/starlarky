def InvalidSpecifier(ValueError):
    """

        An invalid specifier was found, users should refer to PEP 440.
    
    """
def BaseSpecifier(with_metadef(abc.ABCMeta, object)):  # type: ignore
    """
     type: ignore
    """
    def __str__(self):
        """
         type: () -> str

        """
    def __hash__(self):
        """
         type: () -> int

        """
    def __eq__(self, other):
        """
         type: (object) -> bool

        """
    def __ne__(self, other):
        """
         type: (object) -> bool

        """
    def prereleases(self):
        """
         type: () -> Optional[bool]

        """
    def prereleases(self, value):
        """
         type: (bool) -> None

        """
    def contains(self, item, prereleases=None):
        """
         type: (str, Optional[bool]) -> bool

        """
    def filter(self, iterable, prereleases=None):
        """
         type: (Iterable[UnparsedVersion], Optional[bool]) -> Iterable[UnparsedVersion]

        """
def _IndividualSpecifier(BaseSpecifier):
    """
     type: Dict[str, str]
    """
    def __init__(self, spec="", prereleases=None):
        """
         type: (str, Optional[bool]) -> None

        """
    def __repr__(self):
        """
         type: () -> str

        """
    def __str__(self):
        """
         type: () -> str

        """
    def _canonical_spec(self):
        """
         type: () -> Tuple[str, Union[Version, str]]

        """
    def __hash__(self):
        """
         type: () -> int

        """
    def __eq__(self, other):
        """
         type: (object) -> bool

        """
    def __ne__(self, other):
        """
         type: (object) -> bool

        """
    def _get_operator(self, op):
        """
         type: (str) -> CallableOperator

        """
    def _coerce_version(self, version):
        """
         type: (UnparsedVersion) -> ParsedVersion

        """
    def operator(self):
        """
         type: () -> str

        """
    def version(self):
        """
         type: () -> str

        """
    def prereleases(self):
        """
         type: () -> Optional[bool]

        """
    def prereleases(self, value):
        """
         type: (bool) -> None

        """
    def __contains__(self, item):
        """
         type: (str) -> bool

        """
    def contains(self, item, prereleases=None):
        """
         type: (UnparsedVersion, Optional[bool]) -> bool

         Determine if prereleases are to be allowed or not.

        """
    def filter(self, iterable, prereleases=None):
        """
         type: (Iterable[UnparsedVersion], Optional[bool]) -> Iterable[UnparsedVersion]


        """
def LegacySpecifier(_IndividualSpecifier):
    """
    r"""
            (?P<operator>(==|!=|<=|>=|<|>))
            \s*
            (?P<version>
                [^,;\s)]* # Since this is a "legacy" specifier, and the version
                          # string can be just about anything, we match everything
                          # except for whitespace, a semi-colon for marker support,
                          # a closing paren since versions can be enclosed in
                          # them, and a comma since it's a version separator.
            )
        
    """
    def _coerce_version(self, version):
        """
         type: (Union[ParsedVersion, str]) -> LegacyVersion

        """
    def _compare_equal(self, prospective, spec):
        """
         type: (LegacyVersion, str) -> bool

        """
    def _compare_not_equal(self, prospective, spec):
        """
         type: (LegacyVersion, str) -> bool

        """
    def _compare_less_than_equal(self, prospective, spec):
        """
         type: (LegacyVersion, str) -> bool

        """
    def _compare_greater_than_equal(self, prospective, spec):
        """
         type: (LegacyVersion, str) -> bool

        """
    def _compare_less_than(self, prospective, spec):
        """
         type: (LegacyVersion, str) -> bool

        """
    def _compare_greater_than(self, prospective, spec):
        """
         type: (LegacyVersion, str) -> bool

        """
2021-03-02 20:50:48,365 : INFO : tokenize_signature : --> do i ever get here?
2021-03-02 20:50:48,365 : INFO : tokenize_signature : --> do i ever get here?
def _require_version_compare(
    fn  # type: (Callable[[Specifier, ParsedVersion, str], bool])
):
    """
     type: (...) -> Callable[[Specifier, ParsedVersion, str], bool]

    """
    def wrapped(self, prospective, spec):
        """
         type: (Specifier, ParsedVersion, str) -> bool

        """
def Specifier(_IndividualSpecifier):
    """
    r"""
            (?P<operator>(~=|==|!=|<=|>=|<|>|===))
            (?P<version>
                (?:
                    # The identity operators allow for an escape hatch that will
                    # do an exact string match of the version you wish to install.
                    # This will not be parsed by PEP 440 and we cannot determine
                    # any semantic meaning from it. This operator is discouraged
                    # but included entirely as an escape hatch.
                    (?<====)  # Only match for the identity operator
                    \s*
                    [^\s]*    # We just match everything, except for whitespace
                              # since we are only testing for strict identity.
                )
                |
                (?:
                    # The (non)equality operators allow for wild card and local
                    # versions to be specified so we have to define these two
                    # operators separately to enable that.
                    (?<===|!=)            # Only match for equals and not equals

                    \s*
                    v?
                    (?:[0-9]+!)?          # epoch
                    [0-9]+(?:\.[0-9]+)*   # release
                    (?:                   # pre release
                        [-_\.]?
                        (a|b|c|rc|alpha|beta|pre|preview)
                        [-_\.]?
                        [0-9]*
                    )?
                    (?:                   # post release
                        (?:-[0-9]+)|(?:[-_\.]?(post|rev|r)[-_\.]?[0-9]*)
                    )?

                    # You cannot use a wild card and a dev or local version
                    # together so group them with a | and make them optional.
                    (?:
                        (?:[-_\.]?dev[-_\.]?[0-9]*)?         # dev release
                        (?:\+[a-z0-9]+(?:[-_\.][a-z0-9]+)*)? # local
                        |
                        \.\*  # Wild card syntax of .*
                    )?
                )
                |
                (?:
                    # The compatible operator requires at least two digits in the
                    # release segment.
                    (?<=~=)               # Only match for the compatible operator

                    \s*
                    v?
                    (?:[0-9]+!)?          # epoch
                    [0-9]+(?:\.[0-9]+)+   # release  (We have a + instead of a *)
                    (?:                   # pre release
                        [-_\.]?
                        (a|b|c|rc|alpha|beta|pre|preview)
                        [-_\.]?
                        [0-9]*
                    )?
                    (?:                                   # post release
                        (?:-[0-9]+)|(?:[-_\.]?(post|rev|r)[-_\.]?[0-9]*)
                    )?
                    (?:[-_\.]?dev[-_\.]?[0-9]*)?          # dev release
                )
                |
                (?:
                    # All other operators only allow a sub set of what the
                    # (non)equality operators do. Specifically they do not allow
                    # local versions to be specified nor do they allow the prefix
                    # matching wild cards.
                    (?<!==|!=|~=)         # We have special cases for these
                                          # operators so we want to make sure they
                                          # don't match here.

                    \s*
                    v?
                    (?:[0-9]+!)?          # epoch
                    [0-9]+(?:\.[0-9]+)*   # release
                    (?:                   # pre release
                        [-_\.]?
                        (a|b|c|rc|alpha|beta|pre|preview)
                        [-_\.]?
                        [0-9]*
                    )?
                    (?:                                   # post release
                        (?:-[0-9]+)|(?:[-_\.]?(post|rev|r)[-_\.]?[0-9]*)
                    )?
                    (?:[-_\.]?dev[-_\.]?[0-9]*)?          # dev release
                )
            )
        
    """
    def _compare_compatible(self, prospective, spec):
        """
         type: (ParsedVersion, str) -> bool

         Compatible releases have an equivalent combination of >= and ==. That
         is that ~=2.2 is equivalent to >=2.2,==2.*. This allows us to
         implement this in terms of the other specifiers instead of
         implementing it ourselves. The only thing we need to do is construct
         the other specifiers.

         We want everything but the last item in the version, but we want to
         ignore post and dev releases and we want to treat the pre-release as
         it's own separate segment.

        """
    def _compare_equal(self, prospective, spec):
        """
         type: (ParsedVersion, str) -> bool

         We need special logic to handle prefix matching

        """
    def _compare_not_equal(self, prospective, spec):
        """
         type: (ParsedVersion, str) -> bool

        """
    def _compare_less_than_equal(self, prospective, spec):
        """
         type: (ParsedVersion, str) -> bool

         NB: Local version identifiers are NOT permitted in the version
         specifier, so local version labels can be universally removed from
         the prospective version.

        """
    def _compare_greater_than_equal(self, prospective, spec):
        """
         type: (ParsedVersion, str) -> bool

         NB: Local version identifiers are NOT permitted in the version
         specifier, so local version labels can be universally removed from
         the prospective version.

        """
    def _compare_less_than(self, prospective, spec_str):
        """
         type: (ParsedVersion, str) -> bool

         Convert our spec to a Version instance, since we'll want to work with
         it as a version.

        """
    def _compare_greater_than(self, prospective, spec_str):
        """
         type: (ParsedVersion, str) -> bool

         Convert our spec to a Version instance, since we'll want to work with
         it as a version.

        """
    def _compare_arbitrary(self, prospective, spec):
        """
         type: (Version, str) -> bool

        """
    def prereleases(self):
        """
         type: () -> bool

         If there is an explicit prereleases set for this, then we'll just
         blindly use that.

        """
    def prereleases(self, value):
        """
         type: (bool) -> None

        """
def _version_split(version):
    """
     type: (str) -> List[str]

    """
def _pad_version(left, right):
    """
     type: (List[str], List[str]) -> Tuple[List[str], List[str]]

    """
def SpecifierSet(BaseSpecifier):
    """

    """
    def __repr__(self):
        """
         type: () -> str

        """
    def __str__(self):
        """
         type: () -> str

        """
    def __hash__(self):
        """
         type: () -> int

        """
    def __and__(self, other):
        """
         type: (Union[SpecifierSet, str]) -> SpecifierSet

        """
    def __eq__(self, other):
        """
         type: (object) -> bool

        """
    def __ne__(self, other):
        """
         type: (object) -> bool

        """
    def __len__(self):
        """
         type: () -> int

        """
    def __iter__(self):
        """
         type: () -> Iterator[FrozenSet[_IndividualSpecifier]]

        """
    def prereleases(self):
        """
         type: () -> Optional[bool]

         If we have been given an explicit prerelease modifier, then we'll
         pass that through here.

        """
    def prereleases(self, value):
        """
         type: (bool) -> None

        """
    def __contains__(self, item):
        """
         type: (Union[ParsedVersion, str]) -> bool

        """
    def contains(self, item, prereleases=None):
        """
         type: (Union[ParsedVersion, str], Optional[bool]) -> bool

         Ensure that our item is a Version or LegacyVersion instance.

        """
2021-03-02 20:50:48,373 : INFO : tokenize_signature : --> do i ever get here?
2021-03-02 20:50:48,373 : INFO : tokenize_signature : --> do i ever get here?
2021-03-02 20:50:48,373 : INFO : tokenize_signature : --> do i ever get here?
2021-03-02 20:50:48,373 : INFO : tokenize_signature : --> do i ever get here?
    def filter(
        self,
        iterable,  # type: Iterable[Union[ParsedVersion, str]]
        prereleases=None,  # type: Optional[bool]
    ):
        """
         type: (...) -> Iterable[Union[ParsedVersion, str]]

         Determine if we're forcing a prerelease or not, if we're not forcing
         one for this particular filter call, then we'll use whatever the
         SpecifierSet thinks for whether or not we should support prereleases.

        """
