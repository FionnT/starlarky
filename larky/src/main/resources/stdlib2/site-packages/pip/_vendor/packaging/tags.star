def Tag(object):
    """

        A representation of the tag triple for a wheel.

        Instances are considered immutable and thus are hashable. Equality checking
        is also supported.
    
    """
    def __init__(self, interpreter, abi, platform):
        """
         type: (str, str, str) -> None

        """
    def interpreter(self):
        """
         type: () -> str

        """
    def abi(self):
        """
         type: () -> str

        """
    def platform(self):
        """
         type: () -> str

        """
    def __eq__(self, other):
        """
         type: (object) -> bool

        """
    def __hash__(self):
        """
         type: () -> int

        """
    def __str__(self):
        """
         type: () -> str

        """
    def __repr__(self):
        """
         type: () -> str

        """
def parse_tag(tag):
    """
     type: (str) -> FrozenSet[Tag]

    """
def _warn_keyword_parameter(func_name, kwargs):
    """
     type: (str, Dict[str, bool]) -> bool

    """
def _get_config_var(name, warn=False):
    """
     type: (str, bool) -> Union[int, str, None]

    """
def _normalize_string(string):
    """
     type: (str) -> str

    """
def _abi3_applies(python_version):
    """
     type: (PythonVersion) -> bool

    """
def _cpython_abis(py_version, warn=False):
    """
     type: (PythonVersion, bool) -> List[str]

    """
2021-03-02 20:50:46,547 : INFO : tokenize_signature : --> do i ever get here?
2021-03-02 20:50:46,548 : INFO : tokenize_signature : --> do i ever get here?
2021-03-02 20:50:46,548 : INFO : tokenize_signature : --> do i ever get here?
2021-03-02 20:50:46,548 : INFO : tokenize_signature : --> do i ever get here?
2021-03-02 20:50:46,548 : INFO : tokenize_signature : --> do i ever get here?
def cpython_tags(
    python_version=None,  # type: Optional[PythonVersion]
    abis=None,  # type: Optional[Iterable[str]]
    platforms=None,  # type: Optional[Iterable[str]]
    **kwargs  # type: bool
):
    """
     type: (...) -> Iterator[Tag]

    """
def _generic_abi():
    """
     type: () -> Iterator[str]

    """
2021-03-02 20:50:46,549 : INFO : tokenize_signature : --> do i ever get here?
2021-03-02 20:50:46,549 : INFO : tokenize_signature : --> do i ever get here?
2021-03-02 20:50:46,549 : INFO : tokenize_signature : --> do i ever get here?
2021-03-02 20:50:46,549 : INFO : tokenize_signature : --> do i ever get here?
2021-03-02 20:50:46,549 : INFO : tokenize_signature : --> do i ever get here?
def generic_tags(
    interpreter=None,  # type: Optional[str]
    abis=None,  # type: Optional[Iterable[str]]
    platforms=None,  # type: Optional[Iterable[str]]
    **kwargs  # type: bool
):
    """
     type: (...) -> Iterator[Tag]

    """
def _py_interpreter_range(py_version):
    """
     type: (PythonVersion) -> Iterator[str]

    """
2021-03-02 20:50:46,550 : INFO : tokenize_signature : --> do i ever get here?
2021-03-02 20:50:46,550 : INFO : tokenize_signature : --> do i ever get here?
2021-03-02 20:50:46,550 : INFO : tokenize_signature : --> do i ever get here?
2021-03-02 20:50:46,550 : INFO : tokenize_signature : --> do i ever get here?
def compatible_tags(
    python_version=None,  # type: Optional[PythonVersion]
    interpreter=None,  # type: Optional[str]
    platforms=None,  # type: Optional[Iterable[str]]
):
    """
     type: (...) -> Iterator[Tag]

    """
def _mac_arch(arch, is_32bit=_32_BIT_INTERPRETER):
    """
     type: (str, bool) -> str

    """
def _mac_binary_formats(version, cpu_arch):
    """
     type: (MacVersion, str) -> List[str]

    """
def mac_platforms(version=None, arch=None):
    """
     type: (Optional[MacVersion], Optional[str]) -> Iterator[str]

    """
def _is_manylinux_compatible(name, glibc_version):
    """
     type: (str, GlibcVersion) -> bool
     Check for presence of _manylinux module.

    """
def _glibc_version_string():
    """
     type: () -> Optional[str]
     Returns glibc version string, or None if not using glibc.

    """
def _glibc_version_string_confstr():
    """
     type: () -> Optional[str]

    """
def _glibc_version_string_ctypes():
    """
     type: () -> Optional[str]

    """
def _check_glibc_version(version_str, required_major, minimum_minor):
    """
     type: (str, int, int) -> bool
     Parse string and check against requested version.

     We use a regexp instead of str.split because we want to discard any
     random junk that might come after the minor version -- this might happen
     in patched/forked versions of glibc (e.g. Linaro's version of glibc
     uses version strings like "2.20-2014.11"). See gh-3588.

    """
def _have_compatible_glibc(required_major, minimum_minor):
    """
     type: (int, int) -> bool

    """
def _ELFFileHeader(object):
    """
     https://en.wikipedia.org/wiki/Executable_and_Linkable_Format#File_header

    """
    def _InvalidELFFileHeader(ValueError):
    """

            An invalid ELF file header was found.
        
    """
    def __init__(self, file):
        """
         type: (IO[bytes]) -> None

        """
        def unpack(fmt):
            """
             type: (str) -> int

            """
def _get_elf_header():
    """
     type: () -> Optional[_ELFFileHeader]

    """
def _is_linux_armhf():
    """
     type: () -> bool
     hard-float ABI can be detected from the ELF header of the running
     process
     https://static.docs.arm.com/ihi0044/g/aaelf32.pdf

    """
def _is_linux_i686():
    """
     type: () -> bool

    """
def _have_compatible_manylinux_abi(arch):
    """
     type: (str) -> bool

    """
def _linux_platforms(is_32bit=_32_BIT_INTERPRETER):
    """
     type: (bool) -> Iterator[str]

    """
def _generic_platforms():
    """
     type: () -> Iterator[str]

    """
def _platform_tags():
    """
     type: () -> Iterator[str]

    """
def interpreter_name():
    """
     type: () -> str

    """
def interpreter_version(**kwargs):
    """
     type: (bool) -> str

    """
def _version_nodot(version):
    """
     type: (PythonVersion) -> str

    """
def sys_tags(**kwargs):
    """
     type: (bool) -> Iterator[Tag]

    """
