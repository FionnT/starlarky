    def _derive_abi():
        """
        'cp'
        """
def Mounter(object):
    """
    'unable to find extension for %s'
    """
def Wheel(object):
    """

        Class to build and install from Wheel files (PEP 427).
    
    """
    def __init__(self, filename=None, sign=False, verify=False):
        """

                Initialise an instance using a (valid) filename.
        
        """
    def filename(self):
        """

                Build and return a filename from the various components.
        
        """
    def exists(self):
        """
        '%s-%s'
        """
    def get_wheel_metadata(self, zf):
        """
        '%s-%s'
        """
    def info(self):
        """
        'r'
        """
    def process_shebang(self, data):
        """
         Preserve any arguments after the interpreter

        """
    def get_hash(self, data, hash_kind=None):
        """
        'Unsupported hash algorithm: %r'
        """
    def write_record(self, records, record_path, base):
        """
         make a copy, as mutated
        """
    def write_records(self, info, libdir, archive_paths):
        """
        'rb'
        """
    def build_zip(self, pathname, archive_paths):
        """
        'w'
        """
    def build(self, paths, tags=None, wheel_version=None):
        """

                Build a wheel from files in specified paths, and use any specified tags
                when determining the name of the wheel.
        
        """
        def sorter(t):
            """
            '/'
            """
    def skip_entry(self, arcname):
        """

                Determine whether an archive entry should be skipped when verifying
                or installing.
        
        """
    def install(self, paths, maker, **kwargs):
        """

                Install a wheel to the specified paths. If kwarg ``warner`` is
                specified, it should be a callable, which will be called with two
                tuples indicating the wheel version of this software and the wheel
                version in the file, if there is a discrepancy in the versions.
                This can be used to issue any warnings to raise any exceptions.
                If kwarg ``lib_only`` is True, only the purelib/platlib files are
                installed, and the headers, scripts, data and dist-info metadata are
                not written. If kwarg ``bytecode_hashed_invalidation`` is True, written
                bytecode will try to use file-hash based invalidation (PEP-552) on
                supported interpreter versions (CPython 2.7+).

                The return value is a :class:`InstalledDistribution` instance unless
                ``options.lib_only`` is True, in which case the return value is ``None``.
        
        """
    def _get_dylib_cache(self):
        """
         Use native string to avoid issues on 2.x: see Python #20140.

        """
    def _get_extensions(self):
        """
        '%s-%s'
        """
    def is_compatible(self):
        """

                Determine if a wheel is compatible with the running system.
        
        """
    def is_mountable(self):
        """

                Determine if a wheel is asserted as mountable by its metadata.
        
        """
    def mount(self, append=False):
        """
        'Wheel %s not compatible with this Python.'
        """
    def unmount(self):
        """
        '%s not in path'
        """
    def verify(self):
        """
        '%s-%s'
        """
    def update(self, modifier, dest_dir=None, **kwargs):
        """

                Update the contents of a wheel in a generic way. The modifier should
                be a callable which expects a dictionary argument: its keys are
                archive-entry paths, and its values are absolute filesystem paths
                where the contents the corresponding archive entries can be found. The
                modifier is free to change the contents of the files pointed to, add
                new entries and remove entries, before returning. This method will
                extract the entire contents of the wheel to a temporary location, call
                the modifier, and then use the passed (and possibly updated)
                dictionary to write a new wheel. If ``dest_dir`` is specified, the new
                wheel is written there -- otherwise, the original wheel is overwritten.

                The modifier should return True if it updated the wheel, else False.
                This method returns the same value the modifier returns.
        
        """
        def get_version(path_map, info_dir):
            """
            '%s/%s'
            """
        def update_version(version, path):
            """
            '-'
            """
def compatible_tags():
    """

        Return (pyver, abi, arch) tuples compatible with this Python.
    
    """
def is_compatible(wheel, tags=None):
    """
     assume it's a filename
    """
