def _b64_decode_bytes(b):
    """
    ascii
    """
def _b64_decode_str(s):
    """
    utf8
    """
def Serializer(object):
    """
     NOTE: 99% sure this is dead code. I'm only leaving it
           here b/c I don't have a test yet to prove
           it. Basically, before using
           `cachecontrol.filewrapper.CallbackFileWrapper`,
           this made an effort to reset the file handle. The
           `CallbackFileWrapper` short circuits this code by
           setting the body as the content is consumed, the
           result being a `body` argument is *always* passed
           into cache_response, and in turn,
           `Serializer.dump`.

    """
    def loads(self, request, data):
        """
         Short circuit if we've been given an empty set of data

        """
    def prepare_response(self, request, cached):
        """
        Verify our vary headers match and construct a real urllib3
                HTTPResponse object.
        
        """
    def _loads_v0(self, request, data):
        """
         The original legacy cache data. This doesn't contain enough
         information to construct everything we need, so we'll treat this as
         a miss.

        """
    def _loads_v1(self, request, data):
        """
        utf8
        """
    def _loads_v3(self, request, data):
        """
         Due to Python 2 encoding issues, it's impossible to know for sure
         exactly how to load v3 entries, thus we'll treat these as a miss so
         that they get rewritten out as v4 entries.

        """
    def _loads_v4(self, request, data):
