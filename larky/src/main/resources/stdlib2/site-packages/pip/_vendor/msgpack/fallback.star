    def dict_iteritems(d):
        """
         Ugly hack...

        """
    def _is_recursionerror(e):
        """
        maximum recursion depth exceeded
        """
    def _is_recursionerror(e):
        """
        pypy_version_info
        """
    def StringIO(object):
    """
    b
    """
        def write(self, s):
            """
            cannot unpack from multi-byte object
            """
def unpackb(packed, **kwargs):
    """

        Unpack an object from `packed`.

        Raises ``ExtraData`` when *packed* contains extra bytes.
        Raises ``ValueError`` when *packed* is incomplete.
        Raises ``FormatError`` when *packed* is not valid msgpack.
        Raises ``StackError`` when *packed* contains too nested.
        Other exceptions can be raised during unpacking.

        See :class:`Unpacker` for options.
    
    """
    def _unpack_from(f, b, o=0):
        """
        Explicit type cast for legacy struct.unpack_from
        """
def Unpacker(object):
    """
    Streaming unpacker.

        Arguments:

        :param file_like:
            File-like object having `.read(n)` method.
            If specified, unpacker reads serialized data from it and :meth:`feed()` is not usable.

        :param int read_size:
            Used as `file_like.read(read_size)`. (default: `min(16*1024, max_buffer_size)`)

        :param bool use_list:
            If true, unpack msgpack array to Python list.
            Otherwise, unpack to Python tuple. (default: True)

        :param bool raw:
            If true, unpack msgpack raw to Python bytes.
            Otherwise, unpack to Python str by decoding with UTF-8 encoding (default).

        :param int timestamp:
            Control how timestamp type is unpacked:

                0 - Timestamp
                1 - float  (Seconds from the EPOCH)
                2 - int  (Nanoseconds from the EPOCH)
                3 - datetime.datetime  (UTC).  Python 2 is not supported.

        :param bool strict_map_key:
            If true (default), only str or bytes are accepted for map (dict) keys.

        :param callable object_hook:
            When specified, it should be callable.
            Unpacker calls it with a dict argument after unpacking msgpack map.
            (See also simplejson)

        :param callable object_pairs_hook:
            When specified, it should be callable.
            Unpacker calls it with a list of key-value pairs after unpacking msgpack map.
            (See also simplejson)

        :param str unicode_errors:
            The error handler for decoding unicode. (default: 'strict')
            This option should be used only when you have msgpack data which
            contains invalid UTF-8 string.

        :param int max_buffer_size:
            Limits size of data waiting unpacked.  0 means 2**32-1.
            The default value is 100*1024*1024 (100MiB).
            Raises `BufferFull` exception when it is insufficient.
            You should set this parameter when unpacking data from untrusted source.

        :param int max_str_len:
            Deprecated, use *max_buffer_size* instead.
            Limits max length of str. (default: max_buffer_size)

        :param int max_bin_len:
            Deprecated, use *max_buffer_size* instead.
            Limits max length of bin. (default: max_buffer_size)

        :param int max_array_len:
            Limits max length of array.
            (default: max_buffer_size)

        :param int max_map_len:
            Limits max length of map.
            (default: max_buffer_size//2)

        :param int max_ext_len:
            Deprecated, use *max_buffer_size* instead.
            Limits max size of ext type.  (default: max_buffer_size)

        Example of streaming deserialize from file-like object::

            unpacker = Unpacker(file_like)
            for o in unpacker:
                process(o)

        Example of streaming deserialize from socket::

            unpacker = Unpacker(max_buffer_size)
            while True:
                buf = sock.recv(1024**2)
                if not buf:
                    break
                unpacker.feed(buf)
                for o in unpacker:
                    process(o)

        Raises ``ExtraData`` when *packed* contains extra bytes.
        Raises ``OutOfData`` when *packed* is incomplete.
        Raises ``FormatError`` when *packed* is not valid msgpack.
        Raises ``StackError`` when *packed* contains too nested.
        Other exceptions can be raised during unpacking.
    
    """
2021-03-02 20:50:49,287 : INFO : tokenize_signature : --> do i ever get here?
2021-03-02 20:50:49,287 : INFO : tokenize_signature : --> do i ever get here?
2021-03-02 20:50:49,287 : INFO : tokenize_signature : --> do i ever get here?
2021-03-02 20:50:49,287 : INFO : tokenize_signature : --> do i ever get here?
2021-03-02 20:50:49,287 : INFO : tokenize_signature : --> do i ever get here?
2021-03-02 20:50:49,287 : INFO : tokenize_signature : --> do i ever get here?
2021-03-02 20:50:49,287 : INFO : tokenize_signature : --> do i ever get here?
2021-03-02 20:50:49,287 : INFO : tokenize_signature : --> do i ever get here?
2021-03-02 20:50:49,287 : INFO : tokenize_signature : --> do i ever get here?
2021-03-02 20:50:49,288 : INFO : tokenize_signature : --> do i ever get here?
2021-03-02 20:50:49,288 : INFO : tokenize_signature : --> do i ever get here?
2021-03-02 20:50:49,288 : INFO : tokenize_signature : --> do i ever get here?
2021-03-02 20:50:49,288 : INFO : tokenize_signature : --> do i ever get here?
2021-03-02 20:50:49,288 : INFO : tokenize_signature : --> do i ever get here?
2021-03-02 20:50:49,288 : INFO : tokenize_signature : --> do i ever get here?
2021-03-02 20:50:49,288 : INFO : tokenize_signature : --> do i ever get here?
2021-03-02 20:50:49,288 : INFO : tokenize_signature : --> do i ever get here?
2021-03-02 20:50:49,288 : INFO : tokenize_signature : --> do i ever get here?
2021-03-02 20:50:49,288 : INFO : tokenize_signature : --> do i ever get here?
    def __init__(
        self,
        file_like=None,
        read_size=0,
        use_list=True,
        raw=False,
        timestamp=0,
        strict_map_key=True,
        object_hook=None,
        object_pairs_hook=None,
        list_hook=None,
        unicode_errors=None,
        max_buffer_size=100 * 1024 * 1024,
        ext_hook=ExtType,
        max_str_len=-1,
        max_bin_len=-1,
        max_array_len=-1,
        max_map_len=-1,
        max_ext_len=-1,
    ):
        """
        strict
        """
    def feed(self, next_bytes):
        """
         Strip buffer before checkpoint before reading file.

        """
    def _consume(self):
        """
         Gets rid of the used parts of the buffer. 
        """
    def _got_extradata(self):
        """
         (int) -> bytearray

        """
    def _reserve(self, n):
        """
         Fast path: buffer has n bytes already

        """
    def _read_header(self, execute=EX_CONSTRUCT):
        """
        %s exceeds max_str_len(%s)
        """
    def _unpack(self, execute=EX_CONSTRUCT):
        """
        Expected array
        """
    def __iter__(self):
        """

            MessagePack Packer

            Usage:

                packer = Packer()
                astream.write(packer.pack(a))
                astream.write(packer.pack(b))

            Packer's constructor has some keyword arguments:

            :param callable default:
                Convert user type to builtin type that Packer supports.
                See also simplejson's document.

            :param bool use_single_float:
                Use single precision float type for float. (default: False)

            :param bool autoreset:
                Reset buffer after each pack and return its content as `bytes`. (default: True).
                If set this to false, use `bytes()` to get content and `.reset()` to clear buffer.

            :param bool use_bin_type:
                Use bin type introduced in msgpack spec 2.0 for bytes.
                It also enables str8 type for unicode. (default: True)

            :param bool strict_types:
                If set to true, types will be checked to be exact. Derived classes
                from serializable types will not be serialized and will be
                treated as unsupported type and forwarded to default.
                Additionally tuples will not be serialized as lists.
                This is useful when trying to implement accurate serialization
                for python types.

            :param bool datetime:
                If set to true, datetime with tzinfo is packed into Timestamp type.
                Note that the tzinfo is stripped in the timestamp.
                You can get UTC datetime with `timestamp=3` option of the Unpacker.
                (Python 2 is not supported).

            :param str unicode_errors:
                The error handler for encoding unicode. (default: 'strict')
                DO NOT USE THIS!!  This option is kept for very specific usage.
    
        """
2021-03-02 20:50:49,302 : INFO : tokenize_signature : --> do i ever get here?
2021-03-02 20:50:49,302 : INFO : tokenize_signature : --> do i ever get here?
2021-03-02 20:50:49,302 : INFO : tokenize_signature : --> do i ever get here?
2021-03-02 20:50:49,302 : INFO : tokenize_signature : --> do i ever get here?
2021-03-02 20:50:49,302 : INFO : tokenize_signature : --> do i ever get here?
2021-03-02 20:50:49,302 : INFO : tokenize_signature : --> do i ever get here?
2021-03-02 20:50:49,302 : INFO : tokenize_signature : --> do i ever get here?
2021-03-02 20:50:49,302 : INFO : tokenize_signature : --> do i ever get here?
2021-03-02 20:50:49,302 : INFO : tokenize_signature : --> do i ever get here?
    def __init__(
        self,
        default=None,
        use_single_float=False,
        autoreset=True,
        use_bin_type=True,
        strict_types=False,
        datetime=False,
        unicode_errors=None,
    ):
        """
        datetime is not supported in Python 2
        """
2021-03-02 20:50:49,303 : INFO : tokenize_signature : --> do i ever get here?
2021-03-02 20:50:49,303 : INFO : tokenize_signature : --> do i ever get here?
2021-03-02 20:50:49,303 : INFO : tokenize_signature : --> do i ever get here?
2021-03-02 20:50:49,303 : INFO : tokenize_signature : --> do i ever get here?
2021-03-02 20:50:49,303 : INFO : tokenize_signature : --> do i ever get here?
2021-03-02 20:50:49,303 : INFO : tokenize_signature : --> do i ever get here?
    def _pack(
        self,
        obj,
        nest_limit=DEFAULT_RECURSE_LIMIT,
        check=isinstance,
        check_type_strict=_check_type_strict,
    ):
        """
        recursion limit exceeded
        """
    def pack(self, obj):
        """
         force reset
        """
    def pack_map_pairs(self, pairs):
        """
        typecode must have int type.
        """
    def _pack_array_header(self, n):
        """
        B
        """
    def _pack_map_header(self, n):
        """
        B
        """
    def _pack_map_pairs(self, n, pairs, nest_limit=DEFAULT_RECURSE_LIMIT):
        """
        B
        """
    def _pack_bin_header(self, n):
        """
        >BB
        """
    def bytes(self):
        """
        Return internal buffer contents as bytes object
        """
    def reset(self):
        """
        Reset internal buffer.

                This method is useful only when autoreset=False.
        
        """
    def getbuffer(self):
        """
        Return view of internal buffer.
        """
