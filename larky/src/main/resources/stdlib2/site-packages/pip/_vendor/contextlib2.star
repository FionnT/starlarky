def _classic_mro(C, result):
    """
     Backport _collections_abc._check_methods

    """
def _check_methods(C, *methods):
    """
    An abstract base class for context managers.
    """
    def __enter__(self):
        """
        Return `self` upon entering the runtime context.
        """
    def __exit__(self, exc_type, exc_value, traceback):
        """
        Raise any exception triggered within the runtime context.
        """
    def __subclasshook__(cls, C):
        """
        Check whether subclass is considered a subclass of this ABC.
        """
def ContextDecorator(object):
    """
    A base class or mixin that enables context managers to work as decorators.
    """
    def refresh_cm(self):
        """
        Returns the context manager used to actually wrap the call to the
                decorated function.

                The default implementation just returns *self*.

                Overriding this method allows otherwise one-shot context managers
                like _GeneratorContextManager to support use as decorators via
                implicit recreation.

                DEPRECATED: refresh_cm was never added to the standard library's
                            ContextDecorator API
        
        """
    def _recreate_cm(self):
        """
        Return a recreated instance of self.

                Allows an otherwise one-shot context manager like
                _GeneratorContextManager to support use as
                a decorator via implicit recreation.

                This is a private interface just for _GeneratorContextManager.
                See issue #11647 for details.
        
        """
    def __call__(self, func):
        """
        Helper for @contextmanager decorator.
        """
    def __init__(self, func, args, kwds):
        """
         Issue 19330: ensure context manager instances have good docstrings

        """
    def _recreate_cm(self):
        """
         _GCM instances are one-shot context managers, so the
         CM must be recreated each time a decorated function is
         called

        """
    def __enter__(self):
        """
        generator didn't yield
        """
    def __exit__(self, type, value, traceback):
        """
        generator didn't stop
        """
def contextmanager(func):
    """
    @contextmanager decorator.

        Typical usage:

            @contextmanager
            def some_generator(<arguments>):
                <setup>
                try:
                    yield <value>
                finally:
                    <cleanup>

        This makes this:

            with some_generator(<arguments>) as <variable>:
                <body>

        equivalent to this:

            <setup>
            try:
                <variable> = <value>
                <body>
            finally:
                <cleanup>

    
    """
    def helper(*args, **kwds):
        """
        Context to automatically close something at the end of a block.

            Code like this:

                with closing(<module>.open(<arguments>)) as f:
                    <block>

            is equivalent to this:

                f = <module>.open(<arguments>)
                try:
                    <block>
                finally:
                    f.close()

    
        """
    def __init__(self, thing):
        """
         We use a list of old targets to make this CM re-entrant

        """
    def __enter__(self):
        """
        Context manager for temporarily redirecting stdout to another file.

                # How to send help() to stderr
                with redirect_stdout(sys.stderr):
                    help(dir)

                # How to write help() to a file
                with open('help.txt', 'w') as f:
                    with redirect_stdout(f):
                        help(pow)
    
        """
def redirect_stderr(_RedirectStream):
    """
    Context manager for temporarily redirecting stderr to another file.
    """
def suppress(object):
    """
    Context manager to suppress specified exceptions

        After the exception is suppressed, execution proceeds with the next
        statement following the with statement.

             with suppress(FileNotFoundError):
                 os.remove(somefile)
             # Execution still resumes here if the file was already removed
    
    """
    def __init__(self, *exceptions):
        """
         Unlike isinstance and issubclass, CPython exception handling
         currently only looks at the concrete type hierarchy (ignoring
         the instance and subclass checking hooks). While Guido considers
         that a bug rather than a feature, it's a fairly hard one to fix
         due to various internal implementation details. suppress provides
         the simpler issubclass based semantics, rather than trying to
         exactly reproduce the limitations of the CPython interpreter.

         See http://bugs.python.org/issue12029 for more details

        """
    def _make_context_fixer(frame_exc):
        """
         Context may not be correct, so find the end of the chain

        """
    def _reraise_with_existing_context(exc_details):
        """
         bare "raise exc_details[1]" replaces our carefully
         set-up context

        """
    def _make_context_fixer(frame_exc):
        """
         Use 3 argument raise in Python 2,
         but use exec to avoid SyntaxError in Python 3

        """
    def _reraise_with_existing_context(exc_details):
        """
        raise exc_type, exc_value, exc_tb
        """
    def _get_type(obj):
        """
         Old-style class
        """
def ExitStack(object):
    """
    Context manager for dynamic management of a stack of exit callbacks

        For example:

            with ExitStack() as stack:
                files = [stack.enter_context(open(fname)) for fname in filenames]
                # All opened files will automatically be closed at the end of
                # the with statement, even if attempts to open files later
                # in the list raise an exception

    
    """
    def __init__(self):
        """
        Preserve the context stack by transferring it to a new instance
        """
    def _push_cm_exit(self, cm, cm_exit):
        """
        Helper to correctly register callbacks to __exit__ methods
        """
        def _exit_wrapper(*exc_details):
            """
            Registers a callback with the standard __exit__ method signature

                    Can suppress exceptions the same way __exit__ methods can.

                    Also accepts any object with an __exit__ method (registering a call
                    to the method instead of the object itself)
        
            """
    def callback(self, callback, *args, **kwds):
        """
        Registers an arbitrary callback and arguments.

                Cannot suppress exceptions.
        
        """
        def _exit_wrapper(exc_type, exc, tb):
            """
             We changed the signature, so using @wraps is not appropriate, but
             setting __wrapped__ may still help with introspection

            """
    def enter_context(self, cm):
        """
        Enters the supplied context manager

                If successful, also pushes its __exit__ method as a callback and
                returns the result of the __enter__ method.
        
        """
    def close(self):
        """
        Immediately unwind the context stack
        """
    def __enter__(self):
        """
         We manipulate the exception state so it behaves as though
         we were actually nesting multiple with statements

        """
def ContextStack(ExitStack):
    """
    Backwards compatibility alias for ExitStack
    """
    def __init__(self):
        """
        ContextStack has been renamed to ExitStack
        """
    def register_exit(self, callback):
        """
        Context manager that does no additional processing.
            Used as a stand-in for a normal context manager, when a particular
            block of code is only sometimes used with a normal context manager:
            cm = optional_cm if condition else nullcontext()
            with cm:
                # Perform operation, using optional_cm if condition is True
    
        """
    def __init__(self, enter_result=None):
