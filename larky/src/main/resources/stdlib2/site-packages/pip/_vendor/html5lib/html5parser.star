def parse(doc, treebuilder="etree", namespaceHTMLElements=True, **kwargs):
    """
    Parse an HTML document as a string or file-like object into a tree

        :arg doc: the document to parse as a string or file-like object

        :arg treebuilder: the treebuilder to use when parsing

        :arg namespaceHTMLElements: whether or not to namespace HTML elements

        :returns: parsed tree

        Example:

        >>> from html5lib.html5parser import parse
        >>> parse('<html><body><p>This is a doc</p></body></html>')
        <Element u'{http://www.w3.org/1999/xhtml}html' at 0x7feac4909db0>

    
    """
def parseFragment(doc, container="div", treebuilder="etree", namespaceHTMLElements=True, **kwargs):
    """
    Parse an HTML fragment as a string or file-like object into a tree

        :arg doc: the fragment to parse as a string or file-like object

        :arg container: the container context to parse the fragment in

        :arg treebuilder: the treebuilder to use when parsing

        :arg namespaceHTMLElements: whether or not to namespace HTML elements

        :returns: parsed tree

        Example:

        >>> from html5lib.html5libparser import parseFragment
        >>> parseFragment('<b>this is a fragment</b>')
        <Element u'DOCUMENT_FRAGMENT' at 0x7feac484b090>

    
    """
def method_decorator_metaclass(function):
    """
    HTML parser

        Generates a tree structure from a stream of (possibly malformed) HTML.

    
    """
    def __init__(self, tree=None, strict=False, namespaceHTMLElements=True, debug=False):
        """

                :arg tree: a treebuilder class controlling the type of tree that will be
                    returned. Built in treebuilders can be accessed through
                    html5lib.treebuilders.getTreeBuilder(treeType)

                :arg strict: raise an exception when a parse error is encountered

                :arg namespaceHTMLElements: whether or not to namespace HTML elements

                :arg debug: whether or not to enable debug mode which logs things

                Example:

                >>> from html5lib.html5parser import HTMLParser
                >>> parser = HTMLParser()                     # generates parser with etree builder
                >>> parser = HTMLParser('lxml', strict=True)  # generates parser with lxml builder which is strict

        
        """
    def _parse(self, stream, innerHTML=False, container="div", scripting=False, **kwargs):
        """
         only used with debug mode
        """
    def documentEncoding(self):
        """
        Name of the character encoding that was used to decode the input stream, or
                :obj:`None` if that is not determined yet

        
        """
    def isHTMLIntegrationPoint(self, element):
        """
        annotation-xml
        """
    def isMathMLTextIntegrationPoint(self, element):
        """
        Characters
        """
    def parse(self, stream, *args, **kwargs):
        """
        Parse a HTML document into a well-formed tree

                :arg stream: a file-like object or string containing the HTML to be parsed

                    The optional encoding parameter must be a string that indicates
                    the encoding.  If specified, that encoding will be used,
                    regardless of any BOM or later declaration (such as in a meta
                    element).

                :arg scripting: treat noscript elements as if JavaScript was turned on

                :returns: parsed tree

                Example:

                >>> from html5lib.html5parser import HTMLParser
                >>> parser = HTMLParser()
                >>> parser.parse('<html><body><p>This is a doc</p></body></html>')
                <Element u'{http://www.w3.org/1999/xhtml}html' at 0x7feac4909db0>

        
        """
    def parseFragment(self, stream, *args, **kwargs):
        """
        Parse a HTML fragment into a well-formed tree fragment

                :arg container: name of the element we're setting the innerHTML
                    property if set to None, default to 'div'

                :arg stream: a file-like object or string containing the HTML to be parsed

                    The optional encoding parameter must be a string that indicates
                    the encoding.  If specified, that encoding will be used,
                    regardless of any BOM or later declaration (such as in a meta
                    element)

                :arg scripting: treat noscript elements as if JavaScript was turned on

                :returns: parsed tree

                Example:

                >>> from html5lib.html5libparser import HTMLParser
                >>> parser = HTMLParser()
                >>> parser.parseFragment('<b>this is a fragment</b>')
                <Element u'DOCUMENT_FRAGMENT' at 0x7feac484b090>

        
        """
    def parseError(self, errorcode="XXX-undefined-error", datavars=None):
        """
         XXX The idea is to make errorcode mandatory.

        """
    def adjustMathMLAttributes(self, token):
        """
         pylint:disable=unused-argument

        """
    def resetInsertionMode(self):
        """
         The name of this method is mostly historical. (It's also used in the
         specification.)

        """
    def parseRCDataRawtext(self, token, contentType):
        """
         Generic RCDATA/RAWTEXT Parsing algorithm

        """
def getPhases(debug):
    """
    Logger that records which phase processes each token
    """
        def wrapped(self, *args, **kwargs):
            """
            process
            """
    def getMetaclass(use_metaclass, metaclass_func):
        """
         pylint:disable=unused-argument

        """
    def Phase(with_metadef(getMetadef(debug, log))):
    """
    Base class for helper object that implements each phase of processing
        
    """
        def __init__(self, parser, tree):
            """
             For most phases the following is correct. Where it's not it will be
             overridden.

            """
        def processDoctype(self, token):
            """
            unexpected-doctype
            """
        def processCharacters(self, token):
            """
            data
            """
        def processSpaceCharacters(self, token):
            """
            data
            """
        def processStartTag(self, token):
            """
             Note the caching is done here rather than BoundMethodDispatcher as doing it there
             requires a circular reference to the Phase, and this ends up with a significant
             (CPython 2.7, 3.8) GC cost when parsing many short inputs

            """
        def startTagHtml(self, token):
            """
            name
            """
        def processEndTag(self, token):
            """
             Note the caching is done here rather than BoundMethodDispatcher as doing it there
             requires a circular reference to the Phase, and this ends up with a significant
             (CPython 2.7, 3.8) GC cost when parsing many short inputs

            """
    def InitialPhase(Phase):
    """
    name
    """
        def anythingElse(self):
            """
            quirks
            """
        def processCharacters(self, token):
            """
            expected-doctype-but-got-chars
            """
        def processStartTag(self, token):
            """
            expected-doctype-but-got-start-tag
            """
        def processEndTag(self, token):
            """
            expected-doctype-but-got-end-tag
            """
        def processEOF(self):
            """
            expected-doctype-but-got-eof
            """
    def BeforeHtmlPhase(Phase):
    """
     helper methods

    """
        def processEOF(self):
            """
            name
            """
        def processEndTag(self, token):
            """
            name
            """
    def BeforeHeadPhase(Phase):
    """
    head
    """
        def processSpaceCharacters(self, token):
            """
            head
            """
        def startTagHtml(self, token):
            """
            inBody
            """
        def startTagHead(self, token):
            """
            inHead
            """
        def startTagOther(self, token):
            """
            head
            """
        def endTagImplyHead(self, token):
            """
            head
            """
        def endTagOther(self, token):
            """
            end-tag-after-implied-root
            """
    def InHeadPhase(Phase):
    """
     the real thing

    """
        def processCharacters(self, token):
            """
            inBody
            """
        def startTagHead(self, token):
            """
            two-heads-are-not-better-than-one
            """
        def startTagBaseLinkCommand(self, token):
            """
            selfClosingAcknowledged
            """
        def startTagMeta(self, token):
            """
            selfClosingAcknowledged
            """
        def startTagTitle(self, token):
            """
            RCDATA
            """
        def startTagNoFramesStyle(self, token):
            """
             Need to decide whether to implement the scripting-disabled case

            """
        def startTagNoscript(self, token):
            """
            RAWTEXT
            """
        def startTagScript(self, token):
            """
            text
            """
        def startTagOther(self, token):
            """
            head
            """
        def endTagHtmlBodyBr(self, token):
            """
            unexpected-end-tag
            """
        def anythingElse(self):
            """
            head
            """
    def InHeadNoscriptPhase(Phase):
    """
    eof-in-head-noscript
    """
        def processComment(self, token):
            """
            inHead
            """
        def processCharacters(self, token):
            """
            char-in-head-noscript
            """
        def processSpaceCharacters(self, token):
            """
            inHead
            """
        def startTagHtml(self, token):
            """
            inBody
            """
        def startTagBaseLinkCommand(self, token):
            """
            inHead
            """
        def startTagHeadNoscript(self, token):
            """
            unexpected-start-tag
            """
        def startTagOther(self, token):
            """
            unexpected-inhead-noscript-tag
            """
        def endTagNoscript(self, token):
            """
            noscript
            """
        def endTagBr(self, token):
            """
            unexpected-inhead-noscript-tag
            """
        def endTagOther(self, token):
            """
            unexpected-end-tag
            """
        def anythingElse(self):
            """
             Caller must raise parse error first!

            """
    def AfterHeadPhase(Phase):
    """
    inBody
    """
        def startTagBody(self, token):
            """
            inBody
            """
        def startTagFrameset(self, token):
            """
            inFrameset
            """
        def startTagFromHead(self, token):
            """
            unexpected-start-tag-out-of-my-head
            """
        def startTagHead(self, token):
            """
            unexpected-start-tag
            """
        def startTagOther(self, token):
            """
            unexpected-end-tag
            """
        def anythingElse(self):
            """
            body
            """
    def InBodyPhase(Phase):
    """
     http://www.whatwg.org/specs/web-apps/current-work/#parsing-main-inbody
     the really-really-really-very crazy mode

    """
        def __init__(self, *args, **kwargs):
            """
             Set this to the default handler

            """
        def isMatchingFormattingElement(self, node1, node2):
            """
             helper

            """
        def addFormattingElement(self, token):
            """
             the real deal

            """
        def processEOF(self):
            """
            dd
            """
        def processSpaceCharactersDropNewline(self, token):
            """
             Sometimes (start of <pre>, <listing>, and <textarea> blocks) we
             want to drop leading newlines

            """
        def processCharacters(self, token):
            """
            data
            """
        def processSpaceCharactersNonPre(self, token):
            """
            data
            """
        def startTagProcessInHead(self, token):
            """
            inHead
            """
        def startTagBody(self, token):
            """
            unexpected-start-tag
            """
        def startTagFrameset(self, token):
            """
            unexpected-start-tag
            """
        def startTagCloseP(self, token):
            """
            p
            """
        def startTagPreListing(self, token):
            """
            p
            """
        def startTagForm(self, token):
            """
            unexpected-start-tag
            """
        def startTagListItem(self, token):
            """
            li
            """
        def startTagPlaintext(self, token):
            """
            p
            """
        def startTagHeading(self, token):
            """
            p
            """
        def startTagA(self, token):
            """
            a
            """
        def startTagFormatting(self, token):
            """
            nobr
            """
        def startTagButton(self, token):
            """
            button
            """
        def startTagAppletMarqueeObject(self, token):
            """
            p
            """
        def startTagTable(self, token):
            """
            quirks
            """
        def startTagVoidFormatting(self, token):
            """
            selfClosingAcknowledged
            """
        def startTagInput(self, token):
            """
            type
            """
        def startTagParamSource(self, token):
            """
            selfClosingAcknowledged
            """
        def startTagHr(self, token):
            """
            p
            """
        def startTagImage(self, token):
            """
             No really...

            """
        def startTagIsIndex(self, token):
            """
            deprecated-tag
            """
        def startTagTextarea(self, token):
            """
            iframe, noembed noframes, noscript(if scripting enabled)
            """
        def startTagOpt(self, token):
            """
            option
            """
        def startTagSelect(self, token):
            """
            inTable
            """
        def startTagRpRt(self, token):
            """
            ruby
            """
        def startTagMath(self, token):
            """
            namespace
            """
        def startTagSvg(self, token):
            """
            namespace
            """
        def startTagMisplaced(self, token):
            """
             Elements that should be children of other elements that have a
                        different insertion mode; here they are ignored
                        "caption", "col", "colgroup", "frame", "frameset", "head",
                        "option", "optgroup", "tbody", "td", "tfoot", "th", "thead",
                        "tr", "noscript"
            
            """
        def startTagOther(self, token):
            """
            p
            """
        def endTagBody(self, token):
            """
            body
            """
        def endTagHtml(self, token):
            """
             We repeat the test for the body end tag token being ignored here

            """
        def endTagBlock(self, token):
            """
             Put us back in the right whitespace handling mode

            """
        def endTagForm(self, token):
            """
            unexpected-end-tag
            """
        def endTagListItem(self, token):
            """
            name
            """
        def endTagHeading(self, token):
            """
            name
            """
        def endTagFormatting(self, token):
            """
            The much-feared adoption agency algorithm
            """
        def endTagAppletMarqueeObject(self, token):
            """
            name
            """
        def endTagBr(self, token):
            """
            unexpected-end-tag-treated-as
            """
        def endTagOther(self, token):
            """
            name
            """
    def TextPhase(Phase):
    """
    data
    """
        def processEOF(self):
            """
            expected-named-closing-tag-but-got-eof
            """
        def startTagOther(self, token):
            """
            Tried to process start tag %s in RCDATA/RAWTEXT mode
            """
        def endTagScript(self, token):
            """
            script
            """
        def endTagOther(self, token):
            """
            script
            """
    def InTablePhase(Phase):
    """
     http://www.whatwg.org/specs/web-apps/current-work/#in-table

    """
        def clearStackToTableContext(self):
            """
             "clear the stack back to a table context

            """
        def processEOF(self):
            """
            html
            """
        def processSpaceCharacters(self, token):
            """
            inTableText
            """
        def processCharacters(self, token):
            """
            inTableText
            """
        def insertText(self, token):
            """
             If we get here there must be at least one non-whitespace character
             Do the table magic!

            """
        def startTagCaption(self, token):
            """
            inCaption
            """
        def startTagColgroup(self, token):
            """
            inColumnGroup
            """
        def startTagCol(self, token):
            """
            colgroup
            """
        def startTagRowGroup(self, token):
            """
            inTableBody
            """
        def startTagImplyTbody(self, token):
            """
            tbody
            """
        def startTagTable(self, token):
            """
            unexpected-start-tag-implies-end-tag
            """
        def startTagStyleScript(self, token):
            """
            inHead
            """
        def startTagInput(self, token):
            """
            type
            """
        def startTagForm(self, token):
            """
            unexpected-form-in-table
            """
        def startTagOther(self, token):
            """
            unexpected-start-tag-implies-table-voodoo
            """
        def endTagTable(self, token):
            """
            table
            """
        def endTagIgnore(self, token):
            """
            unexpected-end-tag
            """
        def endTagOther(self, token):
            """
            unexpected-end-tag-implies-table-voodoo
            """
    def InTableTextPhase(Phase):
    """
    originalPhase
    """
        def __init__(self, *args, **kwargs):
            """

            """
        def processComment(self, token):
            """
            data
            """
        def processSpaceCharacters(self, token):
            """
             pretty sure we should never reach here

            """
        def processStartTag(self, token):
            """
             http://www.whatwg.org/specs/web-apps/current-work/#in-caption

            """
        def ignoreEndTagCaption(self):
            """
            caption
            """
        def processEOF(self):
            """
            inBody
            """
        def processCharacters(self, token):
            """
            inBody
            """
        def startTagTableElement(self, token):
            """
             XXX Have to duplicate logic here to find out if the tag is ignored

            """
        def startTagOther(self, token):
            """
            inBody
            """
        def endTagCaption(self, token):
            """
             AT this code is quite similar to endTagTable in "InTable

            """
        def endTagTable(self, token):
            """
            caption
            """
        def endTagIgnore(self, token):
            """
            unexpected-end-tag
            """
        def endTagOther(self, token):
            """
            inBody
            """
    def InColumnGroupPhase(Phase):
    """
     http://www.whatwg.org/specs/web-apps/current-work/#in-column

    """
        def ignoreEndTagColgroup(self):
            """
            html
            """
        def processEOF(self):
            """
            html
            """
        def processCharacters(self, token):
            """
            colgroup
            """
        def startTagCol(self, token):
            """
            selfClosingAcknowledged
            """
        def startTagOther(self, token):
            """
            colgroup
            """
        def endTagColgroup(self, token):
            """
             innerHTML case

            """
        def endTagCol(self, token):
            """
            no-end-tag
            """
        def endTagOther(self, token):
            """
            colgroup
            """
    def InTableBodyPhase(Phase):
    """
     http://www.whatwg.org/specs/web-apps/current-work/#in-table0

    """
        def clearStackToTableBodyContext(self):
            """
            tbody
            """
        def processEOF(self):
            """
            inTable
            """
        def processSpaceCharacters(self, token):
            """
            inTable
            """
        def processCharacters(self, token):
            """
            inTable
            """
        def startTagTr(self, token):
            """
            inRow
            """
        def startTagTableCell(self, token):
            """
            unexpected-cell-in-table-body
            """
        def startTagTableOther(self, token):
            """
             XXX AT Any ideas on how to share this with endTagTable?

            """
        def startTagOther(self, token):
            """
            inTable
            """
        def endTagTableRowGroup(self, token):
            """
            name
            """
        def endTagTable(self, token):
            """
            tbody
            """
        def endTagIgnore(self, token):
            """
            unexpected-end-tag-in-table-body
            """
        def endTagOther(self, token):
            """
            inTable
            """
    def InRowPhase(Phase):
    """
     http://www.whatwg.org/specs/web-apps/current-work/#in-row

    """
        def clearStackToTableRowContext(self):
            """
            tr
            """
        def ignoreEndTagTr(self):
            """
            tr
            """
        def processEOF(self):
            """
            inTable
            """
        def processSpaceCharacters(self, token):
            """
            inTable
            """
        def processCharacters(self, token):
            """
            inTable
            """
        def startTagTableCell(self, token):
            """
            inCell
            """
        def startTagTableOther(self, token):
            """
            tr
            """
        def startTagOther(self, token):
            """
            inTable
            """
        def endTagTr(self, token):
            """
            inTableBody
            """
        def endTagTable(self, token):
            """
            tr
            """
        def endTagTableRowGroup(self, token):
            """
            name
            """
        def endTagIgnore(self, token):
            """
            unexpected-end-tag-in-table-row
            """
        def endTagOther(self, token):
            """
            inTable
            """
    def InCellPhase(Phase):
    """
     http://www.whatwg.org/specs/web-apps/current-work/#in-cell

    """
        def closeCell(self):
            """
            td
            """
        def processEOF(self):
            """
            inBody
            """
        def processCharacters(self, token):
            """
            inBody
            """
        def startTagTableOther(self, token):
            """
            td
            """
        def startTagOther(self, token):
            """
            inBody
            """
        def endTagTableCell(self, token):
            """
            name
            """
        def endTagIgnore(self, token):
            """
            unexpected-end-tag
            """
        def endTagImply(self, token):
            """
            name
            """
        def endTagOther(self, token):
            """
            inBody
            """
    def InSelectPhase(Phase):
    """
     http://www.whatwg.org/specs/web-apps/current-work/#in-select

    """
        def processCharacters(self, token):
            """
            data
            """
        def startTagOption(self, token):
            """
             We need to imply </option> if <option> is the current node.

            """
        def startTagOptgroup(self, token):
            """
            option
            """
        def startTagSelect(self, token):
            """
            unexpected-select-in-select
            """
        def startTagInput(self, token):
            """
            unexpected-input-in-select
            """
        def startTagScript(self, token):
            """
            inHead
            """
        def startTagOther(self, token):
            """
            unexpected-start-tag-in-select
            """
        def endTagOption(self, token):
            """
            option
            """
        def endTagOptgroup(self, token):
            """
             </optgroup> implicitly closes <option>

            """
        def endTagSelect(self, token):
            """
            select
            """
        def endTagOther(self, token):
            """
            unexpected-end-tag-in-select
            """
    def InSelectInTablePhase(Phase):
    """
    inSelect
    """
        def processCharacters(self, token):
            """
            inSelect
            """
        def startTagTable(self, token):
            """
            unexpected-table-element-start-tag-in-select-in-table
            """
        def startTagOther(self, token):
            """
            inSelect
            """
        def endTagTable(self, token):
            """
            unexpected-table-element-end-tag-in-select-in-table
            """
        def endTagOther(self, token):
            """
            inSelect
            """
    def InForeignContentPhase(Phase):
    """
    b
    """
        def adjustSVGTagNames(self, token):
            """
            altglyph
            """
        def processCharacters(self, token):
            """
            data
            """
        def processStartTag(self, token):
            """
            name
            """
        def processEndTag(self, token):
            """
            name
            """
    def AfterBodyPhase(Phase):
    """
     Stop parsing

    """
        def processComment(self, token):
            """
             This is needed because data is to be appended to the <html> element
             here and not to whatever is currently open.

            """
        def processCharacters(self, token):
            """
            unexpected-char-after-body
            """
        def startTagHtml(self, token):
            """
            inBody
            """
        def startTagOther(self, token):
            """
            unexpected-start-tag-after-body
            """
        def endTagHtml(self, name):
            """
            unexpected-end-tag-after-body-innerhtml
            """
        def endTagOther(self, token):
            """
            unexpected-end-tag-after-body
            """
    def InFramesetPhase(Phase):
    """
     http://www.whatwg.org/specs/web-apps/current-work/#in-frameset

    """
        def processEOF(self):
            """
            html
            """
        def processCharacters(self, token):
            """
            unexpected-char-in-frameset
            """
        def startTagFrameset(self, token):
            """
            inBody
            """
        def startTagOther(self, token):
            """
            unexpected-start-tag-in-frameset
            """
        def endTagFrameset(self, token):
            """
            html
            """
        def endTagOther(self, token):
            """
            unexpected-end-tag-in-frameset
            """
    def AfterFramesetPhase(Phase):
    """
     http://www.whatwg.org/specs/web-apps/current-work/#after3

    """
        def processEOF(self):
            """
             Stop parsing

            """
        def processCharacters(self, token):
            """
            unexpected-char-after-frameset
            """
        def startTagNoframes(self, token):
            """
            inHead
            """
        def startTagOther(self, token):
            """
            unexpected-start-tag-after-frameset
            """
        def endTagHtml(self, token):
            """
            afterAfterFrameset
            """
        def endTagOther(self, token):
            """
            unexpected-end-tag-after-frameset
            """
    def AfterAfterBodyPhase(Phase):
    """
    inBody
    """
        def processCharacters(self, token):
            """
            expected-eof-but-got-char
            """
        def startTagHtml(self, token):
            """
            inBody
            """
        def startTagOther(self, token):
            """
            expected-eof-but-got-start-tag
            """
        def processEndTag(self, token):
            """
            expected-eof-but-got-end-tag
            """
    def AfterAfterFramesetPhase(Phase):
    """
    inBody
    """
        def processCharacters(self, token):
            """
            expected-eof-but-got-char
            """
        def startTagHtml(self, token):
            """
            inBody
            """
        def startTagNoFrames(self, token):
            """
            inHead
            """
        def startTagOther(self, token):
            """
            expected-eof-but-got-start-tag
            """
        def processEndTag(self, token):
            """
            expected-eof-but-got-end-tag
            """
def adjust_attributes(token, replacements):
    """
    'data'
    """
2021-03-02 20:51:18,964 : INFO : tokenize_signature : --> do i ever get here?
def impliedTagToken(name, type="EndTag", attributes=None,
                    selfClosing=False):
    """
    type
    """
def ParseError(Exception):
    """
    Error in parsed document
    """
