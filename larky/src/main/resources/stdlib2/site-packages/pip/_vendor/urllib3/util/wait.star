def NoWayToWaitForSocketError(Exception):
    """
     How should we wait on sockets?

     There are two types of APIs you can use for waiting on sockets: the fancy
     modern stateful APIs like epoll/kqueue, and the older stateless APIs like
     select/poll. The stateful APIs are more efficient when you have a lots of
     sockets to keep track of, because you can set them up once and then use them
     lots of times. But we only ever want to wait on a single socket at a time
     and don't want to keep track of state, so the stateless APIs are actually
     more efficient. So we want to use select() or poll().

     Now, how do we choose between select() and poll()? On traditional Unixes,
     select() has a strange calling convention that makes it slow, or fail
     altogether, for high-numbered file descriptors. The point of poll() is to fix
     that, so on Unixes, we prefer poll().

     On Windows, there is no poll() (or at least Python doesn't provide a wrapper
     for it), but that's OK, because on Windows, select() doesn't have this
     strange calling convention; plain select() works fine.

     So: on Windows we use select(), and everywhere else we use poll(). We also
     fall back to select() in case poll() is somehow broken or missing.


    """
    def _retry_on_intr(fn, timeout):
        """
         Old and broken Pythons.

        """
    def _retry_on_intr(fn, timeout):
        """
        inf
        """
def select_wait_for_socket(sock, read=False, write=False, timeout=None):
    """
    must specify at least one of read=True, write=True
    """
def poll_wait_for_socket(sock, read=False, write=False, timeout=None):
    """
    must specify at least one of read=True, write=True
    """
    def do_poll(t):
        """
        no select-equivalent available
        """
def _have_working_poll():
    """
     Apparently some systems have a select.poll that fails as soon as you try
     to use it, either due to strange configuration or broken monkeypatching
     from libraries like eventlet/greenlet.

    """
def wait_for_socket(*args, **kwargs):
    """
     We delay choosing which implementation to use until the first time we're
     called. We could do it at import time, but then we might make the wrong
     decision if someone goes wild with monkeypatching select.poll after
     we're imported.

    """
def wait_for_read(sock, timeout=None):
    """
     Waits for reading to be available on a given socket.
        Returns True if the socket is readable, or False if the timeout expired.
    
    """
def wait_for_write(sock, timeout=None):
    """
     Waits for writing to be available on a given socket.
        Returns True if the socket is readable, or False if the timeout expired.
    
    """
