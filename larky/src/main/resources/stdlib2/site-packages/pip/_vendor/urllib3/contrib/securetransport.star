def inject_into_urllib3():
    """

        Monkey-patch urllib3 with SecureTransport-backed SSL-support.
    
    """
def extract_from_urllib3():
    """

        Undo monkey-patching by :func:`inject_into_urllib3`.
    
    """
def _read_callback(connection_id, data_buffer, data_length_pointer):
    """

        SecureTransport read callback. This is called by ST to request that data
        be returned from the socket.
    
    """
def _write_callback(connection_id, data_buffer, data_length_pointer):
    """

        SecureTransport write callback. This is called by ST to request that data
        actually be sent on the network.
    
    """
def WrappedSocket(object):
    """

        API-compatibility wrapper for Python's OpenSSL wrapped socket object.

        Note: _makefile_refs, _drop(), and _reuse() are needed for the garbage
        collector of PyPy.
    
    """
    def __init__(self, socket):
        """
         We save off the previously-configured timeout and then set it to
         zero. This is done because we use select and friends to handle the
         timeouts, but if we leave the timeout set on the lower socket then
         Python will "kindly" call select on that socket again for us. Avoid
         that by forcing the timeout to zero.

        """
    def _raise_on_error(self):
        """

                A context manager that can be used to wrap calls that do I/O from
                SecureTransport. If any of the I/O callbacks hit an exception, this
                context manager will correctly propagate the exception after the fact.
                This avoids silently swallowing those exceptions.

                It also correctly forces the socket closed.
        
        """
    def _set_ciphers(self):
        """

                Sets up the allowed ciphers. By default this matches the set in
                util.ssl_.DEFAULT_CIPHERS, at least as supported by macOS. This is done
                custom and doesn't allow changing at this time, mostly because parsing
                OpenSSL cipher strings is going to be a freaking nightmare.
        
        """
    def _custom_validate(self, verify, trust_bundle):
        """

                Called when we have set custom validation. We do this in two cases:
                first, when cert validation is entirely disabled; and second, when
                using a custom trust DB.
        
        """
2021-03-02 20:51:24,453 : INFO : tokenize_signature : --> do i ever get here?
2021-03-02 20:51:24,454 : INFO : tokenize_signature : --> do i ever get here?
2021-03-02 20:51:24,454 : INFO : tokenize_signature : --> do i ever get here?
2021-03-02 20:51:24,454 : INFO : tokenize_signature : --> do i ever get here?
2021-03-02 20:51:24,454 : INFO : tokenize_signature : --> do i ever get here?
2021-03-02 20:51:24,454 : INFO : tokenize_signature : --> do i ever get here?
2021-03-02 20:51:24,454 : INFO : tokenize_signature : --> do i ever get here?
2021-03-02 20:51:24,454 : INFO : tokenize_signature : --> do i ever get here?
2021-03-02 20:51:24,454 : INFO : tokenize_signature : --> do i ever get here?
2021-03-02 20:51:24,454 : INFO : tokenize_signature : --> do i ever get here?
    def handshake(
        self,
        server_hostname,
        verify,
        trust_bundle,
        min_version,
        max_version,
        client_cert,
        client_key,
        client_key_passphrase,
    ):
        """

                Actually performs the TLS handshake. This is run automatically by
                wrapped socket, and shouldn't be needed in user code.
        
        """
    def fileno(self):
        """
         Copy-pasted from Python 3.5 source code

        """
    def _decref_socketios(self):
        """
         Read short on EOF.

        """
    def settimeout(self, timeout):
        """
         Timed out

        """
    def sendall(self, data):
        """
         TODO: should I do clean shutdown here? Do I have to?

        """
    def getpeercert(self, binary_form=False):
        """
         Urgh, annoying.

         Here's how we do this:

         1. Call SSLCopyPeerTrust to get hold of the trust object for this
            connection.
         2. Call SecTrustGetCertificateAtIndex for index 0 to get the leaf.
         3. To get the CN, call SecCertificateCopyCommonName and process that
            string so that it's of the appropriate type.
         4. To get the SAN, we need to do something a bit more complex:
            a. Call SecCertificateCopyValues to get the data, requesting
               kSecOIDSubjectAltName.
            b. Mess about with this dictionary to try to get the SANs out.

         This is gross. Really gross. It's going to be a few hundred LoC extra
         just to repeat something that SecureTransport can *already do*. So my
         operating assumption at this time is that what we want to do is
         instead to just flag to urllib3 that it shouldn't do its own hostname
         validation when using SecureTransport.

        """
    def version(self):
        """
        SecureTransport does not support TLS 1.3
        """
    def _reuse(self):
        """
         Platform-specific: Python 2
        """
    def makefile(self, mode, bufsize=-1):
        """
         Platform-specific: Python 3
        """
    def makefile(self, mode="r", buffering=None, *args, **kwargs):
        """
         We disable buffering with SecureTransport because it conflicts with
         the buffering that ST does internally (see issue #1153 for more).

        """
def SecureTransportContext(object):
    """

        I am a wrapper class for the SecureTransport library, to translate the
        interface of the standard library ``SSLContext`` object to calls into
        SecureTransport.
    
    """
    def __init__(self, protocol):
        """

                SecureTransport cannot have its hostname checking disabled. For more,
                see the comment on getpeercert() in this file.
        
        """
    def check_hostname(self, value):
        """

                SecureTransport cannot have its hostname checking disabled. For more,
                see the comment on getpeercert() in this file.
        
        """
    def options(self):
        """
         TODO: Well, crap.

         So this is the bit of the code that is the most likely to cause us
         trouble. Essentially we need to enumerate all of the SSL options that
         users might want to use and try to see if we can sensibly translate
         them, or whether we should just ignore them.

        """
    def options(self, value):
        """
         TODO: Update in line with above.

        """
    def verify_mode(self):
        """
         So, this has to do something a bit weird. Specifically, what it does
         is nothing.

         This means that, if we had previously had load_verify_locations
         called, this does not undo that. We need to do that because it turns
         out that the rest of the urllib3 code will attempt to load the
         default verify paths if it hasn't been told about any paths, even if
         the context itself was sometime earlier. We resolve that by just
         ignoring it.

        """
    def load_default_certs(self):
        """
         For now, we just require the default cipher string.

        """
    def load_verify_locations(self, cafile=None, capath=None, cadata=None):
        """
         OK, we only really support cadata and cafile.

        """
    def load_cert_chain(self, certfile, keyfile=None, password=None):
        """
         So, what do we do here? Firstly, we assert some properties. This is a
         stripped down shim, so there is some functionality we don't support.
         See PEP 543 for the real deal.

        """
