def ResolverException(Exception):
    """
    A base class for all exceptions raised by this module.

        Exceptions derived by this class should all be handled in this module. Any
        bubbling pass the resolver should be treated as a bug.
    
    """
def RequirementsConflicted(ResolverException):
    """
    Requirements conflict: {}
    """
def InconsistentCandidate(ResolverException):
    """
    Provided candidate {!r} does not satisfy {}
    """
def Criterion(object):
    """
    Representation of possible resolution results of a package.

        This holds three attributes:

        * `information` is a collection of `RequirementInformation` pairs.
          Each pair is a requirement contributing to this criterion, and the
          candidate that provides the requirement.
        * `incompatibilities` is a collection of all known not-to-work candidates
          to exclude from consideration.
        * `candidates` is a collection containing all possible candidates deducted
          from the union of contributing requirements and known incompatibilities.
          It should never be empty, except when the criterion is an attribute of a
          raised `RequirementsConflicted` (in which case it is always empty).

        .. note::
            This class is intended to be externally immutable. **Do not** mutate
            any of its attribute containers.
    
    """
    def __init__(self, candidates, information, incompatibilities):
        """
        , 
        """
    def from_requirement(cls, provider, requirement, parent):
        """
        Build an instance from a requirement.
        
        """
    def iter_requirement(self):
        """
        Build a new instance from this and a new requirement.
        
        """
    def excluded_of(self, candidate):
        """
        Build a new instance from this, but excluding specified candidate.

                Returns the new instance, or None if we still have no valid candidates.
        
        """
def ResolutionError(ResolverException):
    """
     causes is a list of RequirementInformation objects

    """
def ResolutionTooDeep(ResolutionError):
    """
     Resolution state in a round.

    """
def Resolution(object):
    """
    Stateful resolution object.

        This is designed as a one-off object that holds information to kick start
        the resolution process, and holds the results afterwards.
    
    """
    def __init__(self, provider, reporter):
        """
        state
        """
    def _push_new_state(self):
        """
        Push a new state into history.

                This new state will be used to hold resolution results of the next
                coming round.
        
        """
    def _merge_into_criterion(self, requirement, parent):
        """
         Check the newly-pinned candidate actually works. This should
         always pass under normal circumstances, but in the case of a
         faulty provider, we will raise an error to notify the implementer
         to fix find_matches() and/or is_satisfied_by().

        """
    def _backtrack(self):
        """
         Drop the current state, it's known not to work.

        """
    def resolve(self, requirements, max_rounds):
        """
        already resolved
        """
def _has_route_to_root(criteria, key, all_keys, connected):
    """
    Result
    """
def _build_result(state):
    """
     Sentinel as root dependencies' parent.
    """
def Resolver(AbstractResolver):
    """
    The thing that performs the actual resolution work.
    
    """
    def resolve(self, requirements, max_rounds=100):
        """
        Take a collection of constraints, spit out the resolution result.

                The return value is a representation to the final resolution result. It
                is a tuple subclass with three public members:

                * `mapping`: A dict of resolved candidates. Each key is an identifier
                    of a requirement (as returned by the provider's `identify` method),
                    and the value is the resolved candidate.
                * `graph`: A `DirectedGraph` instance representing the dependency tree.
                    The vertices are keys of `mapping`, and each edge represents *why*
                    a particular package is included. A special vertex `None` is
                    included to represent parents of user-supplied requirements.
                * `criteria`: A dict of "criteria" that hold detailed information on
                    how edges in the graph are derived. Each key is an identifier of a
                    requirement, and the value is a `Criterion` instance.

                The following exceptions may be raised if a resolution cannot be found:

                * `ResolutionImpossible`: A resolution cannot be found for the given
                    combination of requirements. The `causes` attribute of the
                    exception is a list of (requirement, parent), giving the
                    requirements that could not be satisfied.
                * `ResolutionTooDeep`: The dependency tree is too deeply nested and
                    the resolver gave up. This is usually caused by a circular
                    dependency, but you can try to resolve this by increasing the
                    `max_rounds` argument.
        
        """
