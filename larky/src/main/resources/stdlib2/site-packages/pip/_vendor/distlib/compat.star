    def quote(s):
        """
        'utf-8'
        """
    def splituser(host):
        """
        splituser('user[:passwd]@host[:port]') --> 'user[:passwd]', 'host[:port]'.
        """
    def CertificateError(ValueError):
    """
    Matching according to RFC 6125, section 6.4.3

            http://tools.ietf.org/html/rfc6125#section-6.4.3
        
    """
    def match_hostname(cert, hostname):
        """
        Verify that *cert* (in decoded format as returned by
                SSLSocket.getpeercert()) matches the *hostname*.  RFC 2818 and RFC 6125
                rules are followed, but IP addresses are not accepted for *hostname*.

                CertificateError is raised on failure. On success, the function
                returns nothing.
        
        """
    def Container(object):
    """

            A generic container for when multiple values need to be returned
        
    """
        def __init__(self, **kwargs):
            """
             pragma: no cover
            """
    def which(cmd, mode=os.F_OK | os.X_OK, path=None):
        """
        Given a command, mode, and a PATH string, return the path which
                conforms to the given mode on the PATH, or None if there is no such
                file.

                `mode` defaults to os.F_OK | os.X_OK. `path` defaults to the result
                of os.environ.get("PATH"), or can be overridden with a custom search
                path.

        
        """
        def _access_check(fn, mode):
            """
             If we're given a path with a directory part, look it up directly rather
             than referring to PATH directories. This includes checking relative to the
             current directory, e.g. ./script

            """
    def ZipExtFile(BaseZipExtFile):
    """
     return None, so if an exception occurred, it will propagate


    """
    def ZipFile(BaseZipFile):
    """
     return None, so if an exception occurred, it will propagate


    """
        def open(self, *args, **kwargs):
            """
             pragma: no cover
            """
    def python_implementation():
        """
        Return a string identifying the Python implementation.
        """
    def callable(obj):
        """
         pragma: no cover
        """
    def fsencode(filename):
        """
        expect bytes or str, not %s
        """
    def fsdecode(filename):
        """
        expect bytes or str, not %s
        """
    def _get_normal_name(orig_enc):
        """
        Imitates get_normal_name in tokenizer.c.
        """
    def detect_encoding(readline):
        """

                The detect_encoding() function is used to detect the encoding that should
                be used to decode a Python source file.  It requires one argument, readline,
                in the same way as the tokenize() generator.

                It will call readline a maximum of twice, and return the encoding used
                (as a string) and a list of any lines (left as bytes) it has read in.

                It detects the encoding from the presence of a utf-8 bom or an encoding
                cookie as specified in pep-0263.  If both a bom and a cookie are present,
                but disagree, a SyntaxError will be raised.  If the encoding cookie is an
                invalid charset, raise a SyntaxError.  Note that if a utf-8 bom is found,
                'utf-8-sig' is returned.

                If no encoding is specified, then the default of 'utf-8' will be returned.
        
        """
        def read_or_stop():
            """
            b''
            """
        def find_cookie(line):
            """
             Decode as UTF-8. Either the line is an encoding declaration,
             in which case it should be pure ASCII, or it must be UTF-8
             per default encoding.

            """
        def _recursive_repr(fillvalue='...'):
            """
            '''
                        Decorator to make a repr function return fillvalue for a recursive
                        call
                        '''
            """
            def decorating_function(user_function):
                """
                 Can't use functools.wraps() here because of bootstrap issues

                """
    def ChainMap(MutableMapping):
    """
    ''' A ChainMap groups multiple dicts (or other mappings) together
            to create a single, updateable view.

            The underlying mappings are stored in a list.  That list is public and can
            accessed or updated using the *maps* attribute.  There is no other state.

            Lookups search the underlying mappings successively until a key is found.
            In contrast, writes, updates, and deletions only operate on the first
            mapping.

            '''
    """
        def __init__(self, *maps):
            """
            '''Initialize a ChainMap by setting *maps* to the given mappings.
                        If no mappings are provided, a single empty dictionary is used.

                        '''
            """
        def __missing__(self, key):
            """
             can't use 'key in mapping' with defaultdict
            """
        def get(self, key, default=None):
            """
             reuses stored hash values if possible
            """
        def __iter__(self):
            """
            '{0.__class__.__name__}({1})'
            """
        def fromkeys(cls, iterable, *args):
            """
            'Create a ChainMap with a single dict created from the iterable.'
            """
        def copy(self):
            """
            'New ChainMap or subclass with a new copy of maps[0] and refs to maps[1:]'
            """
        def new_child(self):                        # like Django's Context.push()
            """
             like Django's Context.push()
            """
        def parents(self):                          # like Django's Context.pop()
            """
             like Django's Context.pop()
            """
        def __setitem__(self, key, value):
            """
            'Key not found in the first mapping: {!r}'
            """
        def popitem(self):
            """
            'Remove and return an item pair from maps[0]. Raise KeyError is maps[0] is empty.'
            """
        def pop(self, key, *args):
            """
            'Remove *key* from maps[0] and return its value. Raise KeyError if *key* not in maps[0].'
            """
        def clear(self):
            """
            'Clear maps[0], leaving maps[1:] intact.'
            """
        def cache_from_source(path, debug_override=None):
            """
            '.py'
            """
    def OrderedDict(dict):
    """
    'Dictionary that remembers insertion order'
    """
        def __init__(self, *args, **kwds):
            """
            '''Initialize an ordered dictionary.  Signature is the same as for
                        regular dictionaries, but keyword arguments are not recommended
                        because their insertion order is arbitrary.

                        '''
            """
        def __setitem__(self, key, value, dict_setitem=dict.__setitem__):
            """
            'od.__setitem__(i, y) <==> od[i]=y'
            """
        def __delitem__(self, key, dict_delitem=dict.__delitem__):
            """
            'od.__delitem__(y) <==> del od[y]'
            """
        def __iter__(self):
            """
            'od.__iter__() <==> iter(od)'
            """
        def __reversed__(self):
            """
            'od.__reversed__() <==> reversed(od)'
            """
        def clear(self):
            """
            'od.clear() -> None.  Remove all items from od.'
            """
        def popitem(self, last=True):
            """
            '''od.popitem() -> (k, v), return and remove a (key, value) pair.
                        Pairs are returned in LIFO order if last is true or FIFO order if false.

                        '''
            """
        def keys(self):
            """
            'od.keys() -> list of keys in od'
            """
        def values(self):
            """
            'od.values() -> list of values in od'
            """
        def items(self):
            """
            'od.items() -> list of (key, value) pairs in od'
            """
        def iterkeys(self):
            """
            'od.iterkeys() -> an iterator over the keys in od'
            """
        def itervalues(self):
            """
            'od.itervalues -> an iterator over the values in od'
            """
        def iteritems(self):
            """
            'od.iteritems -> an iterator over the (key, value) items in od'
            """
        def update(*args, **kwds):
            """
            '''od.update(E, **F) -> None.  Update od from dict/iterable E and F.

                        If E is a dict instance, does:           for k in E: od[k] = E[k]
                        If E has a .keys() method, does:         for k in E.keys(): od[k] = E[k]
                        Or if E is an iterable of items, does:   for k, v in E: od[k] = v
                        In either case, this is followed by:     for k, v in F.items(): od[k] = v

                        '''
            """
        def pop(self, key, default=__marker):
            """
            '''od.pop(k[,d]) -> v, remove specified key and return the corresponding value.
                        If key is not found, d is returned if given, otherwise KeyError is raised.

                        '''
            """
        def setdefault(self, key, default=None):
            """
            'od.setdefault(k[,d]) -> od.get(k,d), also set od[k]=d if k not in od'
            """
        def __repr__(self, _repr_running=None):
            """
            'od.__repr__() <==> repr(od)'
            """
        def __reduce__(self):
            """
            'Return state information for pickling'
            """
        def copy(self):
            """
            'od.copy() -> a shallow copy of od'
            """
        def fromkeys(cls, iterable, value=None):
            """
            '''OD.fromkeys(S[, v]) -> New ordered dictionary with keys from S
                        and values equal to v (which defaults to None).

                        '''
            """
        def __eq__(self, other):
            """
            '''od.__eq__(y) <==> od==y.  Comparison to another OD is order-sensitive
                        while comparison to a regular mapping is order-insensitive.

                        '''
            """
        def __ne__(self, other):
            """
             -- the following methods are only used in Python 2.7 --


            """
        def viewkeys(self):
            """
            od.viewkeys() -> a set-like object providing a view on od's keys
            """
        def viewvalues(self):
            """
            od.viewvalues() -> an object providing a view on od's values
            """
        def viewitems(self):
            """
            od.viewitems() -> a set-like object providing a view on od's items
            """
    def valid_ident(s):
        """
        'Not a valid Python identifier: %r'
        """
    def ConvertingDict(dict):
    """
    A converting dictionary wrapper.
    """
        def __getitem__(self, key):
            """
            If the converted value is different, save for next time

            """
        def get(self, key, default=None):
            """
            If the converted value is different, save for next time

            """
    def pop(self, key, default=None):
        """
        A converting list wrapper.
        """
        def __getitem__(self, key):
            """
            If the converted value is different, save for next time

            """
        def pop(self, idx=-1):
            """
            A converting tuple wrapper.
            """
        def __getitem__(self, key):
            """

                    The configurator base class which defines some useful defaults.
        
            """
        def __init__(self, config):
            """

                        Resolve strings to objects using standard import and attribute
                        syntax.
            
            """
        def ext_convert(self, value):
            """
            Default converter for the ext:// protocol.
            """
        def cfg_convert(self, value):
            """
            Default converter for the cfg:// protocol.
            """
        def convert(self, value):
            """

                        Convert values to an appropriate type. dicts, lists and tuples are
                        replaced by their converting alternatives. Strings are checked to
                        see if they have a conversion format and are converted if they do.
            
            """
        def configure_custom(self, config):
            """
            Configure an object with a user-supplied factory.
            """
        def as_tuple(self, value):
            """
            Utility function which converts lists to tuples.
            """
