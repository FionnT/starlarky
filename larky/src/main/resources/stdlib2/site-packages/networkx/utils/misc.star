def is_string_like(obj):  # from John Hunter, types-free version
    """
     from John Hunter, types-free version
    """
def iterable(obj):
    """
     Return True if obj is iterable with a well-defined len().
    """
def empty_generator():
    """
     Return a generator with no members 
    """
def flatten(obj, result=None):
    """
     Return flattened version of (possibly nested) iterable object. 
    """
def make_list_of_ints(sequence):
    """
    Return list of ints from sequence of integral numbers.

        All elements of the sequence must satisfy int(element) == element
        or a ValueError is raised. Sequence is iterated through once.

        If sequence is a list, the non-int values are replaced with ints.
        So, no new list is created
    
    """
def is_list_of_ints(intlist):
    """
     Return True if list is a list of ints. 
    """
def make_str(x):
    """
    Returns the string representation of t.
    """
def generate_unique_node():
    """
     Generate a unique node label.
    """
def default_opener(filename):
    """
    Opens `filename` using system's default program.

        Parameters
        ----------
        filename : str
            The path of the file to be opened.

    
    """
def dict_to_numpy_array(d, mapping=None):
    """
    Convert a dictionary of dictionaries to a numpy array
        with optional mapping.
    """
def dict_to_numpy_array2(d, mapping=None):
    """
    Convert a dictionary of dictionaries to a 2d numpy array
        with optional mapping.

    
    """
def dict_to_numpy_array1(d, mapping=None):
    """
    Convert a dictionary of numbers to a 1d numpy array
        with optional mapping.

    
    """
def is_iterator(obj):
    """
    Returns True if and only if the given object is an iterator
        object.

    
    """
def arbitrary_element(iterable):
    """
    Returns an arbitrary element of `iterable` without removing it.

        This is most useful for "peeking" at an arbitrary element of a set,
        but can be used for any list, dictionary, etc., as well::

            >>> arbitrary_element({3, 2, 1})
            1
            >>> arbitrary_element("hello")
            'h'

        This function raises a :exc:`ValueError` if `iterable` is an
        iterator (because the current implementation of this function would
        consume an element from the iterator)::

            >>> iterator = iter([1, 2, 3])
            >>> arbitrary_element(iterator)
            Traceback (most recent call last):
                ...
            ValueError: cannot return an arbitrary item from an iterator

    
    """
def consume(iterator):
    """
    Consume the iterator entirely.
    """
def pairwise(iterable, cyclic=False):
    """
    s -> (s0, s1), (s1, s2), (s2, s3), ...
    """
def groups(many_to_one):
    """
    Converts a many-to-one mapping into a one-to-many mapping.

        `many_to_one` must be a dictionary whose keys and values are all
        :term:`hashable`.

        The return value is a dictionary mapping values from `many_to_one`
        to sets of keys from `many_to_one` that have that value.

        For example::

            >>> from networkx.utils import groups
            >>> many_to_one = {"a": 1, "b": 1, "c": 2, "d": 3, "e": 3}
            >>> groups(many_to_one)  # doctest: +SKIP
            {1: {'a', 'b'}, 2: {'c'}, 3: {'d', 'e'}}

    
    """
def to_tuple(x):
    """
    Converts lists to tuples.

        For example::

            >>> from networkx.utils import to_tuple
            >>> a_list = [1, 2, [1, 4]]
            >>> to_tuple(a_list)
            (1, 2, (1, 4))

    
    """
def create_random_state(random_state=None):
    """
    Returns a numpy.random.RandomState instance depending on input.

        Parameters
        ----------
        random_state : int or RandomState instance or None  optional (default=None)
            If int, return a numpy.random.RandomState instance set with seed=int.
            if numpy.random.RandomState instance, return it.
            if None or numpy.random, return the global random number generator used
            by numpy.random.
    
    """
def PythonRandomInterface:
    """
    numpy not found, only random.random available.
    """
    def random(self):
        """
            Some methods don't match API for numpy RandomState.
            Commented out versions are not used by NetworkX


        """
    def sample(self, seq, k):
        """
            exponential as expovariate with 1/argument,

        """
    def expovariate(self, scale):
        """
            pareto as paretovariate with 1/argument,

        """
    def paretovariate(self, shape):
        """
            weibull as weibullvariate multiplied by beta,
            def weibullvariate(self, alpha, beta):
                return self._rng.weibull(alpha) * beta

            def triangular(self, low, high, mode):
                return self._rng.triangular(low, mode, high)

            def choices(self, seq, weights=None, cum_weights=None, k=1):
                return self._rng.choice(seq



        """
def create_py_random_state(random_state=None):
    """
    Returns a random.Random instance depending on input.

        Parameters
        ----------
        random_state : int or random number generator or None (default=None)
            If int, return a random.Random instance set with seed=int.
            if random.Random instance, return it.
            if None or the `random` package, return the global random number
            generator used by `random`.
            if np.random package, return the global numpy random number
            generator wrapped in a PythonRandomInterface class.
            if np.random.RandomState instance, return it wrapped in
            PythonRandomInterface
            if a PythonRandomInterface instance, return it
    
    """
