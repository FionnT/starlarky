def not_implemented_for(*graph_types):
    """
    Decorator to mark algorithms as not implemented

        Parameters
        ----------
        graph_types : container of strings
            Entries must be one of 'directed','undirected', 'multigraph', 'graph'.

        Returns
        -------
        _require : function
            The decorated function.

        Raises
        ------
        NetworkXNotImplemented
        If any of the packages cannot be imported

        Notes
        -----
        Multiple types are joined logically with "and".
        For "or" use multiple @not_implemented_for() lines.

        Examples
        --------
        Decorate functions like this::

           @not_implemnted_for('directed')
           def sp_function(G):
               pass

           @not_implemnted_for('directed','multigraph')
           def sp_np_function(G):
               pass
    
    """
    def _not_implemented_for(not_implement_for_func, *args, **kwargs):
        """
        directed
        """
def _open_gz(path, mode):
    """
     To handle new extensions, define a function accepting a `path` and `mode`.
     Then add the extension to _dispatch_dict.

    """
def open_file(path_arg, mode="r"):
    """
    Decorator to ensure clean opening and closing of files.

        Parameters
        ----------
        path_arg : int
            Location of the path argument in args.  Even if the argument is a
            named positional argument (with a default value), you must specify its
            index as a positional argument.
        mode : str
            String for opening mode.

        Returns
        -------
        _open_file : function
            Function which cleanly executes the io.

        Examples
        --------
        Decorate functions like this::

           @open_file(0,'r')
           def read_function(pathname):
               pass

           @open_file(1,'w')
           def write_function(G,pathname):
               pass

           @open_file(1,'w')
           def write_function(G, pathname='graph.dot')
               pass

           @open_file('path', 'w+')
           def another_function(arg, **kwargs):
               path = kwargs['path']
               pass
    
    """
    def _open_file(func_to_be_decorated, *args, **kwargs):
        """
         Note that since we have used @decorator, *args, and **kwargs have
         already been resolved to match the function signature of func. This
         means default values have been propagated. For example,  the function
         func(x, y, a=1, b=2, **kwargs) if called as func(0,1,b=5,c=10) would
         have args=(0,1,1,5) and kwargs={'c':10}.

         First we parse the arguments of the decorator. The path_arg could
         be an positional argument or a keyword argument.  Even if it is

        """
def nodes_or_number(which_args):
    """
    Decorator to allow number of nodes or container of nodes.

        Parameters
        ----------
        which_args : int or sequence of ints
            Location of the node arguments in args. Even if the argument is a
            named positional argument (with a default value), you must specify its
            index as a positional argument.
            If more than one node argument is allowed, can be a list of locations.

        Returns
        -------
        _nodes_or_numbers : function
            Function which replaces int args with ranges.

        Examples
        --------
        Decorate functions like this::

           @nodes_or_number(0)
           def empty_graph(nodes):
               pass

           @nodes_or_number([0,1])
           def grid_2d_graph(m1, m2, periodic=False):
               pass

           @nodes_or_number(1)
           def full_rary_tree(r, n)
               # r is a number. n can be a number of a list of nodes
               pass
    
    """
    def _nodes_or_number(func_to_be_decorated, *args, **kw):
        """
         form tuple of arg positions to be converted.

        """
def preserve_random_state(func):
    """
     Decorator to preserve the numpy.random state during a function.

        Parameters
        ----------
        func : function
            function around which to preserve the random state.

        Returns
        -------
        wrapper : function
            Function which wraps the input function by saving the state before
            calling the function and restoring the function afterward.

        Examples
        --------
        Decorate functions like this::

            @preserve_random_state
            def do_random_stuff(x, y):
                return x + y * numpy.random.random()

        Notes
        -----
        If numpy.random is not importable, the state is not saved or restored.
    
    """
        def save_random_state():
            """
            Decorator to generate a numpy.random.RandomState instance.

                Argument position `random_state_index` is processed by create_random_state.
                The result is a numpy.random.RandomState instance.

                Parameters
                ----------
                random_state_index : int
                    Location of the random_state argument in args that is to be used to
                    generate the numpy.random.RandomState instance. Even if the argument is
                    a named positional argument (with a default value), you must specify
                    its index as a positional argument.

                Returns
                -------
                _random_state : function
                    Function whose random_state keyword argument is a RandomState instance.

                Examples
                --------
                Decorate functions like this::

                   @np_random_state(0)
                   def random_float(random_state=None):
                       return random_state.rand()

                   @np_random_state(1)
                   def random_array(dims, random_state=1):
                       return random_state.rand(*dims)

                See Also
                --------
                py_random_state
    
            """
    def _random_state(func, *args, **kwargs):
        """
         Parse the decorator arguments.

        """
def py_random_state(random_state_index):
    """
    Decorator to generate a random.Random instance (or equiv).

        Argument position `random_state_index` processed by create_py_random_state.
        The result is either a random.Random instance, or numpy.random.RandomState
        instance with additional attributes to mimic basic methods of Random.

        Parameters
        ----------
        random_state_index : int
            Location of the random_state argument in args that is to be used to
            generate the numpy.random.RandomState instance. Even if the argument is
            a named positional argument (with a default value), you must specify
            its index as a positional argument.

        Returns
        -------
        _random_state : function
            Function whose random_state keyword argument is a RandomState instance.

        Examples
        --------
        Decorate functions like this::

           @py_random_state(0)
           def random_float(random_state=None):
               return random_state.rand()

           @py_random_state(1)
           def random_array(dims, random_state=1):
               return random_state.rand(*dims)

        See Also
        --------
        np_random_state
    
    """
    def _random_state(func, *args, **kwargs):
        """
         Parse the decorator arguments.

        """
