        def daxpy(x, y, a):
            """
            Preconditioned conjugate gradient method.

                To solve Ax = b:
                    M = A.diagonal() # or some other preconditioner
                    solver = _PCGSolver(lambda x: A * x, lambda x: M * x)
                    x = solver.solve(b)

                The inputs A and M are functions which compute
                matrix multiplication on the argument.
                A - multiply by the matrix A in Ax=b
                M - multiply by M, the preconditioner surragate for A

                Warning: There is no limit on number of iterations.
    
            """
    def __init__(self, A, M):
        """
        F
        """
    def _solve(self, b, tol):
        """
         Initialize.

        """
def _CholeskySolver:
    """
    Cholesky factorization.

        To solve Ax = b:
            solver = _CholeskySolver(A)
            x = solver.solve(b)

        optional argument `tol` on solve method is ignored but included
        to match _PCGsolver API.
    
    """
    def __init__(self, A):
        """
        Cholesky solver unavailable.
        """
    def solve(self, B, tol=None):
        """
        LU factorization.

            To solve Ax = b:
                solver = _LUSolver(A)
                x = solver.solve(b)

            optional argument `tol` on solve method is ignored but included
            to match _PCGsolver API.
    
        """
    def __init__(self, A):
        """
        LU solver unavailable.
        """
    def solve(self, B, tol=None):
        """
        F
        """
def _preprocess_graph(G, weight):
    """
    Compute edge weights and eliminate zero-weight edges.
    
    """
def _rcm_estimate(G, nodelist):
    """
    Estimate the Fiedler vector using the reverse Cuthill-McKee ordering.
    
    """
def _tracemin_fiedler(L, X, normalized, tol, method):
    """
    Compute the Fiedler vector of L using the TraceMIN-Fiedler algorithm.

        The Fiedler vector of a connected undirected graph is the eigenvector
        corresponding to the second smallest eigenvalue of the Laplacian matrix of
        of the graph. This function starts with the Laplacian L, not the Graph.

        Parameters
        ----------
        L : Laplacian of a possibly weighted or normalized, but undirected graph

        X : Initial guess for a solution. Usually a matrix of random numbers.
            This function allows more than one column in X to identify more than
            one eigenvector if desired.

        normalized : bool
            Whether the normalized Laplacian matrix is used.

        tol : float
            Tolerance of relative residual in eigenvalue computation.
            Warning: There is no limit on number of iterations.

        method : string
            Should be 'tracemin_pcg', 'tracemin_chol' or 'tracemin_lu'.
            Otherwise exception is raised.

        Returns
        -------
        sigma, X : Two NumPy arrays of floats.
            The lowest eigenvalues and corresponding eigenvectors of L.
            The size of input X determines the size of these outputs.
            As this is for Fiedler vectors, the zero eigenvalue (and
            constant eigenvector) are avoided.
    
    """
        def project(X):
            """
            Make X orthogonal to the nullspace of L.
            
            """
        def project(X):
            """
            Make X orthogonal to the nullspace of L.
            
            """
def _get_fiedler_func(method):
    """
    Returns a function that solves the Fiedler eigenvalue problem.
    
    """
        def find_fiedler(L, x, normalized, tol, seed):
            """
            tracemin_pcg
            """
        def find_fiedler(L, x, normalized, tol, seed):
            """
            csc
            """
2021-03-02 20:47:08,985 : INFO : tokenize_signature : --> do i ever get here?
2021-03-02 20:47:08,985 : INFO : tokenize_signature : --> do i ever get here?
def algebraic_connectivity(
    G, weight="weight", normalized=False, tol=1e-8, method="tracemin_pcg", seed=None
):
    """
    Returns the algebraic connectivity of an undirected graph.

        The algebraic connectivity of a connected undirected graph is the second
        smallest eigenvalue of its Laplacian matrix.

        Parameters
        ----------
        G : NetworkX graph
            An undirected graph.

        weight : object, optional (default: None)
            The data key used to determine the weight of each edge. If None, then
            each edge has unit weight.

        normalized : bool, optional (default: False)
            Whether the normalized Laplacian matrix is used.

        tol : float, optional (default: 1e-8)
            Tolerance of relative residual in eigenvalue computation.

        method : string, optional (default: 'tracemin_pcg')
            Method of eigenvalue computation. It must be one of the tracemin
            options shown below (TraceMIN), 'lanczos' (Lanczos iteration)
            or 'lobpcg' (LOBPCG).

            The TraceMIN algorithm uses a linear system solver. The following
            values allow specifying the solver to be used.

            =============== ========================================
            Value           Solver
            =============== ========================================
            'tracemin_pcg'  Preconditioned conjugate gradient method
            'tracemin_chol' Cholesky factorization
            'tracemin_lu'   LU factorization
            =============== ========================================

        seed : integer, random_state, or None (default)
            Indicator of random number generation state.
            See :ref:`Randomness<randomness>`.

        Returns
        -------
        algebraic_connectivity : float
            Algebraic connectivity.

        Raises
        ------
        NetworkXNotImplemented
            If G is directed.

        NetworkXError
            If G has less than two nodes.

        Notes
        -----
        Edge weights are interpreted by their absolute values. For MultiGraph's,
        weights of parallel edges are summed. Zero-weighted edges are ignored.

        To use Cholesky factorization in the TraceMIN algorithm, the
        :samp:`scikits.sparse` package must be installed.

        See Also
        --------
        laplacian_matrix
    
    """
2021-03-02 20:47:08,986 : INFO : tokenize_signature : --> do i ever get here?
2021-03-02 20:47:08,986 : INFO : tokenize_signature : --> do i ever get here?
def fiedler_vector(
    G, weight="weight", normalized=False, tol=1e-8, method="tracemin_pcg", seed=None
):
    """
    Returns the Fiedler vector of a connected undirected graph.

        The Fiedler vector of a connected undirected graph is the eigenvector
        corresponding to the second smallest eigenvalue of the Laplacian matrix of
        of the graph.

        Parameters
        ----------
        G : NetworkX graph
            An undirected graph.

        weight : object, optional (default: None)
            The data key used to determine the weight of each edge. If None, then
            each edge has unit weight.

        normalized : bool, optional (default: False)
            Whether the normalized Laplacian matrix is used.

        tol : float, optional (default: 1e-8)
            Tolerance of relative residual in eigenvalue computation.

        method : string, optional (default: 'tracemin_pcg')
            Method of eigenvalue computation. It must be one of the tracemin
            options shown below (TraceMIN), 'lanczos' (Lanczos iteration)
            or 'lobpcg' (LOBPCG).

            The TraceMIN algorithm uses a linear system solver. The following
            values allow specifying the solver to be used.

            =============== ========================================
            Value           Solver
            =============== ========================================
            'tracemin_pcg'  Preconditioned conjugate gradient method
            'tracemin_chol' Cholesky factorization
            'tracemin_lu'   LU factorization
            =============== ========================================

        seed : integer, random_state, or None (default)
            Indicator of random number generation state.
            See :ref:`Randomness<randomness>`.

        Returns
        -------
        fiedler_vector : NumPy array of floats.
            Fiedler vector.

        Raises
        ------
        NetworkXNotImplemented
            If G is directed.

        NetworkXError
            If G has less than two nodes or is not connected.

        Notes
        -----
        Edge weights are interpreted by their absolute values. For MultiGraph's,
        weights of parallel edges are summed. Zero-weighted edges are ignored.

        To use Cholesky factorization in the TraceMIN algorithm, the
        :samp:`scikits.sparse` package must be installed.

        See Also
        --------
        laplacian_matrix
    
    """
2021-03-02 20:47:08,987 : INFO : tokenize_signature : --> do i ever get here?
2021-03-02 20:47:08,987 : INFO : tokenize_signature : --> do i ever get here?
def spectral_ordering(
    G, weight="weight", normalized=False, tol=1e-8, method="tracemin_pcg", seed=None
):
    """
    Compute the spectral_ordering of a graph.

        The spectral ordering of a graph is an ordering of its nodes where nodes
        in the same weakly connected components appear contiguous and ordered by
        their corresponding elements in the Fiedler vector of the component.

        Parameters
        ----------
        G : NetworkX graph
            A graph.

        weight : object, optional (default: None)
            The data key used to determine the weight of each edge. If None, then
            each edge has unit weight.

        normalized : bool, optional (default: False)
            Whether the normalized Laplacian matrix is used.

        tol : float, optional (default: 1e-8)
            Tolerance of relative residual in eigenvalue computation.

        method : string, optional (default: 'tracemin_pcg')
            Method of eigenvalue computation. It must be one of the tracemin
            options shown below (TraceMIN), 'lanczos' (Lanczos iteration)
            or 'lobpcg' (LOBPCG).

            The TraceMIN algorithm uses a linear system solver. The following
            values allow specifying the solver to be used.

            =============== ========================================
            Value           Solver
            =============== ========================================
            'tracemin_pcg'  Preconditioned conjugate gradient method
            'tracemin_chol' Cholesky factorization
            'tracemin_lu'   LU factorization
            =============== ========================================

        seed : integer, random_state, or None (default)
            Indicator of random number generation state.
            See :ref:`Randomness<randomness>`.

        Returns
        -------
        spectral_ordering : NumPy array of floats.
            Spectral ordering of nodes.

        Raises
        ------
        NetworkXError
            If G is empty.

        Notes
        -----
        Edge weights are interpreted by their absolute values. For MultiGraph's,
        weights of parallel edges are summed. Zero-weighted edges are ignored.

        To use Cholesky factorization in the TraceMIN algorithm, the
        :samp:`scikits.sparse` package must be installed.

        See Also
        --------
        laplacian_matrix
    
    """
