def _process_params(G, center, dim):
    """
     Some boilerplate code.

    """
def random_layout(G, center=None, dim=2, seed=None):
    """
    Position nodes uniformly at random in the unit square.

        For every node, a position is generated by choosing each of dim
        coordinates uniformly at random on the interval [0.0, 1.0).

        NumPy (http://scipy.org) is required for this function.

        Parameters
        ----------
        G : NetworkX graph or list of nodes
            A position will be assigned to every node in G.

        center : array-like or None
            Coordinate pair around which to center the layout.

        dim : int
            Dimension of layout.

        seed : int, RandomState instance or None  optional (default=None)
            Set the random state for deterministic node layouts.
            If int, `seed` is the seed used by the random number generator,
            if numpy.random.RandomState instance, `seed` is the random
            number generator,
            if None, the random number generator is the RandomState instance used
            by numpy.random.

        Returns
        -------
        pos : dict
            A dictionary of positions keyed by node

        Examples
        --------
        >>> G = nx.lollipop_graph(4, 3)
        >>> pos = nx.random_layout(G)

    
    """
def circular_layout(G, scale=1, center=None, dim=2):
    """
     dim=2 only

    """
def shell_layout(G, nlist=None, rotate=None, scale=1, center=None, dim=2):
    """
    Position nodes in concentric circles.

        Parameters
        ----------
        G : NetworkX graph or list of nodes
            A position will be assigned to every node in G.

        nlist : list of lists
           List of node lists for each shell.

        rotate : angle in radians (default=pi/len(nlist))
           Angle by which to rotate the starting position of each shell
           relative to the starting position of the previous shell.
           To recreate behavior before v2.5 use rotate=0.

        scale : number (default: 1)
            Scale factor for positions.

        center : array-like or None
            Coordinate pair around which to center the layout.

        dim : int
            Dimension of layout, currently only dim=2 is supported.
            Other dimension values result in a ValueError.

        Returns
        -------
        pos : dict
            A dictionary of positions keyed by node

        Raises
        -------
        ValueError
            If dim != 2

        Examples
        --------
        >>> G = nx.path_graph(4)
        >>> shells = [[0], [1, 2, 3]]
        >>> pos = nx.shell_layout(G, shells)

        Notes
        -----
        This algorithm currently only works in two dimensions and does not
        try to minimize edge crossings.

    
    """
2021-03-02 20:47:07,458 : INFO : tokenize_signature : --> do i ever get here?
2021-03-02 20:47:07,458 : INFO : tokenize_signature : --> do i ever get here?
def bipartite_layout(
    G, nodes, align="vertical", scale=1, center=None, aspect_ratio=4 / 3
):
    """
    Position nodes in two straight lines.

        Parameters
        ----------
        G : NetworkX graph or list of nodes
            A position will be assigned to every node in G.

        nodes : list or container
            Nodes in one node set of the bipartite graph.
            This set will be placed on left or top.

        align : string (default='vertical')
            The alignment of nodes. Vertical or horizontal.

        scale : number (default: 1)
            Scale factor for positions.

        center : array-like or None
            Coordinate pair around which to center the layout.

        aspect_ratio : number (default=4/3):
            The ratio of the width to the height of the layout.

        Returns
        -------
        pos : dict
            A dictionary of positions keyed by node.

        Examples
        --------
        >>> G = nx.bipartite.gnmk_random_graph(3, 5, 10, seed=123)
        >>> top = nx.bipartite.sets(G)[0]
        >>> pos = nx.bipartite_layout(G, top)

        Notes
        -----
        This algorithm currently only works in two dimensions and does not
        try to minimize edge crossings.

    
    """
2021-03-02 20:47:07,460 : INFO : tokenize_signature : --> do i ever get here?
2021-03-02 20:47:07,461 : INFO : tokenize_signature : --> do i ever get here?
2021-03-02 20:47:07,461 : INFO : tokenize_signature : --> do i ever get here?
2021-03-02 20:47:07,461 : INFO : tokenize_signature : --> do i ever get here?
2021-03-02 20:47:07,461 : INFO : tokenize_signature : --> do i ever get here?
2021-03-02 20:47:07,461 : INFO : tokenize_signature : --> do i ever get here?
2021-03-02 20:47:07,461 : INFO : tokenize_signature : --> do i ever get here?
2021-03-02 20:47:07,461 : INFO : tokenize_signature : --> do i ever get here?
2021-03-02 20:47:07,461 : INFO : tokenize_signature : --> do i ever get here?
2021-03-02 20:47:07,461 : INFO : tokenize_signature : --> do i ever get here?
2021-03-02 20:47:07,461 : INFO : tokenize_signature : --> do i ever get here?
2021-03-02 20:47:07,461 : INFO : tokenize_signature : --> do i ever get here?
def fruchterman_reingold_layout(
    G,
    k=None,
    pos=None,
    fixed=None,
    iterations=50,
    threshold=1e-4,
    weight="weight",
    scale=1,
    center=None,
    dim=2,
    seed=None,
):
    """
    Position nodes using Fruchterman-Reingold force-directed algorithm.

        The algorithm simulates a force-directed representation of the network
        treating edges as springs holding nodes close, while treating nodes
        as repelling objects, sometimes called an anti-gravity force.
        Simulation continues until the positions are close to an equilibrium.

        There are some hard-coded values: minimal distance between
        nodes (0.01) and "temperature" of 0.1 to ensure nodes don't fly away.
        During the simulation, `k` helps determine the distance between nodes,
        though `scale` and `center` determine the size and place after
        rescaling occurs at the end of the simulation.

        Fixing some nodes doesn't allow them to move in the simulation.
        It also turns off the rescaling feature at the simulation's end.
        In addition, setting `scale` to `None` turns off rescaling.

        Parameters
        ----------
        G : NetworkX graph or list of nodes
            A position will be assigned to every node in G.

        k : float (default=None)
            Optimal distance between nodes.  If None the distance is set to
            1/sqrt(n) where n is the number of nodes.  Increase this value
            to move nodes farther apart.

        pos : dict or None  optional (default=None)
            Initial positions for nodes as a dictionary with node as keys
            and values as a coordinate list or tuple.  If None, then use
            random initial positions.

        fixed : list or None  optional (default=None)
            Nodes to keep fixed at initial position.
            ValueError raised if `fixed` specified and `pos` not.

        iterations : int  optional (default=50)
            Maximum number of iterations taken

        threshold: float optional (default = 1e-4)
            Threshold for relative error in node position changes.
            The iteration stops if the error is below this threshold.

        weight : string or None   optional (default='weight')
            The edge attribute that holds the numerical value used for
            the edge weight.  If None, then all edge weights are 1.

        scale : number or None (default: 1)
            Scale factor for positions. Not used unless `fixed is None`.
            If scale is None, no rescaling is performed.

        center : array-like or None
            Coordinate pair around which to center the layout.
            Not used unless `fixed is None`.

        dim : int
            Dimension of layout.

        seed : int, RandomState instance or None  optional (default=None)
            Set the random state for deterministic node layouts.
            If int, `seed` is the seed used by the random number generator,
            if numpy.random.RandomState instance, `seed` is the random
            number generator,
            if None, the random number generator is the RandomState instance used
            by numpy.random.

        Returns
        -------
        pos : dict
            A dictionary of positions keyed by node

        Examples
        --------
        >>> G = nx.path_graph(4)
        >>> pos = nx.spring_layout(G)

        # The same using longer but equivalent function name
        >>> pos = nx.fruchterman_reingold_layout(G)
    
    """
2021-03-02 20:47:07,464 : INFO : tokenize_signature : --> do i ever get here?
2021-03-02 20:47:07,464 : INFO : tokenize_signature : --> do i ever get here?
def _fruchterman_reingold(
    A, k=None, pos=None, fixed=None, iterations=50, threshold=1e-4, dim=2, seed=None
):
    """
     Position nodes in adjacency matrix A using Fruchterman-Reingold
     Entry point for NetworkX graph is fruchterman_reingold_layout()

    """
2021-03-02 20:47:07,466 : INFO : tokenize_signature : --> do i ever get here?
2021-03-02 20:47:07,467 : INFO : tokenize_signature : --> do i ever get here?
def _sparse_fruchterman_reingold(
    A, k=None, pos=None, fixed=None, iterations=50, threshold=1e-4, dim=2, seed=None
):
    """
     Position nodes in adjacency matrix A using Fruchterman-Reingold
     Entry point for NetworkX graph is fruchterman_reingold_layout()
     Sparse version

    """
2021-03-02 20:47:07,469 : INFO : tokenize_signature : --> do i ever get here?
2021-03-02 20:47:07,469 : INFO : tokenize_signature : --> do i ever get here?
def kamada_kawai_layout(
    G, dist=None, pos=None, weight="weight", scale=1, center=None, dim=2
):
    """
    Position nodes using Kamada-Kawai path-length cost-function.

        Parameters
        ----------
        G : NetworkX graph or list of nodes
            A position will be assigned to every node in G.

        dist : dict (default=None)
            A two-level dictionary of optimal distances between nodes,
            indexed by source and destination node.
            If None, the distance is computed using shortest_path_length().

        pos : dict or None  optional (default=None)
            Initial positions for nodes as a dictionary with node as keys
            and values as a coordinate list or tuple.  If None, then use
            circular_layout() for dim >= 2 and a linear layout for dim == 1.

        weight : string or None   optional (default='weight')
            The edge attribute that holds the numerical value used for
            the edge weight.  If None, then all edge weights are 1.

        scale : number (default: 1)
            Scale factor for positions.

        center : array-like or None
            Coordinate pair around which to center the layout.

        dim : int
            Dimension of layout.

        Returns
        -------
        pos : dict
            A dictionary of positions keyed by node

        Examples
        --------
        >>> G = nx.path_graph(4)
        >>> pos = nx.kamada_kawai_layout(G)
    
    """
def _kamada_kawai_solve(dist_mtx, pos_arr, dim):
    """
     Anneal node locations based on the Kamada-Kawai cost-function,
     using the supplied matrix of preferred inter-node distances,
     and starting locations.


    """
def _kamada_kawai_costfn(pos_vec, np, invdist, meanweight, dim):
    """
     Cost-function and gradient for Kamada-Kawai layout algorithm

    """
def spectral_layout(G, weight="weight", scale=1, center=None, dim=2):
    """
    Position nodes using the eigenvectors of the graph Laplacian.

        Using the unnormalized Laplacian, the layout shows possible clusters of
        nodes which are an approximation of the ratio cut. If dim is the number of
        dimensions then the positions are the entries of the dim eigenvectors
        corresponding to the ascending eigenvalues starting from the second one.

        Parameters
        ----------
        G : NetworkX graph or list of nodes
            A position will be assigned to every node in G.

        weight : string or None   optional (default='weight')
            The edge attribute that holds the numerical value used for
            the edge weight.  If None, then all edge weights are 1.

        scale : number (default: 1)
            Scale factor for positions.

        center : array-like or None
            Coordinate pair around which to center the layout.

        dim : int
            Dimension of layout.

        Returns
        -------
        pos : dict
            A dictionary of positions keyed by node

        Examples
        --------
        >>> G = nx.path_graph(4)
        >>> pos = nx.spectral_layout(G)

        Notes
        -----
        Directed graphs will be considered as undirected graphs when
        positioning the nodes.

        For larger graphs (>500 nodes) this will use the SciPy sparse
        eigenvalue solver (ARPACK).
    
    """
def _spectral(A, dim=2):
    """
     Input adjacency matrix A
     Uses dense eigenvalue solver from numpy

    """
def _sparse_spectral(A, dim=2):
    """
     Input adjacency matrix A
     Uses sparse eigenvalue solver from scipy
     Could use multilevel methods here, see Koren "On spectral graph drawing

    """
def planar_layout(G, scale=1, center=None, dim=2):
    """
    Position nodes without edge intersections.

        Parameters
        ----------
        G : NetworkX graph or list of nodes
            A position will be assigned to every node in G. If G is of type
            nx.PlanarEmbedding, the positions are selected accordingly.

        scale : number (default: 1)
            Scale factor for positions.

        center : array-like or None
            Coordinate pair around which to center the layout.

        dim : int
            Dimension of layout.

        Returns
        -------
        pos : dict
            A dictionary of positions keyed by node

        Raises
        ------
        NetworkXException
            If G is not planar

        Examples
        --------
        >>> G = nx.path_graph(4)
        >>> pos = nx.planar_layout(G)
    
    """
def spiral_layout(G, scale=1, center=None, dim=2, resolution=0.35, equidistant=False):
    """
    Position nodes in a spiral layout.

        Parameters
        ----------
        G : NetworkX graph or list of nodes
            A position will be assigned to every node in G.
        scale : number (default: 1)
            Scale factor for positions.
        center : array-like or None
            Coordinate pair around which to center the layout.
        dim : int
            Dimension of layout, currently only dim=2 is supported.
            Other dimension values result in a ValueError.
        resolution : float
            The compactness of the spiral layout returned.
            Lower values result in more compressed spiral layouts.
        equidistant : bool
            If True, nodes will be plotted equidistant from each other.
        Returns
        -------
        pos : dict
            A dictionary of positions keyed by node
        Raises
        -------
        ValueError
            If dim != 2

        Examples
        --------
        >>> G = nx.path_graph(4)
        >>> pos = nx.spiral_layout(G)

        Notes
        -----
        This algorithm currently only works in two dimensions.

    
    """
def multipartite_layout(G, subset_key="subset", align="vertical", scale=1, center=None):
    """
    Position nodes in layers of straight lines.

        Parameters
        ----------
        G : NetworkX graph or list of nodes
            A position will be assigned to every node in G.

        subset_key : string (default='subset')
            Key of node data to be used as layer subset.

        align : string (default='vertical')
            The alignment of nodes. Vertical or horizontal.

        scale : number (default: 1)
            Scale factor for positions.

        center : array-like or None
            Coordinate pair around which to center the layout.

        Returns
        -------
        pos : dict
            A dictionary of positions keyed by node.

        Examples
        --------
        >>> G = nx.complete_multipartite_graph(28, 16, 10)
        >>> pos = nx.multipartite_layout(G)

        Notes
        -----
        This algorithm currently only works in two dimensions and does not
        try to minimize edge crossings.

        Network does not need to be a complete multipartite graph. As long as nodes
        have subset_key data, they will be placed in the corresponding layers.

    
    """
def rescale_layout(pos, scale=1):
    """
    Returns scaled position array to (-scale, scale) in all axes.

        The function acts on NumPy arrays which hold position information.
        Each position is one row of the array. The dimension of the space
        equals the number of columns. Each coordinate in one column.

        To rescale, the mean (center) is subtracted from each axis separately.
        Then all values are scaled so that the largest magnitude value
        from all axes equals `scale` (thus, the aspect ratio is preserved).
        The resulting NumPy Array is returned (order of rows unchanged).

        Parameters
        ----------
        pos : numpy array
            positions to be scaled. Each row is a position.

        scale : number (default: 1)
            The size of the resulting extent in all directions.

        Returns
        -------
        pos : numpy array
            scaled positions. Each row is a position.

        See Also
        --------
        rescale_layout_dict
    
    """
def rescale_layout_dict(pos, scale=1):
    """
    Return a dictionary of scaled positions keyed by node

        Parameters
        ----------
        pos : A dictionary of positions keyed by node

        scale : number (default: 1)
            The size of the resulting extent in all directions.

        Returns
        -------
        pos : A dictionary of positions keyed by node

        Examples
        --------
        >>> pos = {0: (0, 0), 1: (1, 1), 2: (0.5, 0.5)}
        >>> nx.rescale_layout_dict(pos)
        {0: (-1.0, -1.0), 1: (1.0, 1.0), 2: (0.0, 0.0)}

        >>> pos = {0: (0, 0), 1: (-1, 1), 2: (-0.5, 0.5)}
        >>> nx.rescale_layout_dict(pos, scale=2)
        {0: (2.0, -2.0), 1: (-2.0, 2.0), 2: (0.0, 0.0)}

        See Also
        --------
        rescale_layout
    
    """
