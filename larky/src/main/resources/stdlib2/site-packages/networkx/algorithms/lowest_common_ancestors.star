def tree_all_pairs_lowest_common_ancestor(G, root=None, pairs=None):
    """
    r"""Yield the lowest common ancestor for sets of pairs in a tree.

        Parameters
        ----------
        G : NetworkX directed graph (must be a tree)

        root : node, optional (default: None)
            The root of the subtree to operate on.
            If None, assume the entire graph has exactly one source and use that.

        pairs : iterable or iterator of pairs of nodes, optional (default: None)
            The pairs of interest. If None, Defaults to all pairs of nodes
            under `root` that have a lowest common ancestor.

        Returns
        -------
        lcas : generator of tuples `((u, v), lca)` where `u` and `v` are nodes
            in `pairs` and `lca` is their lowest common ancestor.

        Notes
        -----
        Only defined on non-null trees represented with directed edges from
        parents to children. Uses Tarjan's off-line lowest-common-ancestors
        algorithm. Runs in time $O(4 \times (V + E + P))$ time, where 4 is the largest
        value of the inverse Ackermann function likely to ever come up in actual
        use, and $P$ is the number of pairs requested (or $V^2$ if all are needed).

        Tarjan, R. E. (1979), "Applications of path compression on balanced trees",
        Journal of the ACM 26 (4): 690-715, doi:10.1145/322154.322161.

        See Also
        --------
        all_pairs_lowest_common_ancestor (similar routine for general DAGs)
        lowest_common_ancestor           (just a single pair for general DAGs)
    
    """
def lowest_common_ancestor(G, node1, node2, default=None):
    """
    Compute the lowest common ancestor of the given pair of nodes.

        Parameters
        ----------
        G : NetworkX directed graph

        node1, node2 : nodes in the graph.

        default : object
            Returned if no common ancestor between `node1` and `node2`

        Returns
        -------
        The lowest common ancestor of node1 and node2,
        or default if they have no common ancestors.

        Notes
        -----
        Only defined on non-null directed acyclic graphs.
        Takes n log(n) time in the size of the graph.
        See `all_pairs_lowest_common_ancestor` when you have
        more than one pair of nodes of interest.

        See Also
        --------
        tree_all_pairs_lowest_common_ancestor
        all_pairs_lowest_common_ancestor
    
    """
def all_pairs_lowest_common_ancestor(G, pairs=None):
    """
    Compute the lowest common ancestor for pairs of nodes.

        Parameters
        ----------
        G : NetworkX directed graph

        pairs : iterable of pairs of nodes, optional (default: all pairs)
            The pairs of nodes of interest.
            If None, will find the LCA of all pairs of nodes.

        Returns
        -------
        An iterator over ((node1, node2), lca) where (node1, node2) are
        the pairs specified and lca is a lowest common ancestor of the pair.
        Note that for the default of all pairs in G, we consider
        unordered pairs, e.g. you will not get both (b, a) and (a, b).

        Notes
        -----
        Only defined on non-null directed acyclic graphs.

        Uses the $O(n^3)$ ancestor-list algorithm from:
        M. A. Bender, M. Farach-Colton, G. Pemmasani, S. Skiena, P. Sumazin.
        "Lowest common ancestors in trees and directed acyclic graphs."
        Journal of Algorithms, 57(2): 75-94, 2005.

        See Also
        --------
        tree_all_pairs_lowest_common_ancestor
        lowest_common_ancestor
    
    """
    def _compute_dag_lca_from_tree_values(tree_lca, dry_run):
        """
        Iterate through the in-order merge for each pair of interest.

                We do this to answer the user's query, but it is also used to
                avoid generating unnecessary tree entries when the user only
                needs some pairs.
        
        """
            def get_next_in_merged_lists(indices):
                """
                Returns index of the list containing the next item

                                Next order refers to the merged order.
                                Index can be 0 or 1 (or None if exhausted).
                
                """
