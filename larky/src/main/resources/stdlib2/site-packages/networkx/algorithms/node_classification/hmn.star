def harmonic_function(G, max_iter=30, label_name="label"):
    """
    Node classification by Harmonic function

        Parameters
        ----------
        G : NetworkX Graph
        max_iter : int
            maximum number of iterations allowed
        label_name : string
            name of target labels to predict

        Returns
        ----------
        predicted : array, shape = [n_samples]
            Array of predicted labels

        Raises
        ----------
        NetworkXError
            If no nodes on `G` has `label_name`.

        Examples
        --------
        >>> from networkx.algorithms import node_classification
        >>> G = nx.path_graph(4)
        >>> G.nodes[0]["label"] = "A"
        >>> G.nodes[3]["label"] = "B"
        >>> G.nodes(data=True)
        NodeDataView({0: {'label': 'A'}, 1: {}, 2: {}, 3: {'label': 'B'}})
        >>> G.edges()
        EdgeView([(0, 1), (1, 2), (2, 3)])
        >>> predicted = node_classification.harmonic_function(G)
        >>> predicted
        ['A', 'A', 'B', 'B']

        References
        ----------
        Zhu, X., Ghahramani, Z., & Lafferty, J. (2003, August).
        Semi-supervised learning using gaussian fields and harmonic functions.
        In ICML (Vol. 3, pp. 912-919).
    
    """
    def _build_propagation_matrix(X, labels):
        """
        Build propagation matrix of Harmonic function

                Parameters
                ----------
                X : scipy sparse matrix, shape = [n_samples, n_samples]
                    Adjacency matrix
                labels : array, shape = [n_samples, 2]
                    Array of pairs of node id and label id

                Returns
                ----------
                P : scipy sparse matrix, shape = [n_samples, n_samples]
                    Propagation matrix

        
        """
    def _build_base_matrix(X, labels, n_classes):
        """
        Build base matrix of Harmonic function

                Parameters
                ----------
                X : scipy sparse matrix, shape = [n_samples, n_samples]
                    Adjacency matrix
                labels : array, shape = [n_samples, 2]
                    Array of pairs of node id and label id
                n_classes : integer
                    The number of classes (distinct labels) on the input graph

                Returns
                ----------
                B : array, shape = [n_samples, n_classes]
                    Base matrix
        
        """
