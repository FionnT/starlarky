def descendants(G, source):
    """
    Returns all nodes reachable from `source` in `G`.

        Parameters
        ----------
        G : NetworkX DiGraph
            A directed acyclic graph (DAG)
        source : node in `G`

        Returns
        -------
        set()
            The descendants of `source` in `G`
    
    """
def ancestors(G, source):
    """
    Returns all nodes having a path to `source` in `G`.

        Parameters
        ----------
        G : NetworkX DiGraph
            A directed acyclic graph (DAG)
        source : node in `G`

        Returns
        -------
        set()
            The ancestors of source in G
    
    """
def has_cycle(G):
    """
    Decides whether the directed graph has a cycle.
    """
def is_directed_acyclic_graph(G):
    """
    Returns True if the graph `G` is a directed acyclic graph (DAG) or
        False if not.

        Parameters
        ----------
        G : NetworkX graph

        Returns
        -------
        bool
            True if `G` is a DAG, False otherwise
    
    """
def topological_sort(G):
    """
    Returns a generator of nodes in topologically sorted order.

        A topological sort is a nonunique permutation of the nodes such that an
        edge from u to v implies that u appears before v in the topological sort
        order.

        Parameters
        ----------
        G : NetworkX digraph
            A directed acyclic graph (DAG)

        Returns
        -------
        iterable
            An iterable of node names in topological sorted order.

        Raises
        ------
        NetworkXError
            Topological sort is defined for directed graphs only. If the graph `G`
            is undirected, a :exc:`NetworkXError` is raised.

        NetworkXUnfeasible
            If `G` is not a directed acyclic graph (DAG) no topological sort exists
            and a :exc:`NetworkXUnfeasible` exception is raised.  This can also be
            raised if `G` is changed while the returned iterator is being processed

        RuntimeError
            If `G` is changed while the returned iterator is being processed.

        Examples
        --------
        To get the reverse order of the topological sort:

        >>> DG = nx.DiGraph([(1, 2), (2, 3)])
        >>> list(reversed(list(nx.topological_sort(DG))))
        [3, 2, 1]

        If your DiGraph naturally has the edges representing tasks/inputs
        and nodes representing people/processes that initiate tasks, then
        topological_sort is not quite what you need. You will have to change
        the tasks to nodes with dependence reflected by edges. The result is
        a kind of topological sort of the edges. This can be done
        with :func:`networkx.line_graph` as follows:

        >>> list(nx.topological_sort(nx.line_graph(DG)))
        [(1, 2), (2, 3)]

        Notes
        -----
        This algorithm is based on a description and proof in
        "Introduction to Algorithms: A Creative Approach" [1]_ .

        See also
        --------
        is_directed_acyclic_graph, lexicographical_topological_sort

        References
        ----------
        .. [1] Manber, U. (1989).
           *Introduction to Algorithms - A Creative Approach.* Addison-Wesley.
    
    """
def lexicographical_topological_sort(G, key=None):
    """
    Returns a generator of nodes in lexicographically topologically sorted
        order.

        A topological sort is a nonunique permutation of the nodes such that an
        edge from u to v implies that u appears before v in the topological sort
        order.

        Parameters
        ----------
        G : NetworkX digraph
            A directed acyclic graph (DAG)

        key : function, optional
            This function maps nodes to keys with which to resolve ambiguities in
            the sort order.  Defaults to the identity function.

        Returns
        -------
        iterable
            An iterable of node names in lexicographical topological sort order.

        Raises
        ------
        NetworkXError
            Topological sort is defined for directed graphs only. If the graph `G`
            is undirected, a :exc:`NetworkXError` is raised.

        NetworkXUnfeasible
            If `G` is not a directed acyclic graph (DAG) no topological sort exists
            and a :exc:`NetworkXUnfeasible` exception is raised.  This can also be
            raised if `G` is changed while the returned iterator is being processed

        RuntimeError
            If `G` is changed while the returned iterator is being processed.

        Notes
        -----
        This algorithm is based on a description and proof in
        "Introduction to Algorithms: A Creative Approach" [1]_ .

        See also
        --------
        topological_sort

        References
        ----------
        .. [1] Manber, U. (1989).
           *Introduction to Algorithms - A Creative Approach.* Addison-Wesley.
    
    """
        def key(node):
            """
             These nodes have zero indegree and ready to be returned.

            """
def all_topological_sorts(G):
    """
    Returns a generator of _all_ topological sorts of the directed graph G.

        A topological sort is a nonunique permutation of the nodes such that an
        edge from u to v implies that u appears before v in the topological sort
        order.

        Parameters
        ----------
        G : NetworkX DiGraph
            A directed graph

        Returns
        -------
        generator
            All topological sorts of the digraph G

        Raises
        ------
        NetworkXNotImplemented
            If `G` is not directed
        NetworkXUnfeasible
            If `G` is not acyclic

        Examples
        --------
        To enumerate all topological sorts of directed graph:

        >>> DG = nx.DiGraph([(1, 2), (2, 3), (2, 4)])
        >>> list(nx.all_topological_sorts(DG))
        [[1, 2, 4, 3], [1, 2, 3, 4]]

        Notes
        -----
        Implements an iterative version of the algorithm given in [1].

        References
        ----------
        .. [1] Knuth, Donald E., Szwarcfiter, Jayme L. (1974).
           "A Structured Program to Generate All Topological Sorting Arrangements"
           Information Processing Letters, Volume 2, Issue 6, 1974, Pages 153-157,
           ISSN 0020-0190,
           https://doi.org/10.1016/0020-0190(74)90001-5.
           Elsevier (North-Holland), Amsterdam
    
    """
def is_aperiodic(G):
    """
    Returns True if `G` is aperiodic.

        A directed graph is aperiodic if there is no integer k > 1 that
        divides the length of every cycle in the graph.

        Parameters
        ----------
        G : NetworkX DiGraph
            A directed graph

        Returns
        -------
        bool
            True if the graph is aperiodic False otherwise

        Raises
        ------
        NetworkXError
            If `G` is not directed

        Notes
        -----
        This uses the method outlined in [1]_, which runs in $O(m)$ time
        given $m$ edges in `G`. Note that a graph is not aperiodic if it is
        acyclic as every integer trivial divides length 0 cycles.

        References
        ----------
        .. [1] Jarvis, J. P.; Shier, D. R. (1996),
           "Graph-theoretic analysis of finite Markov chains,"
           in Shier, D. R.; Wallenius, K. T., Applied Mathematical Modeling:
           A Multidisciplinary Approach, CRC Press.
    
    """
def transitive_closure(G, reflexive=False):
    """
     Returns transitive closure of a directed graph

        The transitive closure of G = (V,E) is a graph G+ = (V,E+) such that
        for all v, w in V there is an edge (v, w) in E+ if and only if there
        is a path from v to w in G.

        Handling of paths from v to v has some flexibility within this definition.
        A reflexive transitive closure creates a self-loop for the path
        from v to v of length 0. The usual transitive closure creates a
        self-loop only if a cycle exists (a path from v to v with length > 0).
        We also allow an option for no self-loops.

        Parameters
        ----------
        G : NetworkX DiGraph
            A directed graph
        reflexive : Bool or None, optional (default: False)
            Determines when cycles create self-loops in the Transitive Closure.
            If True, trivial cycles (length 0) create self-loops. The result
            is a reflexive tranistive closure of G.
            If False (the default) non-trivial cycles create self-loops.
            If None, self-loops are not created.

        Returns
        -------
        NetworkX DiGraph
            The transitive closure of `G`

        Raises
        ------
        NetworkXNotImplemented
            If `G` is not directed

        References
        ----------
        .. [1] http://www.ics.uci.edu/~eppstein/PADS/PartialOrder.py

        TODO this function applies to all directed graphs and is probably misplaced
             here in dag.py
    
    """
def transitive_closure_dag(G, topo_order=None):
    """
     Returns the transitive closure of a directed acyclic graph.

        This function is faster than the function `transitive_closure`, but fails
        if the graph has a cycle.

        The transitive closure of G = (V,E) is a graph G+ = (V,E+) such that
        for all v, w in V there is an edge (v, w) in E+ if and only if there
        is a non-null path from v to w in G.

        Parameters
        ----------
        G : NetworkX DiGraph
            A directed acyclic graph (DAG)

        topo_order: list or tuple, optional
            A topological order for G (if None, the function will compute one)

        Returns
        -------
        NetworkX DiGraph
            The transitive closure of `G`

        Raises
        ------
        NetworkXNotImplemented
            If `G` is not directed
        NetworkXUnfeasible
            If `G` has a cycle

        Notes
        -----
        This algorithm is probably simple enough to be well-known but I didn't find
        a mention in the literature.
    
    """
def transitive_reduction(G):
    """
     Returns transitive reduction of a directed graph

        The transitive reduction of G = (V,E) is a graph G- = (V,E-) such that
        for all v,w in V there is an edge (v,w) in E- if and only if (v,w) is
        in E and there is no path from v to w in G with length greater than 1.

        Parameters
        ----------
        G : NetworkX DiGraph
            A directed acyclic graph (DAG)

        Returns
        -------
        NetworkX DiGraph
            The transitive reduction of `G`

        Raises
        ------
        NetworkXError
            If `G` is not a directed acyclic graph (DAG) transitive reduction is
            not uniquely defined and a :exc:`NetworkXError` exception is raised.

        References
        ----------
        https://en.wikipedia.org/wiki/Transitive_reduction

    
    """
def antichains(G, topo_order=None):
    """
    Generates antichains from a directed acyclic graph (DAG).

        An antichain is a subset of a partially ordered set such that any
        two elements in the subset are incomparable.

        Parameters
        ----------
        G : NetworkX DiGraph
            A directed acyclic graph (DAG)

        topo_order: list or tuple, optional
            A topological order for G (if None, the function will compute one)

        Returns
        -------
        generator object

        Raises
        ------
        NetworkXNotImplemented
            If `G` is not directed

        NetworkXUnfeasible
            If `G` contains a cycle

        Notes
        -----
        This function was originally developed by Peter Jipsen and Franco Saliola
        for the SAGE project. It's included in NetworkX with permission from the
        authors. Original SAGE code at:

        https://github.com/sagemath/sage/blob/master/src/sage/combinat/posets/hasse_diagram.py

        References
        ----------
        .. [1] Free Lattices, by R. Freese, J. Jezek and J. B. Nation,
           AMS, Vol 42, 1995, p. 226.
    
    """
def dag_longest_path(G, weight="weight", default_weight=1, topo_order=None):
    """
    Returns the longest path in a directed acyclic graph (DAG).

        If `G` has edges with `weight` attribute the edge data are used as
        weight values.

        Parameters
        ----------
        G : NetworkX DiGraph
            A directed acyclic graph (DAG)

        weight : str, optional
            Edge data key to use for weight

        default_weight : int, optional
            The weight of edges that do not have a weight attribute

        topo_order: list or tuple, optional
            A topological order for G (if None, the function will compute one)

        Returns
        -------
        list
            Longest path

        Raises
        ------
        NetworkXNotImplemented
            If `G` is not directed

        See also
        --------
        dag_longest_path_length

    
    """
def dag_longest_path_length(G, weight="weight", default_weight=1):
    """
    Returns the longest path length in a DAG

        Parameters
        ----------
        G : NetworkX DiGraph
            A directed acyclic graph (DAG)

        weight : string, optional
            Edge data key to use for weight

        default_weight : int, optional
            The weight of edges that do not have a weight attribute

        Returns
        -------
        int
            Longest path length

        Raises
        ------
        NetworkXNotImplemented
            If `G` is not directed

        See also
        --------
        dag_longest_path
    
    """
def root_to_leaf_paths(G):
    """
    Yields root-to-leaf paths in a directed acyclic graph.

        `G` must be a directed acyclic graph. If not, the behavior of this
        function is undefined. A "root" in this graph is a node of in-degree
        zero and a "leaf" a node of out-degree zero.

        When invoked, this function iterates over each path from any root to
        any leaf. A path is a list of nodes.

    
    """
def dag_to_branching(G):
    """
    Returns a branching representing all (overlapping) paths from
        root nodes to leaf nodes in the given directed acyclic graph.

        As described in :mod:`networkx.algorithms.tree.recognition`, a
        *branching* is a directed forest in which each node has at most one
        parent. In other words, a branching is a disjoint union of
        *arborescences*. For this function, each node of in-degree zero in
        `G` becomes a root of one of the arborescences, and there will be
        one leaf node for each distinct path from that root to a leaf node
        in `G`.

        Each node `v` in `G` with *k* parents becomes *k* distinct nodes in
        the returned branching, one for each parent, and the sub-DAG rooted
        at `v` is duplicated for each copy. The algorithm then recurses on
        the children of each copy of `v`.

        Parameters
        ----------
        G : NetworkX graph
            A directed acyclic graph.

        Returns
        -------
        DiGraph
            The branching in which there is a bijection between root-to-leaf
            paths in `G` (in which multiple paths may share the same leaf)
            and root-to-leaf paths in the branching (in which there is a
            unique path from a root to a leaf).

            Each node has an attribute 'source' whose value is the original
            node to which this node corresponds. No other graph, node, or
            edge attributes are copied into this new graph.

        Raises
        ------
        NetworkXNotImplemented
            If `G` is not directed, or if `G` is a multigraph.

        HasACycle
            If `G` is not acyclic.

        Examples
        --------
        To examine which nodes in the returned branching were produced by
        which original node in the directed acyclic graph, we can collect
        the mapping from source node to new nodes into a dictionary. For
        example, consider the directed diamond graph::

            >>> from collections import defaultdict
            >>> from operator import itemgetter
            >>>
            >>> G = nx.DiGraph(nx.utils.pairwise("abd"))
            >>> G.add_edges_from(nx.utils.pairwise("acd"))
            >>> B = nx.dag_to_branching(G)
            >>>
            >>> sources = defaultdict(set)
            >>> for v, source in B.nodes(data="source"):
            ...     sources[source].add(v)
            >>> len(sources["a"])
            1
            >>> len(sources["d"])
            2

        To copy node attributes from the original graph to the new graph,
        you can use a dictionary like the one constructed in the above
        example::

            >>> for source, nodes in sources.items():
            ...     for v in nodes:
            ...         B.nodes[v].update(G.nodes[source])

        Notes
        -----
        This function is not idempotent in the sense that the node labels in
        the returned branching may be uniquely generated each time the
        function is invoked. In fact, the node labels may not be integers;
        in order to relabel the nodes to be more readable, you can use the
        :func:`networkx.convert_node_labels_to_integers` function.

        The current implementation of this function uses
        :func:`networkx.prefix_tree`, so it is subject to the limitations of
        that function.

    
    """
