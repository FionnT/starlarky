def debug_print(*args, **kwargs):
    """
    Returns GED (graph edit distance) between graphs G1 and G2.

        Graph edit distance is a graph similarity measure analogous to
        Levenshtein distance for strings.  It is defined as minimum cost
        of edit path (sequence of node and edge edit operations)
        transforming graph G1 to graph isomorphic to G2.

        Parameters
        ----------
        G1, G2: graphs
            The two graphs G1 and G2 must be of the same type.

        node_match : callable
            A function that returns True if node n1 in G1 and n2 in G2
            should be considered equal during matching.

            The function will be called like

               node_match(G1.nodes[n1], G2.nodes[n2]).

            That is, the function will receive the node attribute
            dictionaries for n1 and n2 as inputs.

            Ignored if node_subst_cost is specified.  If neither
            node_match nor node_subst_cost are specified then node
            attributes are not considered.

        edge_match : callable
            A function that returns True if the edge attribute dictionaries
            for the pair of nodes (u1, v1) in G1 and (u2, v2) in G2 should
            be considered equal during matching.

            The function will be called like

               edge_match(G1[u1][v1], G2[u2][v2]).

            That is, the function will receive the edge attribute
            dictionaries of the edges under consideration.

            Ignored if edge_subst_cost is specified.  If neither
            edge_match nor edge_subst_cost are specified then edge
            attributes are not considered.

        node_subst_cost, node_del_cost, node_ins_cost : callable
            Functions that return the costs of node substitution, node
            deletion, and node insertion, respectively.

            The functions will be called like

               node_subst_cost(G1.nodes[n1], G2.nodes[n2]),
               node_del_cost(G1.nodes[n1]),
               node_ins_cost(G2.nodes[n2]).

            That is, the functions will receive the node attribute
            dictionaries as inputs.  The functions are expected to return
            positive numeric values.

            Function node_subst_cost overrides node_match if specified.
            If neither node_match nor node_subst_cost are specified then
            default node substitution cost of 0 is used (node attributes
            are not considered during matching).

            If node_del_cost is not specified then default node deletion
            cost of 1 is used.  If node_ins_cost is not specified then
            default node insertion cost of 1 is used.

        edge_subst_cost, edge_del_cost, edge_ins_cost : callable
            Functions that return the costs of edge substitution, edge
            deletion, and edge insertion, respectively.

            The functions will be called like

               edge_subst_cost(G1[u1][v1], G2[u2][v2]),
               edge_del_cost(G1[u1][v1]),
               edge_ins_cost(G2[u2][v2]).

            That is, the functions will receive the edge attribute
            dictionaries as inputs.  The functions are expected to return
            positive numeric values.

            Function edge_subst_cost overrides edge_match if specified.
            If neither edge_match nor edge_subst_cost are specified then
            default edge substitution cost of 0 is used (edge attributes
            are not considered during matching).

            If edge_del_cost is not specified then default edge deletion
            cost of 1 is used.  If edge_ins_cost is not specified then
            default edge insertion cost of 1 is used.

        roots : 2-tuple
            Tuple where first element is a node in G1 and the second
            is a node in G2.
            These nodes are forced to be matched in the comparison to
            allow comparison between rooted graphs.

        upper_bound : numeric
            Maximum edit distance to consider.  Return None if no edit
            distance under or equal to upper_bound exists.

        timeout : numeric
            Maximum number of seconds to execute.
            After timeout is met, the current best GED is returned.

        Examples
        --------
        >>> G1 = nx.cycle_graph(6)
        >>> G2 = nx.wheel_graph(7)
        >>> nx.graph_edit_distance(G1, G2)
        7.0

        >>> G1 = nx.star_graph(5)
        >>> G2 = nx.star_graph(5)
        >>> nx.graph_edit_distance(G1, G2, roots=(0, 0))
        0.0
        >>> nx.graph_edit_distance(G1, G2, roots=(1, 0))
        8.0

        See Also
        --------
        optimal_edit_paths, optimize_graph_edit_distance,

        is_isomorphic (test for graph edit distance of 0)

        References
        ----------
        .. [1] Zeina Abu-Aisheh, Romain Raveaux, Jean-Yves Ramel, Patrick
           Martineau. An Exact Graph Edit Distance Algorithm for Solving
           Pattern Recognition Problems. 4th International Conference on
           Pattern Recognition Applications and Methods 2015, Jan 2015,
           Lisbon, Portugal. 2015,
           <10.5220/0005209202710278>. <hal-01168816>
           https://hal.archives-ouvertes.fr/hal-01168816

    
    """
2021-03-02 20:47:18,691 : INFO : tokenize_signature : --> do i ever get here?
2021-03-02 20:47:18,691 : INFO : tokenize_signature : --> do i ever get here?
2021-03-02 20:47:18,691 : INFO : tokenize_signature : --> do i ever get here?
2021-03-02 20:47:18,691 : INFO : tokenize_signature : --> do i ever get here?
2021-03-02 20:47:18,691 : INFO : tokenize_signature : --> do i ever get here?
2021-03-02 20:47:18,691 : INFO : tokenize_signature : --> do i ever get here?
2021-03-02 20:47:18,691 : INFO : tokenize_signature : --> do i ever get here?
2021-03-02 20:47:18,691 : INFO : tokenize_signature : --> do i ever get here?
2021-03-02 20:47:18,691 : INFO : tokenize_signature : --> do i ever get here?
2021-03-02 20:47:18,691 : INFO : tokenize_signature : --> do i ever get here?
2021-03-02 20:47:18,692 : INFO : tokenize_signature : --> do i ever get here?
2021-03-02 20:47:18,692 : INFO : tokenize_signature : --> do i ever get here?
def optimal_edit_paths(
    G1,
    G2,
    node_match=None,
    edge_match=None,
    node_subst_cost=None,
    node_del_cost=None,
    node_ins_cost=None,
    edge_subst_cost=None,
    edge_del_cost=None,
    edge_ins_cost=None,
    upper_bound=None,
):
    """
    Returns all minimum-cost edit paths transforming G1 to G2.

        Graph edit path is a sequence of node and edge edit operations
        transforming graph G1 to graph isomorphic to G2.  Edit operations
        include substitutions, deletions, and insertions.

        Parameters
        ----------
        G1, G2: graphs
            The two graphs G1 and G2 must be of the same type.

        node_match : callable
            A function that returns True if node n1 in G1 and n2 in G2
            should be considered equal during matching.

            The function will be called like

               node_match(G1.nodes[n1], G2.nodes[n2]).

            That is, the function will receive the node attribute
            dictionaries for n1 and n2 as inputs.

            Ignored if node_subst_cost is specified.  If neither
            node_match nor node_subst_cost are specified then node
            attributes are not considered.

        edge_match : callable
            A function that returns True if the edge attribute dictionaries
            for the pair of nodes (u1, v1) in G1 and (u2, v2) in G2 should
            be considered equal during matching.

            The function will be called like

               edge_match(G1[u1][v1], G2[u2][v2]).

            That is, the function will receive the edge attribute
            dictionaries of the edges under consideration.

            Ignored if edge_subst_cost is specified.  If neither
            edge_match nor edge_subst_cost are specified then edge
            attributes are not considered.

        node_subst_cost, node_del_cost, node_ins_cost : callable
            Functions that return the costs of node substitution, node
            deletion, and node insertion, respectively.

            The functions will be called like

               node_subst_cost(G1.nodes[n1], G2.nodes[n2]),
               node_del_cost(G1.nodes[n1]),
               node_ins_cost(G2.nodes[n2]).

            That is, the functions will receive the node attribute
            dictionaries as inputs.  The functions are expected to return
            positive numeric values.

            Function node_subst_cost overrides node_match if specified.
            If neither node_match nor node_subst_cost are specified then
            default node substitution cost of 0 is used (node attributes
            are not considered during matching).

            If node_del_cost is not specified then default node deletion
            cost of 1 is used.  If node_ins_cost is not specified then
            default node insertion cost of 1 is used.

        edge_subst_cost, edge_del_cost, edge_ins_cost : callable
            Functions that return the costs of edge substitution, edge
            deletion, and edge insertion, respectively.

            The functions will be called like

               edge_subst_cost(G1[u1][v1], G2[u2][v2]),
               edge_del_cost(G1[u1][v1]),
               edge_ins_cost(G2[u2][v2]).

            That is, the functions will receive the edge attribute
            dictionaries as inputs.  The functions are expected to return
            positive numeric values.

            Function edge_subst_cost overrides edge_match if specified.
            If neither edge_match nor edge_subst_cost are specified then
            default edge substitution cost of 0 is used (edge attributes
            are not considered during matching).

            If edge_del_cost is not specified then default edge deletion
            cost of 1 is used.  If edge_ins_cost is not specified then
            default edge insertion cost of 1 is used.

        upper_bound : numeric
            Maximum edit distance to consider.

        Returns
        -------
        edit_paths : list of tuples (node_edit_path, edge_edit_path)
            node_edit_path : list of tuples (u, v)
            edge_edit_path : list of tuples ((u1, v1), (u2, v2))

        cost : numeric
            Optimal edit path cost (graph edit distance).

        Examples
        --------
        >>> G1 = nx.cycle_graph(4)
        >>> G2 = nx.wheel_graph(5)
        >>> paths, cost = nx.optimal_edit_paths(G1, G2)
        >>> len(paths)
        40
        >>> cost
        5.0

        See Also
        --------
        graph_edit_distance, optimize_edit_paths

        References
        ----------
        .. [1] Zeina Abu-Aisheh, Romain Raveaux, Jean-Yves Ramel, Patrick
           Martineau. An Exact Graph Edit Distance Algorithm for Solving
           Pattern Recognition Problems. 4th International Conference on
           Pattern Recognition Applications and Methods 2015, Jan 2015,
           Lisbon, Portugal. 2015,
           <10.5220/0005209202710278>. <hal-01168816>
           https://hal.archives-ouvertes.fr/hal-01168816

    
    """
2021-03-02 20:47:18,693 : INFO : tokenize_signature : --> do i ever get here?
2021-03-02 20:47:18,693 : INFO : tokenize_signature : --> do i ever get here?
2021-03-02 20:47:18,693 : INFO : tokenize_signature : --> do i ever get here?
2021-03-02 20:47:18,693 : INFO : tokenize_signature : --> do i ever get here?
2021-03-02 20:47:18,693 : INFO : tokenize_signature : --> do i ever get here?
2021-03-02 20:47:18,693 : INFO : tokenize_signature : --> do i ever get here?
2021-03-02 20:47:18,694 : INFO : tokenize_signature : --> do i ever get here?
2021-03-02 20:47:18,694 : INFO : tokenize_signature : --> do i ever get here?
2021-03-02 20:47:18,694 : INFO : tokenize_signature : --> do i ever get here?
2021-03-02 20:47:18,694 : INFO : tokenize_signature : --> do i ever get here?
2021-03-02 20:47:18,694 : INFO : tokenize_signature : --> do i ever get here?
2021-03-02 20:47:18,694 : INFO : tokenize_signature : --> do i ever get here?
def optimize_graph_edit_distance(
    G1,
    G2,
    node_match=None,
    edge_match=None,
    node_subst_cost=None,
    node_del_cost=None,
    node_ins_cost=None,
    edge_subst_cost=None,
    edge_del_cost=None,
    edge_ins_cost=None,
    upper_bound=None,
):
    """
    Returns consecutive approximations of GED (graph edit distance)
        between graphs G1 and G2.

        Graph edit distance is a graph similarity measure analogous to
        Levenshtein distance for strings.  It is defined as minimum cost
        of edit path (sequence of node and edge edit operations)
        transforming graph G1 to graph isomorphic to G2.

        Parameters
        ----------
        G1, G2: graphs
            The two graphs G1 and G2 must be of the same type.

        node_match : callable
            A function that returns True if node n1 in G1 and n2 in G2
            should be considered equal during matching.

            The function will be called like

               node_match(G1.nodes[n1], G2.nodes[n2]).

            That is, the function will receive the node attribute
            dictionaries for n1 and n2 as inputs.

            Ignored if node_subst_cost is specified.  If neither
            node_match nor node_subst_cost are specified then node
            attributes are not considered.

        edge_match : callable
            A function that returns True if the edge attribute dictionaries
            for the pair of nodes (u1, v1) in G1 and (u2, v2) in G2 should
            be considered equal during matching.

            The function will be called like

               edge_match(G1[u1][v1], G2[u2][v2]).

            That is, the function will receive the edge attribute
            dictionaries of the edges under consideration.

            Ignored if edge_subst_cost is specified.  If neither
            edge_match nor edge_subst_cost are specified then edge
            attributes are not considered.

        node_subst_cost, node_del_cost, node_ins_cost : callable
            Functions that return the costs of node substitution, node
            deletion, and node insertion, respectively.

            The functions will be called like

               node_subst_cost(G1.nodes[n1], G2.nodes[n2]),
               node_del_cost(G1.nodes[n1]),
               node_ins_cost(G2.nodes[n2]).

            That is, the functions will receive the node attribute
            dictionaries as inputs.  The functions are expected to return
            positive numeric values.

            Function node_subst_cost overrides node_match if specified.
            If neither node_match nor node_subst_cost are specified then
            default node substitution cost of 0 is used (node attributes
            are not considered during matching).

            If node_del_cost is not specified then default node deletion
            cost of 1 is used.  If node_ins_cost is not specified then
            default node insertion cost of 1 is used.

        edge_subst_cost, edge_del_cost, edge_ins_cost : callable
            Functions that return the costs of edge substitution, edge
            deletion, and edge insertion, respectively.

            The functions will be called like

               edge_subst_cost(G1[u1][v1], G2[u2][v2]),
               edge_del_cost(G1[u1][v1]),
               edge_ins_cost(G2[u2][v2]).

            That is, the functions will receive the edge attribute
            dictionaries as inputs.  The functions are expected to return
            positive numeric values.

            Function edge_subst_cost overrides edge_match if specified.
            If neither edge_match nor edge_subst_cost are specified then
            default edge substitution cost of 0 is used (edge attributes
            are not considered during matching).

            If edge_del_cost is not specified then default edge deletion
            cost of 1 is used.  If edge_ins_cost is not specified then
            default edge insertion cost of 1 is used.

        upper_bound : numeric
            Maximum edit distance to consider.

        Returns
        -------
        Generator of consecutive approximations of graph edit distance.

        Examples
        --------
        >>> G1 = nx.cycle_graph(6)
        >>> G2 = nx.wheel_graph(7)
        >>> for v in nx.optimize_graph_edit_distance(G1, G2):
        ...     minv = v
        >>> minv
        7.0

        See Also
        --------
        graph_edit_distance, optimize_edit_paths

        References
        ----------
        .. [1] Zeina Abu-Aisheh, Romain Raveaux, Jean-Yves Ramel, Patrick
           Martineau. An Exact Graph Edit Distance Algorithm for Solving
           Pattern Recognition Problems. 4th International Conference on
           Pattern Recognition Applications and Methods 2015, Jan 2015,
           Lisbon, Portugal. 2015,
           <10.5220/0005209202710278>. <hal-01168816>
           https://hal.archives-ouvertes.fr/hal-01168816
    
    """
2021-03-02 20:47:18,696 : INFO : tokenize_signature : --> do i ever get here?
2021-03-02 20:47:18,696 : INFO : tokenize_signature : --> do i ever get here?
2021-03-02 20:47:18,696 : INFO : tokenize_signature : --> do i ever get here?
2021-03-02 20:47:18,697 : INFO : tokenize_signature : --> do i ever get here?
2021-03-02 20:47:18,697 : INFO : tokenize_signature : --> do i ever get here?
2021-03-02 20:47:18,697 : INFO : tokenize_signature : --> do i ever get here?
2021-03-02 20:47:18,697 : INFO : tokenize_signature : --> do i ever get here?
2021-03-02 20:47:18,697 : INFO : tokenize_signature : --> do i ever get here?
2021-03-02 20:47:18,697 : INFO : tokenize_signature : --> do i ever get here?
2021-03-02 20:47:18,698 : INFO : tokenize_signature : --> do i ever get here?
2021-03-02 20:47:18,698 : INFO : tokenize_signature : --> do i ever get here?
2021-03-02 20:47:18,698 : INFO : tokenize_signature : --> do i ever get here?
2021-03-02 20:47:18,698 : INFO : tokenize_signature : --> do i ever get here?
2021-03-02 20:47:18,698 : INFO : tokenize_signature : --> do i ever get here?
2021-03-02 20:47:18,698 : INFO : tokenize_signature : --> do i ever get here?
def optimize_edit_paths(
    G1,
    G2,
    node_match=None,
    edge_match=None,
    node_subst_cost=None,
    node_del_cost=None,
    node_ins_cost=None,
    edge_subst_cost=None,
    edge_del_cost=None,
    edge_ins_cost=None,
    upper_bound=None,
    strictly_decreasing=True,
    roots=None,
    timeout=None,
):
    """
    GED (graph edit distance) calculation: advanced interface.

        Graph edit path is a sequence of node and edge edit operations
        transforming graph G1 to graph isomorphic to G2.  Edit operations
        include substitutions, deletions, and insertions.

        Graph edit distance is defined as minimum cost of edit path.

        Parameters
        ----------
        G1, G2: graphs
            The two graphs G1 and G2 must be of the same type.

        node_match : callable
            A function that returns True if node n1 in G1 and n2 in G2
            should be considered equal during matching.

            The function will be called like

               node_match(G1.nodes[n1], G2.nodes[n2]).

            That is, the function will receive the node attribute
            dictionaries for n1 and n2 as inputs.

            Ignored if node_subst_cost is specified.  If neither
            node_match nor node_subst_cost are specified then node
            attributes are not considered.

        edge_match : callable
            A function that returns True if the edge attribute dictionaries
            for the pair of nodes (u1, v1) in G1 and (u2, v2) in G2 should
            be considered equal during matching.

            The function will be called like

               edge_match(G1[u1][v1], G2[u2][v2]).

            That is, the function will receive the edge attribute
            dictionaries of the edges under consideration.

            Ignored if edge_subst_cost is specified.  If neither
            edge_match nor edge_subst_cost are specified then edge
            attributes are not considered.

        node_subst_cost, node_del_cost, node_ins_cost : callable
            Functions that return the costs of node substitution, node
            deletion, and node insertion, respectively.

            The functions will be called like

               node_subst_cost(G1.nodes[n1], G2.nodes[n2]),
               node_del_cost(G1.nodes[n1]),
               node_ins_cost(G2.nodes[n2]).

            That is, the functions will receive the node attribute
            dictionaries as inputs.  The functions are expected to return
            positive numeric values.

            Function node_subst_cost overrides node_match if specified.
            If neither node_match nor node_subst_cost are specified then
            default node substitution cost of 0 is used (node attributes
            are not considered during matching).

            If node_del_cost is not specified then default node deletion
            cost of 1 is used.  If node_ins_cost is not specified then
            default node insertion cost of 1 is used.

        edge_subst_cost, edge_del_cost, edge_ins_cost : callable
            Functions that return the costs of edge substitution, edge
            deletion, and edge insertion, respectively.

            The functions will be called like

               edge_subst_cost(G1[u1][v1], G2[u2][v2]),
               edge_del_cost(G1[u1][v1]),
               edge_ins_cost(G2[u2][v2]).

            That is, the functions will receive the edge attribute
            dictionaries as inputs.  The functions are expected to return
            positive numeric values.

            Function edge_subst_cost overrides edge_match if specified.
            If neither edge_match nor edge_subst_cost are specified then
            default edge substitution cost of 0 is used (edge attributes
            are not considered during matching).

            If edge_del_cost is not specified then default edge deletion
            cost of 1 is used.  If edge_ins_cost is not specified then
            default edge insertion cost of 1 is used.

        upper_bound : numeric
            Maximum edit distance to consider.

        strictly_decreasing : bool
            If True, return consecutive approximations of strictly
            decreasing cost.  Otherwise, return all edit paths of cost
            less than or equal to the previous minimum cost.

        roots : 2-tuple
            Tuple where first element is a node in G1 and the second
            is a node in G2.
            These nodes are forced to be matched in the comparison to
            allow comparison between rooted graphs.

        timeout : numeric
            Maximum number of seconds to execute.
            After timeout is met, the current best GED is returned.

        Returns
        -------
        Generator of tuples (node_edit_path, edge_edit_path, cost)
            node_edit_path : list of tuples (u, v)
            edge_edit_path : list of tuples ((u1, v1), (u2, v2))
            cost : numeric

        See Also
        --------
        graph_edit_distance, optimize_graph_edit_distance, optimal_edit_paths

        References
        ----------
        .. [1] Zeina Abu-Aisheh, Romain Raveaux, Jean-Yves Ramel, Patrick
           Martineau. An Exact Graph Edit Distance Algorithm for Solving
           Pattern Recognition Problems. 4th International Conference on
           Pattern Recognition Applications and Methods 2015, Jan 2015,
           Lisbon, Portugal. 2015,
           <10.5220/0005209202710278>. <hal-01168816>
           https://hal.archives-ouvertes.fr/hal-01168816

    
    """
    def CostMatrix:
    """
     assert C.shape[0] == len(lsa_row_ind)
     assert C.shape[1] == len(lsa_col_ind)
     assert len(lsa_row_ind) == len(lsa_col_ind)
     assert set(lsa_row_ind) == set(range(len(lsa_row_ind)))
     assert set(lsa_col_ind) == set(range(len(lsa_col_ind)))
     assert ls == C[lsa_row_ind, lsa_col_ind].sum()

    """
    def make_CostMatrix(C, m, n):
        """
         assert(C.shape == (m + n, m + n))

        """
    def extract_C(C, i, j, m, n):
        """
         assert(C.shape == (m + n, m + n))

        """
    def reduce_C(C, i, j, m, n):
        """
         assert(C.shape == (m + n, m + n))

        """
    def reduce_ind(ind, i):
        """
         assert set(ind) == set(range(len(ind)))

        """
    def match_edges(u, v, pending_g, pending_h, Ce, matched_uv=[]):
        """

                Parameters:
                    u, v: matched vertices, u=None or v=None for
                       deletion/insertion
                    pending_g, pending_h: lists of edges not yet mapped
                    Ce: CostMatrix of pending edge mappings
                    matched_uv: partial vertex edit path
                        list of tuples (u, v) of previously matched vertex
                            mappings u<->v, u=None or v=None for
                            deletion/insertion

                Returns:
                    list of (i, j): indices of edge mappings g<->h
                    localCe: local CostMatrix of edge mappings
                        (basically submatrix of Ce at cross of rows i, cols j)
        
        """
    def reduce_Ce(Ce, ij, m, n):
        """

                Parameters:
                    matched_uv: partial vertex edit path
                        list of tuples (u, v) of vertex mappings u<->v,
                        u=None or v=None for deletion/insertion
                    pending_u, pending_v: lists of vertices not yet mapped
                    Cv: CostMatrix of pending vertex mappings
                    pending_g, pending_h: lists of edges not yet mapped
                    Ce: CostMatrix of pending edge mappings
                    matched_cost: cost of partial edit path

                Returns:
                    sequence of
                        (i, j): indices of vertex mapping u<->v
                        Cv_ij: reduced CostMatrix of pending vertex mappings
                            (basically Cv with row i, col j removed)
                        list of (x, y): indices of edge mappings g<->h
                        Ce_xy: reduced CostMatrix of pending edge mappings
                            (basically Ce with rows x, cols y removed)
                        cost: total cost of edit operation
                    NOTE: most promising ops first
        
        """
2021-03-02 20:47:18,708 : INFO : tokenize_signature : --> do i ever get here?
2021-03-02 20:47:18,708 : INFO : tokenize_signature : --> do i ever get here?
2021-03-02 20:47:18,708 : INFO : tokenize_signature : --> do i ever get here?
2021-03-02 20:47:18,708 : INFO : tokenize_signature : --> do i ever get here?
2021-03-02 20:47:18,708 : INFO : tokenize_signature : --> do i ever get here?
2021-03-02 20:47:18,708 : INFO : tokenize_signature : --> do i ever get here?
2021-03-02 20:47:18,708 : INFO : tokenize_signature : --> do i ever get here?
2021-03-02 20:47:18,708 : INFO : tokenize_signature : --> do i ever get here?
2021-03-02 20:47:18,708 : INFO : tokenize_signature : --> do i ever get here?
2021-03-02 20:47:18,708 : INFO : tokenize_signature : --> do i ever get here?
    def get_edit_paths(
        matched_uv,
        pending_u,
        pending_v,
        Cv,
        matched_gh,
        pending_g,
        pending_h,
        Ce,
        matched_cost,
    ):
        """

                Parameters:
                    matched_uv: partial vertex edit path
                        list of tuples (u, v) of vertex mappings u<->v,
                        u=None or v=None for deletion/insertion
                    pending_u, pending_v: lists of vertices not yet mapped
                    Cv: CostMatrix of pending vertex mappings
                    matched_gh: partial edge edit path
                        list of tuples (g, h) of edge mappings g<->h,
                        g=None or h=None for deletion/insertion
                    pending_g, pending_h: lists of edges not yet mapped
                    Ce: CostMatrix of pending edge mappings
                    matched_cost: cost of partial edit path

                Returns:
                    sequence of (vertex_path, edge_path, cost)
                        vertex_path: complete vertex edit path
                            list of tuples (u, v) of vertex mappings u<->v,
                            u=None or v=None for deletion/insertion
                        edge_path: complete edge edit path
                            list of tuples (g, h) of edge mappings g<->h,
                            g=None or h=None for deletion/insertion
                        cost: total cost of edit path
                    NOTE: path costs are non-increasing
        
        """
    def MaxCost:
    """
     initial upper-bound estimate
     NOTE: should work for empty graph

    """
    def prune(cost):
        """
         Now go!


        """
def _is_close(d1, d2, atolerance=0, rtolerance=0):
    """
    Determines whether two adjacency matrices are within
        a provided tolerance.

        Parameters
        ----------
        d1 : dict
            Adjacency dictionary

        d2 : dict
            Adjacency dictionary

        atolerance : float
            Some scalar tolerance value to determine closeness

        rtolerance : float
            A scalar tolerance value that will be some proportion
            of ``d2``'s value

        Returns
        -------
        closeness : bool
            If all of the nodes within ``d1`` and ``d2`` are within
            a predefined tolerance, they are considered "close" and
            this method will return True. Otherwise, this method will
            return False.

    
    """
2021-03-02 20:47:18,715 : INFO : tokenize_signature : --> do i ever get here?
2021-03-02 20:47:18,715 : INFO : tokenize_signature : --> do i ever get here?
2021-03-02 20:47:18,715 : INFO : tokenize_signature : --> do i ever get here?
2021-03-02 20:47:18,715 : INFO : tokenize_signature : --> do i ever get here?
2021-03-02 20:47:18,715 : INFO : tokenize_signature : --> do i ever get here?
2021-03-02 20:47:18,715 : INFO : tokenize_signature : --> do i ever get here?
2021-03-02 20:47:18,715 : INFO : tokenize_signature : --> do i ever get here?
def simrank_similarity(
    G,
    source=None,
    target=None,
    importance_factor=0.9,
    max_iterations=100,
    tolerance=1e-4,
):
    """
    Returns the SimRank similarity of nodes in the graph ``G``.

        SimRank is a similarity metric that says "two objects are considered
        to be similar if they are referenced by similar objects." [1]_.

        The pseudo-code definition from the paper is::

            def simrank(G, u, v):
                in_neighbors_u = G.predecessors(u)
                in_neighbors_v = G.predecessors(v)
                scale = C / (len(in_neighbors_u) * len(in_neighbors_v))
                return scale * sum(simrank(G, w, x)
                                   for w, x in product(in_neighbors_u,
                                                       in_neighbors_v))

        where ``G`` is the graph, ``u`` is the source, ``v`` is the target,
        and ``C`` is a float decay or importance factor between 0 and 1.

        The SimRank algorithm for determining node similarity is defined in
        [2]_.

        Parameters
        ----------
        G : NetworkX graph
            A NetworkX graph

        source : node
            If this is specified, the returned dictionary maps each node
            ``v`` in the graph to the similarity between ``source`` and
            ``v``.

        target : node
            If both ``source`` and ``target`` are specified, the similarity
            value between ``source`` and ``target`` is returned. If
            ``target`` is specified but ``source`` is not, this argument is
            ignored.

        importance_factor : float
            The relative importance of indirect neighbors with respect to
            direct neighbors.

        max_iterations : integer
            Maximum number of iterations.

        tolerance : float
            Error tolerance used to check convergence. When an iteration of
            the algorithm finds that no similarity value changes more than
            this amount, the algorithm halts.

        Returns
        -------
        similarity : dictionary or float
            If ``source`` and ``target`` are both ``None``, this returns a
            dictionary of dictionaries, where keys are node pairs and value
            are similarity of the pair of nodes.

            If ``source`` is not ``None`` but ``target`` is, this returns a
            dictionary mapping node to the similarity of ``source`` and that
            node.

            If neither ``source`` nor ``target`` is ``None``, this returns
            the similarity value for the given pair of nodes.

        Examples
        --------
        If the nodes of the graph are numbered from zero to *n - 1*, where *n*
        is the number of nodes in the graph, you can create a SimRank matrix
        from the return value of this function where the node numbers are
        the row and column indices of the matrix::

            >>> from numpy import array
            >>> G = nx.cycle_graph(4)
            >>> sim = nx.simrank_similarity(G)
            >>> lol = [[sim[u][v] for v in sorted(sim[u])] for u in sorted(sim)]
            >>> sim_array = array(lol)

        References
        ----------
        .. [1] https://en.wikipedia.org/wiki/SimRank
        .. [2] G. Jeh and J. Widom.
               "SimRank: a measure of structural-context similarity",
               In KDD'02: Proceedings of the Eighth ACM SIGKDD
               International Conference on Knowledge Discovery and Data Mining,
               pp. 538--543. ACM Press, 2002.
    
    """
    def avg_sim(s):
        """
        Calculate SimRank of nodes in ``G`` using matrices with ``numpy``.

            The SimRank algorithm for determining node similarity is defined in
            [1]_.

            Parameters
            ----------
            G : NetworkX graph
                A NetworkX graph

            source : node
                If this is specified, the returned dictionary maps each node
                ``v`` in the graph to the similarity between ``source`` and
                ``v``.

            target : node
                If both ``source`` and ``target`` are specified, the similarity
                value between ``source`` and ``target`` is returned. If
                ``target`` is specified but ``source`` is not, this argument is
                ignored.

            importance_factor : float
                The relative importance of indirect neighbors with respect to
                direct neighbors.

            max_iterations : integer
                Maximum number of iterations.

            tolerance : float
                Error tolerance used to check convergence. When an iteration of
                the algorithm finds that no similarity value changes more than
                this amount, the algorithm halts.

            Returns
            -------
            similarity : numpy matrix, numpy array or float
                If ``source`` and ``target`` are both ``None``, this returns a
                Matrix containing SimRank scores of the nodes.

                If ``source`` is not ``None`` but ``target`` is, this returns an
                Array containing SimRank scores of ``source`` and that
                node.

                If neither ``source`` nor ``target`` is ``None``, this returns
                the similarity value for the given pair of nodes.

            Examples
            --------
                >>> from numpy import array
                >>> G = nx.cycle_graph(4)
                >>> sim = nx.simrank_similarity_numpy(G)

            References
            ----------
            .. [1] G. Jeh and J. Widom.
                   "SimRank: a measure of structural-context similarity",
                   In KDD'02: Proceedings of the Eighth ACM SIGKDD
                   International Conference on Knowledge Discovery and Data Mining,
                   pp. 538--543. ACM Press, 2002.
    
        """
