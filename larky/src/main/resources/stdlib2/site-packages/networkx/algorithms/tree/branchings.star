def random_string(L=15, seed=None):
    """

    """
def _min_weight(weight):
    """
    weight
    """
def greedy_branching(G, attr="weight", default=1, kind="max", seed=None):
    """

        Returns a branching obtained through a greedy algorithm.

        This algorithm is wrong, and cannot give a proper optimal branching.
        However, we include it for pedagogical reasons, as it can be helpful to
        see what its outputs are.

        The output is a branching, and possibly, a spanning arborescence. However,
        it is not guaranteed to be optimal in either case.

        Parameters
        ----------
        G : DiGraph
            The directed graph to scan.
        attr : str
            The attribute to use as weights. If None, then each edge will be
            treated equally with a weight of 1.
        default : float
            When `attr` is not None, then if an edge does not have that attribute,
            `default` specifies what value it should take.
        kind : str
            The type of optimum to search for: 'min' or 'max' greedy branching.
        seed : integer, random_state, or None (default)
            Indicator of random number generation state.
            See :ref:`Randomness<randomness>`.

        Returns
        -------
        B : directed graph
            The greedily obtained branching.

    
    """
def MultiDiGraph_EdgeKey(nx.MultiDiGraph):
    """

        MultiDiGraph which assigns unique keys to every edge.

        Adds a dictionary edge_index which maps edge keys to (u, v, data) tuples.

        This is not a complete implementation. For Edmonds algorithm, we only use
        add_node and add_edge, so that is all that is implemented here. During
        additions, any specified keys are ignored---this means that you also
        cannot update edge attributes through add_node and add_edge.

        Why do we need this? Edmonds algorithm requires that we track edges, even
        as we change the head and tail of an edge, and even changing the weight
        of edges. We must reliably track edges across graph mutations.

    
    """
    def __init__(self, incoming_graph_data=None, **attr):
        """

                Key is now required.

        
        """
    def add_edges_from(self, ebunch_to_add, **attr):
        """
        f"Invalid edge key {key!r}
        """
    def remove_edges_from(self, ebunch):
        """

            Returns the edge keys of the unique path between u and v.

            This is not a generic function. G must be a branching and an instance of
            MultiDiGraph_EdgeKey.

    
        """
    def first_key(i, vv):
        """
         Needed for 2.x/3.x compatibilitity

        """
def Edmonds:
    """

        Edmonds algorithm for finding optimal branchings and spanning arborescences.

    
    """
    def __init__(self, G, seed=None):
        """
         Need to fix this. We need the whole tree.

        """
    def _init(self, attr, default, kind, style, preserve_attrs, seed):
        """
        Unknown value for `kind`.
        """
2021-03-02 20:47:13,442 : INFO : tokenize_signature : --> do i ever get here?
2021-03-02 20:47:13,442 : INFO : tokenize_signature : --> do i ever get here?
2021-03-02 20:47:13,442 : INFO : tokenize_signature : --> do i ever get here?
2021-03-02 20:47:13,442 : INFO : tokenize_signature : --> do i ever get here?
2021-03-02 20:47:13,442 : INFO : tokenize_signature : --> do i ever get here?
2021-03-02 20:47:13,443 : INFO : tokenize_signature : --> do i ever get here?
2021-03-02 20:47:13,443 : INFO : tokenize_signature : --> do i ever get here?
2021-03-02 20:47:13,443 : INFO : tokenize_signature : --> do i ever get here?
    def find_optimum(
        self,
        attr="weight",
        default=1,
        kind="max",
        style="branching",
        preserve_attrs=False,
        seed=None,
    ):
        """

                Returns a branching from G.

                Parameters
                ----------
                attr : str
                    The edge attribute used to in determining optimality.
                default : float
                    The value of the edge attribute used if an edge does not have
                    the attribute `attr`.
                kind : {'min', 'max'}
                    The type of optimum to search for, either 'min' or 'max'.
                style : {'branching', 'arborescence'}
                    If 'branching', then an optimal branching is found. If `style` is
                    'arborescence', then a branching is found, such that if the
                    branching is also an arborescence, then the branching is an
                    optimal spanning arborescences. A given graph G need not have
                    an optimal spanning arborescence.
                preserve_attrs : bool
                    If True, preserve the other edge attributes of the original
                    graph (that are not the one passed to `attr`)
                seed : integer, random_state, or None (default)
                    Indicator of random number generation state.
                    See :ref:`Randomness<randomness>`.

                Returns
                -------
                H : (multi)digraph
                    The branching.

        
        """
        def desired_edge(v):
            """

                        Find the edge directed toward v with maximal weight.

            
            """
        def is_root(G, u, edgekeys):
            """

                        Returns True if `u` is a root node in G.

                        Node `u` will be a root node if its in-degree, restricted to the
                        specified edges, is equal to 0.

            
            """
def maximum_branching(G, attr="weight", default=1, preserve_attrs=False):
    """
    max
    """
def minimum_branching(G, attr="weight", default=1, preserve_attrs=False):
    """
    min
    """
def maximum_spanning_arborescence(G, attr="weight", default=1, preserve_attrs=False):
    """
    max
    """
def minimum_spanning_arborescence(G, attr="weight", default=1, preserve_attrs=False):
    """
    min
    """
