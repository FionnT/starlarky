def index_satisfying(iterable, condition):
    """
    Returns the index of the first element in `iterable` that
        satisfies the given condition.

        If no such element is found (that is, when the iterable is
        exhausted), this returns the length of the iterable (that is, one
        greater than the last index of the iterable).

        `iterable` must not be empty. If `iterable` is empty, this
        function raises :exc:`ValueError`.

    
    """
def is_tournament(G):
    """
    Returns True if and only if `G` is a tournament.

        A tournament is a directed graph, with neither self-loops nor
        multi-edges, in which there is exactly one directed edge joining
        each pair of distinct nodes.

        Parameters
        ----------
        G : NetworkX graph
            A directed graph representing a tournament.

        Returns
        -------
        bool
            Whether the given graph is a tournament graph.

        Notes
        -----
        Some definitions require a self-loop on each node, but that is not
        the convention used here.

    
    """
def hamiltonian_path(G):
    """
    Returns a Hamiltonian path in the given tournament graph.

        Each tournament has a Hamiltonian path. If furthermore, the
        tournament is strongly connected, then the returned Hamiltonian path
        is a Hamiltonian cycle (by joining the endpoints of the path).

        Parameters
        ----------
        G : NetworkX graph
            A directed graph representing a tournament.

        Returns
        -------
        bool
            Whether the given graph is a tournament graph.

        Notes
        -----
        This is a recursive implementation with an asymptotic running time
        of $O(n^2)$, ignoring multiplicative polylogarithmic factors, where
        $n$ is the number of nodes in the graph.

    
    """
def random_tournament(n, seed=None):
    """
    r"""Returns a random tournament graph on `n` nodes.

        Parameters
        ----------
        n : int
            The number of nodes in the returned graph.
        seed : integer, random_state, or None (default)
            Indicator of random number generation state.
            See :ref:`Randomness<randomness>`.

        Returns
        -------
        bool
            Whether the given graph is a tournament graph.

        Notes
        -----
        This algorithm adds, for each pair of distinct nodes, an edge with
        uniformly random orientation. In other words, `\binom{n}{2}` flips
        of an unbiased coin decide the orientations of the edges in the
        graph.

    
    """
def score_sequence(G):
    """
    Returns the score sequence for the given tournament graph.

        The score sequence is the sorted list of the out-degrees of the
        nodes of the graph.

        Parameters
        ----------
        G : NetworkX graph
            A directed graph representing a tournament.

        Returns
        -------
        list
            A sorted list of the out-degrees of the nodes of `G`.

    
    """
def tournament_matrix(G):
    """
    r"""Returns the tournament matrix for the given tournament graph.

        This function requires SciPy.

        The *tournament matrix* of a tournament graph with edge set *E* is
        the matrix *T* defined by

        .. math::

           T_{i j} =
           \begin{cases}
           +1 & \text{if } (i, j) \in E \\
           -1 & \text{if } (j, i) \in E \\
           0 & \text{if } i == j.
           \end{cases}

        An equivalent definition is `T = A - A^T`, where *A* is the
        adjacency matrix of the graph `G`.

        Parameters
        ----------
        G : NetworkX graph
            A directed graph representing a tournament.

        Returns
        -------
        SciPy sparse matrix
            The tournament matrix of the tournament graph `G`.

        Raises
        ------
        ImportError
            If SciPy is not available.

    
    """
def is_reachable(G, s, t):
    """
    Decides whether there is a path from `s` to `t` in the
        tournament.

        This function is more theoretically efficient than the reachability
        checks than the shortest path algorithms in
        :mod:`networkx.algorithms.shortest_paths`.

        The given graph **must** be a tournament, otherwise this function's
        behavior is undefined.

        Parameters
        ----------
        G : NetworkX graph
            A directed graph representing a tournament.

        s : node
            A node in the graph.

        t : node
            A node in the graph.

        Returns
        -------
        bool
            Whether there is a path from `s` to `t` in `G`.

        Notes
        -----
        Although this function is more theoretically efficient than the
        generic shortest path functions, a speedup requires the use of
        parallelism. Though it may in the future, the current implementation
        does not use parallelism, thus you may not see much of a speedup.

        This algorithm comes from [1].

        References
        ----------
        .. [1] Tantau, Till.
               "A note on the complexity of the reachability problem for
               tournaments."
               *Electronic Colloquium on Computational Complexity*. 2001.
               <http://eccc.hpi-web.de/report/2001/092/>

    
    """
    def two_neighborhood(G, v):
        """
        Returns the set of nodes at distance at most two from `v`.

                `G` must be a graph and `v` a node in that graph.

                The returned set includes the nodes at distance zero (that is,
                the node `v` itself), the nodes at distance one (that is, the
                out-neighbors of `v`), and the nodes at distance two.

        
        """
    def is_closed(G, nodes):
        """
        Decides whether the given set of nodes is closed.

                A set *S* of nodes is *closed* if for each node *u* in the graph
                not in *S* and for each node *v* in *S*, there is an edge from
                *u* to *v*.

        
        """
def is_strongly_connected(G):
    """
    Decides whether the given tournament is strongly connected.

        This function is more theoretically efficient than the
        :func:`~networkx.algorithms.components.is_strongly_connected`
        function.

        The given graph **must** be a tournament, otherwise this function's
        behavior is undefined.

        Parameters
        ----------
        G : NetworkX graph
            A directed graph representing a tournament.

        Returns
        -------
        bool
            Whether the tournament is strongly connected.

        Notes
        -----
        Although this function is more theoretically efficient than the
        generic strong connectivity function, a speedup requires the use of
        parallelism. Though it may in the future, the current implementation
        does not use parallelism, thus you may not see much of a speedup.

        This algorithm comes from [1].

        References
        ----------
        .. [1] Tantau, Till.
               "A note on the complexity of the reachability problem for
               tournaments."
               *Electronic Colloquium on Computational Complexity*. 2001.
               <http://eccc.hpi-web.de/report/2001/092/>

    
    """
