def check_planarity(G, counterexample=False):
    """
    Check if a graph is planar and return a counterexample or an embedding.

        A graph is planar iff it can be drawn in a plane without
        any edge intersections.

        Parameters
        ----------
        G : NetworkX graph
        counterexample : bool
            A Kuratowski subgraph (to proof non planarity) is only returned if set
            to true.

        Returns
        -------
        (is_planar, certificate) : (bool, NetworkX graph) tuple
            is_planar is true if the graph is planar.
            If the graph is planar `certificate` is a PlanarEmbedding
            otherwise it is a Kuratowski subgraph.

        Notes
        -----
        A (combinatorial) embedding consists of cyclic orderings of the incident
        edges at each vertex. Given such an embedding there are multiple approaches
        discussed in literature to drawing the graph (subject to various
        constraints, e.g. integer coordinates), see e.g. [2].

        The planarity check algorithm and extraction of the combinatorial embedding
        is based on the Left-Right Planarity Test [1].

        A counterexample is only generated if the corresponding parameter is set,
        because the complexity of the counterexample generation is higher.

        References
        ----------
        .. [1] Ulrik Brandes:
            The Left-Right Planarity Test
            2009
            http://citeseerx.ist.psu.edu/viewdoc/summary?doi=10.1.1.217.9208
        .. [2] Takao Nishizeki, Md Saidur Rahman:
            Planar graph drawing
            Lecture Notes Series on Computing: Volume 12
            2004
    
    """
def check_planarity_recursive(G, counterexample=False):
    """
    Recursive version of :meth:`check_planarity`.
    """
def get_counterexample(G):
    """
    Obtains a Kuratowski subgraph.

        Raises nx.NetworkXException if G is planar.

        The function removes edges such that the graph is still not planar.
        At some point the removal of any edge would make the graph planar.
        This subgraph must be a Kuratowski subgraph.

        Parameters
        ----------
        G : NetworkX graph

        Returns
        -------
        subgraph : NetworkX graph
            A Kuratowski subgraph that proves that G is not planar.

    
    """
def get_counterexample_recursive(G):
    """
    Recursive version of :meth:`get_counterexample`.
    
    """
def Interval:
    """
    Represents a set of return edges.

        All return edges in an interval induce a same constraint on the contained
        edges, which means that all edges must either have a left orientation or
        all edges must have a right orientation.
    
    """
    def __init__(self, low=None, high=None):
        """
        Check if the interval is empty
        """
    def copy(self):
        """
        Returns a copy of this interval
        """
    def conflicting(self, b, planarity_state):
        """
        Returns True if interval I conflicts with edge b
        """
def ConflictPair:
    """
    Represents a different constraint between two intervals.

        The edges in the left interval must have a different orientation than
        the one in the right interval.
    
    """
    def __init__(self, left=Interval(), right=Interval()):
        """
        Swap left and right intervals
        """
    def lowest(self, planarity_state):
        """
        Returns the lowest lowpoint of a conflict pair
        """
def top_of_stack(l):
    """
    Returns the element on top of the stack.
    """
def LRPlanarity:
    """
    A class to maintain the state during planarity check.
    """
    def __init__(self, G):
        """
         copy G without adding self-loops

        """
    def lr_planarity(self):
        """
        Execute the LR planarity test.

                Returns
                -------
                embedding : dict
                    If the graph is planar an embedding is returned. Otherwise None.
        
        """
    def lr_planarity_recursive(self):
        """
        Recursive version of :meth:`lr_planarity`.
        """
    def dfs_orientation(self, v):
        """
        Orient the graph by DFS, compute lowpoints and nesting order.
        
        """
    def dfs_orientation_recursive(self, v):
        """
        Recursive version of :meth:`dfs_orientation`.
        """
    def dfs_testing(self, v):
        """
        Test for LR partition.
        """
    def dfs_testing_recursive(self, v):
        """
        Recursive version of :meth:`dfs_testing`.
        """
    def add_constraints(self, ei, e):
        """
         merge return edges of e_i into P.right

        """
    def remove_back_edges(self, e):
        """
         trim back edges ending at parent u
         drop entire conflict pairs

        """
    def dfs_embedding(self, v):
        """
        Completes the embedding.
        """
    def dfs_embedding_recursive(self, v):
        """
        Recursive version of :meth:`dfs_embedding`.
        """
    def sign(self, e):
        """
        Resolve the relative side of an edge to the absolute side.
        """
    def sign_recursive(self, e):
        """
        Recursive version of :meth:`sign`.
        """
def PlanarEmbedding(nx.DiGraph):
    """
    Represents a planar graph with its planar embedding.

        The planar embedding is given by a `combinatorial embedding
        <https://en.wikipedia.org/wiki/Graph_embedding#Combinatorial_embedding>`_.

        **Neighbor ordering:**

        In comparison to a usual graph structure, the embedding also stores the
        order of all neighbors for every vertex.
        The order of the neighbors can be given in clockwise (cw) direction or
        counterclockwise (ccw) direction. This order is stored as edge attributes
        in the underlying directed graph. For the edge (u, v) the edge attribute
        'cw' is set to the neighbor of u that follows immediately after v in
        clockwise direction.

        In order for a PlanarEmbedding to be valid it must fulfill multiple
        conditions. It is possible to check if these conditions are fulfilled with
        the method :meth:`check_structure`.
        The conditions are:

        * Edges must go in both directions (because the edge attributes differ)
        * Every edge must have a 'cw' and 'ccw' attribute which corresponds to a
          correct planar embedding.
        * A node with non zero degree must have a node attribute 'first_nbr'.

        As long as a PlanarEmbedding is invalid only the following methods should
        be called:

        * :meth:`add_half_edge_ccw`
        * :meth:`add_half_edge_cw`
        * :meth:`connect_components`
        * :meth:`add_half_edge_first`

        Even though the graph is a subclass of nx.DiGraph, it can still be used
        for algorithms that require undirected graphs, because the method
        :meth:`is_directed` is overridden. This is possible, because a valid
        PlanarGraph must have edges in both directions.

        **Half edges:**

        In methods like `add_half_edge_ccw` the term "half-edge" is used, which is
        a term that is used in `doubly connected edge lists
        <https://en.wikipedia.org/wiki/Doubly_connected_edge_list>`_. It is used
        to emphasize that the edge is only in one direction and there exists
        another half-edge in the opposite direction.
        While conventional edges always have two faces (including outer face) next
        to them, it is possible to assign each half-edge *exactly one* face.
        For a half-edge (u, v) that is orientated such that u is below v then the
        face that belongs to (u, v) is to the right of this half-edge.

        Examples
        --------

        Create an embedding of a star graph (compare `nx.star_graph(3)`):

        >>> G = nx.PlanarEmbedding()
        >>> G.add_half_edge_cw(0, 1, None)
        >>> G.add_half_edge_cw(0, 2, 1)
        >>> G.add_half_edge_cw(0, 3, 2)
        >>> G.add_half_edge_cw(1, 0, None)
        >>> G.add_half_edge_cw(2, 0, None)
        >>> G.add_half_edge_cw(3, 0, None)

        Alternatively the same embedding can also be defined in counterclockwise
        orientation. The following results in exactly the same PlanarEmbedding:

        >>> G = nx.PlanarEmbedding()
        >>> G.add_half_edge_ccw(0, 1, None)
        >>> G.add_half_edge_ccw(0, 3, 1)
        >>> G.add_half_edge_ccw(0, 2, 3)
        >>> G.add_half_edge_ccw(1, 0, None)
        >>> G.add_half_edge_ccw(2, 0, None)
        >>> G.add_half_edge_ccw(3, 0, None)

        After creating a graph, it is possible to validate that the PlanarEmbedding
        object is correct:

        >>> G.check_structure()

    
    """
    def get_data(self):
        """
        Converts the adjacency structure into a better readable structure.

                Returns
                -------
                embedding : dict
                    A dict mapping all nodes to a list of neighbors sorted in
                    clockwise order.

                See Also
                --------
                set_data

        
        """
    def set_data(self, data):
        """
        Inserts edges according to given sorted neighbor list.

                The input format is the same as the output format of get_data().

                Parameters
                ----------
                data : dict
                    A dict mapping all nodes to a list of neighbors sorted in
                    clockwise order.

                See Also
                --------
                get_data

        
        """
    def neighbors_cw_order(self, v):
        """
        Generator for the neighbors of v in clockwise order.

                Parameters
                ----------
                v : node

                Yields
                ------
                node

        
        """
    def check_structure(self):
        """
        Runs without exceptions if this object is valid.

                Checks that the following properties are fulfilled:

                * Edges go in both directions (because the edge attributes differ).
                * Every edge has a 'cw' and 'ccw' attribute which corresponds to a
                  correct planar embedding.
                * A node with a degree larger than 0 has a node attribute 'first_nbr'.

                Running this method verifies that the underlying Graph must be planar.

                Raises
                ------
                NetworkXException
                    This exception is raised with a short explanation if the
                    PlanarEmbedding is invalid.
        
        """
    def add_half_edge_ccw(self, start_node, end_node, reference_neighbor):
        """
        Adds a half-edge from start_node to end_node.

                The half-edge is added counter clockwise next to the existing half-edge
                (start_node, reference_neighbor).

                Parameters
                ----------
                start_node : node
                    Start node of inserted edge.
                end_node : node
                    End node of inserted edge.
                reference_neighbor: node
                    End node of reference edge.

                Raises
                ------
                NetworkXException
                    If the reference_neighbor does not exist.

                See Also
                --------
                add_half_edge_cw
                connect_components
                add_half_edge_first

        
        """
    def add_half_edge_cw(self, start_node, end_node, reference_neighbor):
        """
        Adds a half-edge from start_node to end_node.

                The half-edge is added clockwise next to the existing half-edge
                (start_node, reference_neighbor).

                Parameters
                ----------
                start_node : node
                    Start node of inserted edge.
                end_node : node
                    End node of inserted edge.
                reference_neighbor: node
                    End node of reference edge.

                Raises
                ------
                NetworkXException
                    If the reference_neighbor does not exist.

                See Also
                --------
                add_half_edge_ccw
                connect_components
                add_half_edge_first
        
        """
    def connect_components(self, v, w):
        """
        Adds half-edges for (v, w) and (w, v) at some position.

                This method should only be called if v and w are in different
                components, or it might break the embedding.
                This especially means that if `connect_components(v, w)`
                is called it is not allowed to call `connect_components(w, v)`
                afterwards. The neighbor orientations in both directions are
                all set correctly after the first call.

                Parameters
                ----------
                v : node
                w : node

                See Also
                --------
                add_half_edge_ccw
                add_half_edge_cw
                add_half_edge_first
        
        """
    def add_half_edge_first(self, start_node, end_node):
        """
        The added half-edge is inserted at the first position in the order.

                Parameters
                ----------
                start_node : node
                end_node : node

                See Also
                --------
                add_half_edge_ccw
                add_half_edge_cw
                connect_components
        
        """
    def next_face_half_edge(self, v, w):
        """
        Returns the following half-edge left of a face.

                Parameters
                ----------
                v : node
                w : node

                Returns
                -------
                half-edge : tuple
        
        """
    def traverse_face(self, v, w, mark_half_edges=None):
        """
        Returns nodes on the face that belong to the half-edge (v, w).

                The face that is traversed lies to the right of the half-edge (in an
                orientation where v is below w).

                Optionally it is possible to pass a set to which all encountered half
                edges are added. Before calling this method, this set must not include
                any half-edges that belong to the face.

                Parameters
                ----------
                v : node
                    Start node of half-edge.
                w : node
                    End node of half-edge.
                mark_half_edges: set, optional
                    Set to which all encountered half-edges are added.

                Returns
                -------
                face : list
                    A list of nodes that lie on this face.
        
        """
    def is_directed(self):
        """
        A valid PlanarEmbedding is undirected.

                All reverse edges are contained, i.e. for every existing
                half-edge (v, w) the half-edge in the opposite direction (w, v) is also
                contained.
        
        """
