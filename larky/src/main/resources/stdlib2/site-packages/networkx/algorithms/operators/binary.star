def union(G, H, rename=(None, None), name=None):
    """
     Return the union of graphs G and H.

        Graphs G and H must be disjoint, otherwise an exception is raised.

        Parameters
        ----------
        G,H : graph
           A NetworkX graph

        rename : bool , default=(None, None)
           Node names of G and H can be changed by specifying the tuple
           rename=('G-','H-') (for example).  Node "u" in G is then renamed
           "G-u" and "v" in H is renamed "H-v".

        name : string
           Specify the name for the union graph

        Returns
        -------
        U : A union graph with the same type as G.

        Notes
        -----
        To force a disjoint union with node relabeling, use
        disjoint_union(G,H) or convert_node_labels_to integers().

        Graph, edge, and node attributes are propagated from G and H
        to the union graph.  If a graph attribute is present in both
        G and H the value from H is used.

        See Also
        --------
        disjoint_union
    
    """
    def add_prefix(graph, prefix):
        """
        The node sets of G and H are not disjoint.
        """
def disjoint_union(G, H):
    """
     Return the disjoint union of graphs G and H.

        This algorithm forces distinct integer node labels.

        Parameters
        ----------
        G,H : graph
           A NetworkX graph

        Returns
        -------
        U : A union graph with the same type as G.

        Notes
        -----
        A new graph is created, of the same class as G.  It is recommended
        that G and H be either both directed or both undirected.

        The nodes of G are relabeled 0 to len(G)-1, and the nodes of H are
        relabeled len(G) to len(G)+len(H)-1.

        Graph, edge, and node attributes are propagated from G and H
        to the union graph.  If a graph attribute is present in both
        G and H the value from H is used.
    
    """
def intersection(G, H):
    """
    Returns a new graph that contains only the edges that exist in
        both G and H.

        The node sets of H and G must be the same.

        Parameters
        ----------
        G,H : graph
           A NetworkX graph.  G and H must have the same node sets.

        Returns
        -------
        GH : A new graph with the same type as G.

        Notes
        -----
        Attributes from the graph, nodes, and edges are not copied to the new
        graph.  If you want a new graph of the intersection of G and H
        with the attributes (including edge data) from G use remove_nodes_from()
        as follows

        >>> G = nx.path_graph(3)
        >>> H = nx.path_graph(5)
        >>> R = G.copy()
        >>> R.remove_nodes_from(n for n in G if n not in H)
    
    """
def difference(G, H):
    """
    Returns a new graph that contains the edges that exist in G but not in H.

        The node sets of H and G must be the same.

        Parameters
        ----------
        G,H : graph
           A NetworkX graph.  G and H must have the same node sets.

        Returns
        -------
        D : A new graph with the same type as G.

        Notes
        -----
        Attributes from the graph, nodes, and edges are not copied to the new
        graph.  If you want a new graph of the difference of G and H with
        with the attributes (including edge data) from G use remove_nodes_from()
        as follows:

        >>> G = nx.path_graph(3)
        >>> H = nx.path_graph(5)
        >>> R = G.copy()
        >>> R.remove_nodes_from(n for n in G if n in H)
    
    """
def symmetric_difference(G, H):
    """
    Returns new graph with edges that exist in either G or H but not both.

        The node sets of H and G must be the same.

        Parameters
        ----------
        G,H : graph
           A NetworkX graph.  G and H must have the same node sets.

        Returns
        -------
        D : A new graph with the same type as G.

        Notes
        -----
        Attributes from the graph, nodes, and edges are not copied to the new
        graph.
    
    """
def compose(G, H):
    """
    Returns a new graph of G composed with H.

        Composition is the simple union of the node sets and edge sets.
        The node sets of G and H do not need to be disjoint.

        Parameters
        ----------
        G, H : graph
           A NetworkX graph

        Returns
        -------
        C: A new graph  with the same type as G

        Notes
        -----
        It is recommended that G and H be either both directed or both undirected.
        Attributes from H take precedent over attributes from G.

        For MultiGraphs, the edges are identified by incident nodes AND edge-key.
        This can cause surprises (i.e., edge `(1, 2)` may or may not be the same
        in two graphs) if you use MultiGraph without keeping track of edge keys.
    
    """
def full_join(G, H, rename=(None, None)):
    """
    Returns the full join of graphs G and H.

        Full join is the union of G and H in which all edges between
        G and H are added.
        The node sets of G and H must be disjoint,
        otherwise an exception is raised.

        Parameters
        ----------
        G, H : graph
           A NetworkX graph

        rename : bool , default=(None, None)
           Node names of G and H can be changed by specifying the tuple
           rename=('G-','H-') (for example).  Node "u" in G is then renamed
           "G-u" and "v" in H is renamed "H-v".

        Returns
        -------
        U : The full join graph with the same type as G.

        Notes
        -----
        It is recommended that G and H be either both directed or both undirected.

        If G is directed, then edges from G to H are added as well as from H to G.

        Note that full_join() does not produce parallel edges for MultiGraphs.

        The full join operation of graphs G and H is the same as getting
        their complement, performing a disjoint union, and finally getting
        the complement of the resulting graph.

        Graph, edge, and node attributes are propagated from G and H
        to the union graph.  If a graph attribute is present in both
        G and H the value from H is used.

        See Also
        --------
        union
        disjoint_union
    
    """
    def add_prefix(graph, prefix):
