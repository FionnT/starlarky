def generic_graph_view(G, create_using=None):
    """
    Multigraph for G must agree with create_using
    """
def subgraph_view(G, filter_node=no_filter, filter_edge=no_filter):
    """
     View of `G` applying a filter on nodes and edges.

        `subgraph_view` provides a read-only view of the input graph that excludes
        nodes and edges based on the outcome of two filter functions `filter_node`
        and `filter_edge`.

        The `filter_node` function takes one argument --- the node --- and returns
        `True` if the node should be included in the subgraph, and `False` if it
        should not be included.

        The `filter_edge` function takes two (or three arguments if `G` is a
        multi-graph) --- the nodes describing an edge, plus the edge-key if
        parallel edges are possible --- and returns `True` if the edge should be
        included in the subgraph, and `False` if it should not be included.

        Both node and edge filter functions are called on graph elements as they
        are queried, meaning there is no up-front cost to creating the view.

        Parameters
        ----------
        G : networkx.Graph
            A directed/undirected graph/multigraph

        filter_node : callable, optional
            A function taking a node as input, which returns `True` if the node
            should appear in the view.

        filter_edge : callable, optional
            A function taking as input the two nodes describing an edge (plus the
            edge-key if `G` is a multi-graph), which returns `True` if the edge
            should appear in the view.

        Returns
        -------
        graph : networkx.Graph
            A read-only graph view of the input graph.

        Examples
        --------
        >>> G = nx.path_graph(6)

        Filter functions operate on the node, and return `True` if the node should
        appear in the view:

        >>> def filter_node(n1):
        ...     return n1 != 5
        ...
        >>> view = nx.subgraph_view(G, filter_node=filter_node)
        >>> view.nodes()
        NodeView((0, 1, 2, 3, 4))

        We can use a closure pattern to filter graph elements based on additional
        data --- for example, filtering on edge data attached to the graph:

        >>> G[3][4]["cross_me"] = False
        >>> def filter_edge(n1, n2):
        ...     return G[n1][n2].get("cross_me", True)
        ...
        >>> view = nx.subgraph_view(G, filter_edge=filter_edge)
        >>> view.edges()
        EdgeView([(0, 1), (1, 2), (2, 3), (4, 5)])

        >>> view = nx.subgraph_view(G, filter_node=filter_node, filter_edge=filter_edge,)
        >>> view.nodes()
        NodeView((0, 1, 2, 3, 4))
        >>> view.edges()
        EdgeView([(0, 1), (1, 2), (2, 3)])
    
    """
        def reverse_edge(u, v, k):
            """
            undirected
            """
def reverse_view(G):
    """
     View of `G` with edge directions reversed

        `reverse_view` returns a read-only view of the input graph where
        edge directions are reversed.

        Identical to digraph.reverse(copy=False)

        Parameters
        ----------
        G : networkx.DiGraph

        Returns
        -------
        graph : networkx.DiGraph

        Examples
        --------
        >>> G = nx.DiGraph()
        >>> G.add_edge(1, 2)
        >>> G.add_edge(2, 3)
        >>> G.edges()
        OutEdgeView([(1, 2), (2, 3)])

        >>> view = nx.reverse_view(G)
        >>> view.edges()
        OutEdgeView([(2, 1), (3, 2)])
    
    """
