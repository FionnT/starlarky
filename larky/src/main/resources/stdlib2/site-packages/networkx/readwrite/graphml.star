2021-03-02 20:47:06,776 : INFO : tokenize_signature : --> do i ever get here?
2021-03-02 20:47:06,776 : INFO : tokenize_signature : --> do i ever get here?
2021-03-02 20:47:06,776 : INFO : tokenize_signature : --> do i ever get here?
2021-03-02 20:47:06,777 : INFO : tokenize_signature : --> do i ever get here?
2021-03-02 20:47:06,777 : INFO : tokenize_signature : --> do i ever get here?
2021-03-02 20:47:06,777 : INFO : tokenize_signature : --> do i ever get here?
2021-03-02 20:47:06,777 : INFO : tokenize_signature : --> do i ever get here?
def write_graphml_xml(
    G,
    path,
    encoding="utf-8",
    prettyprint=True,
    infer_numeric_types=False,
    named_key_ids=False,
):
    """
    Write G in GraphML XML format to path

        Parameters
        ----------
        G : graph
           A networkx graph
        path : file or string
           File or filename to write.
           Filenames ending in .gz or .bz2 will be compressed.
        encoding : string (optional)
           Encoding for text data.
        prettyprint : bool (optional)
           If True use line breaks and indenting in output XML.
        infer_numeric_types : boolean
           Determine if numeric types should be generalized.
           For example, if edges have both int and float 'weight' attributes,
           we infer in GraphML that both are floats.
        named_key_ids : bool (optional)
           If True use attr.name as value for key elements' id attribute.

        Examples
        --------
        >>> G = nx.path_graph(4)
        >>> nx.write_graphml(G, "test.graphml")

        Notes
        -----
        This implementation does not support mixed graphs (directed
        and unidirected edges together) hyperedges, nested graphs, or ports.
    
    """
2021-03-02 20:47:06,777 : INFO : tokenize_signature : --> do i ever get here?
2021-03-02 20:47:06,777 : INFO : tokenize_signature : --> do i ever get here?
2021-03-02 20:47:06,777 : INFO : tokenize_signature : --> do i ever get here?
2021-03-02 20:47:06,777 : INFO : tokenize_signature : --> do i ever get here?
2021-03-02 20:47:06,777 : INFO : tokenize_signature : --> do i ever get here?
2021-03-02 20:47:06,778 : INFO : tokenize_signature : --> do i ever get here?
2021-03-02 20:47:06,778 : INFO : tokenize_signature : --> do i ever get here?
def write_graphml_lxml(
    G,
    path,
    encoding="utf-8",
    prettyprint=True,
    infer_numeric_types=False,
    named_key_ids=False,
):
    """
    Write G in GraphML XML format to path

        This function uses the LXML framework and should be faster than
        the version using the xml library.

        Parameters
        ----------
        G : graph
           A networkx graph
        path : file or string
           File or filename to write.
           Filenames ending in .gz or .bz2 will be compressed.
        encoding : string (optional)
           Encoding for text data.
        prettyprint : bool (optional)
           If True use line breaks and indenting in output XML.
        infer_numeric_types : boolean
           Determine if numeric types should be generalized.
           For example, if edges have both int and float 'weight' attributes,
           we infer in GraphML that both are floats.
        named_key_ids : bool (optional)
           If True use attr.name as value for key elements' id attribute.

        Examples
        --------
        >>> G = nx.path_graph(4)
        >>> nx.write_graphml_lxml(G, "fourpath.graphml")  # doctest: +SKIP

        Notes
        -----
        This implementation does not support mixed graphs (directed
        and unidirected edges together) hyperedges, nested graphs, or ports.
    
    """
def generate_graphml(G, encoding="utf-8", prettyprint=True, named_key_ids=False):
    """
    Generate GraphML lines for G

        Parameters
        ----------
        G : graph
           A networkx graph
        encoding : string (optional)
           Encoding for text data.
        prettyprint : bool (optional)
           If True use line breaks and indenting in output XML.
        named_key_ids : bool (optional)
           If True use attr.name as value for key elements' id attribute.

        Examples
        --------
        >>> G = nx.path_graph(4)
        >>> linefeed = chr(10)  # linefeed = \n
        >>> s = linefeed.join(nx.generate_graphml(G))  # doctest: +SKIP
        >>> for line in nx.generate_graphml(G):  # doctest: +SKIP
        ...     print(line)

        Notes
        -----
        This implementation does not support mixed graphs (directed and unidirected
        edges together) hyperedges, nested graphs, or ports.
    
    """
def read_graphml(path, node_type=str, edge_key_type=int, force_multigraph=False):
    """
    Read graph in GraphML format from path.

        Parameters
        ----------
        path : file or string
           File or filename to write.
           Filenames ending in .gz or .bz2 will be compressed.

        node_type: Python type (default: str)
           Convert node ids to this type

        edge_key_type: Python type (default: int)
           Convert graphml edge ids to this type. Multigraphs use id as edge key.
           Non-multigraphs add to edge attribute dict with name "id".

        force_multigraph : bool (default: False)
           If True, return a multigraph with edge keys. If False (the default)
           return a multigraph when multiedges are in the graph.

        Returns
        -------
        graph: NetworkX graph
            If parallel edges are present or `force_multigraph=True` then
            a MultiGraph or MultiDiGraph is returned. Otherwise a Graph/DiGraph.
            The returned graph is directed if the file indicates it should be.

        Notes
        -----
        Default node and edge attributes are not propagated to each node and edge.
        They can be obtained from `G.graph` and applied to node and edge attributes
        if desired using something like this:

        >>> default_color = G.graph["node_default"]["color"]  # doctest: +SKIP
        >>> for node, data in G.nodes(data=True):  # doctest: +SKIP
        ...     if "color" not in data:
        ...         data["color"] = default_color
        >>> default_color = G.graph["edge_default"]["color"]  # doctest: +SKIP
        >>> for u, v, data in G.edges(data=True):  # doctest: +SKIP
        ...     if "color" not in data:
        ...         data["color"] = default_color

        This implementation does not support mixed graphs (directed and unidirected
        edges together), hypergraphs, nested graphs, or ports.

        For multigraphs the GraphML edge "id" will be used as the edge
        key.  If not specified then they "key" attribute will be used.  If
        there is no "key" attribute a default NetworkX multigraph edge key
        will be provided.

        Files with the yEd "yfiles" extension will can be read but the graphics
        information is discarded.

        yEd compressed files ("file.graphmlz" extension) can be read by renaming
        the file to "file.graphml.gz".

    
    """
2021-03-02 20:47:06,779 : INFO : tokenize_signature : --> do i ever get here?
2021-03-02 20:47:06,780 : INFO : tokenize_signature : --> do i ever get here?
def parse_graphml(
    graphml_string, node_type=str, edge_key_type=int, force_multigraph=False
):
    """
    Read graph in GraphML format from string.

        Parameters
        ----------
        graphml_string : string
           String containing graphml information
           (e.g., contents of a graphml file).

        node_type: Python type (default: str)
           Convert node ids to this type

        edge_key_type: Python type (default: int)
           Convert graphml edge ids to this type. Multigraphs use id as edge key.
           Non-multigraphs add to edge attribute dict with name "id".

        force_multigraph : bool (default: False)
           If True, return a multigraph with edge keys. If False (the default)
           return a multigraph when multiedges are in the graph.


        Returns
        -------
        graph: NetworkX graph
            If no parallel edges are found a Graph or DiGraph is returned.
            Otherwise a MultiGraph or MultiDiGraph is returned.

        Examples
        --------
        >>> G = nx.path_graph(4)
        >>> linefeed = chr(10)  # linefeed = \n
        >>> s = linefeed.join(nx.generate_graphml(G))
        >>> H = nx.parse_graphml(s)

        Notes
        -----
        Default node and edge attributes are not propagated to each node and edge.
        They can be obtained from `G.graph` and applied to node and edge attributes
        if desired using something like this:

        >>> default_color = G.graph["node_default"]["color"]  # doctest: +SKIP
        >>> for node, data in G.nodes(data=True):  # doctest: +SKIP
        ...     if "color" not in data:
        ...         data["color"] = default_color
        >>> default_color = G.graph["edge_default"]["color"]  # doctest: +SKIP
        >>> for u, v, data in G.edges(data=True):  # doctest: +SKIP
        ...     if "color" not in data:
        ...         data["color"] = default_color

        This implementation does not support mixed graphs (directed and unidirected
        edges together), hypergraphs, nested graphs, or ports.

        For multigraphs the GraphML edge "id" will be used as the edge
        key.  If not specified then they "key" attribute will be used.  If
        there is no "key" attribute a default NetworkX multigraph edge key
        will be provided.

    
    """
def GraphML:
    """
    http://graphml.graphdrawing.org/xmlns
    """
def GraphMLWriter(GraphML):
    """
    utf-8
    """
    def __str__(self):
        """
        Infer the attribute type of data named name. Currently this only
                supports inference of numeric types.

                If self.infer_numeric_types is false, type is used. Otherwise, pick the
                most general of types found across all values with name and scope. This
                means edges with data named 'weight' are treated separately from nodes
                with data named 'weight'.
        
        """
    def get_key(self, name, attr_type, scope, default):
        """
        f"d{len(list(self.keys))}
        """
    def add_data(self, name, element_type, value, scope="all", default=None):
        """

                Make a data element for an edge or a node. Keep a log of the
                type in the keys table.
        
        """
    def add_attributes(self, scope, xml_obj, data, default):
        """
        Appends attribute data to edges or nodes, and stores type information
                to be added later. See add_graph_element.
        
        """
    def add_nodes(self, G, graph_element):
        """
        node_default
        """
    def add_edges(self, G, graph_element):
        """
        edge
        """
    def add_graph_element(self, G):
        """

                Serialize graph G in GraphML to the stream.
        
        """
    def add_graphs(self, graph_list):
        """
         Add many graphs to this GraphML document. 
        """
    def dump(self, stream):
        """
         in-place prettyprint formatter

        """
def IncrementalElement:
    """
    Wrapper for _IncrementalWriter providing an Element like interface.

        This wrapper does not intend to be a complete implementation but rather to
        deal with those calls used in GraphMLWriter.
    
    """
    def __init__(self, xml, prettyprint):
        """
        utf-8
        """
    def add_graph_element(self, G):
        """

                Serialize graph G in GraphML to the stream.
        
        """
    def add_attributes(self, scope, xml_obj, data, default):
        """
        Appends attribute data.
        """
    def __str__(self):
        """
         Choose a writer function for default

        """
def GraphMLReader(GraphML):
    """
    Read a GraphML document.  Produces NetworkX graph objects.
    """
    def __init__(self, node_type=str, edge_key_type=int, force_multigraph=False):
        """
         If False, test for multiedges
        """
    def __call__(self, path=None, string=None):
        """
        Must specify either 'path' or 'string' as kwarg
        """
    def make_graph(self, graph_xml, graphml_keys, defaults, G=None):
        """
         set default graph type

        """
    def add_node(self, G, node_xml, graphml_keys, defaults):
        """
        Add a node to the graph.
        
        """
    def add_edge(self, G, edge_element, graphml_keys):
        """
        Add an edge to the graph.
        
        """
    def decode_data_elements(self, graphml_keys, obj_xml):
        """
        Use the key information to decode the data XML if present.
        """
    def find_graphml_keys(self, graph_element):
        """
        Extracts all the keys and key defaults from the xml.
        
        """
