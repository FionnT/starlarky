def MetadataMissingError(DistlibException):
    """
    A required metadata is missing
    """
def MetadataConflictError(DistlibException):
    """
    Attempt to read or write metadata fields that are conflictual.
    """
def MetadataUnrecognizedVersionError(DistlibException):
    """
    Unknown metadata version number.
    """
def MetadataInvalidError(DistlibException):
    """
    A metadata value is invalid
    """
def _version2fieldlist(version):
    """
    '1.0'
    """
def _best_version(fields):
    """
    Detect the best version depending on the fields used.
    """
    def _has_marker(keys, markers):
        """
        'UNKNOWN'
        """
def _get_name_and_version(name, version, for_filename=False):
    """
    Return the distribution name with version.

        If for_filename is true, return a filename-escaped form.
    """
def LegacyMetadata(object):
    """
    The legacy metadata of a release.

        Supports versions 1.0, 1.1, 1.2, 2.0 and 1.3/2.1 (auto-detected). You can
        instantiate the class with one of these arguments (or none):
        - *path*, the path to a metadata file
        - *fileobj* give a file-like object with metadata as content
        - *mapping* is a dict-like object
        - *scheme* is a version scheme name
    
    """
2021-03-02 20:48:46,467 : INFO : tokenize_signature : --> do i ever get here?
    def __init__(self, path=None, fileobj=None, mapping=None,
                 scheme='default'):
        """
        'path, fileobj and mapping are exclusive'
        """
    def set_metadata_version(self):
        """
        'Metadata-Version'
        """
    def _write_field(self, fileobj, name, value):
        """
        '%s: %s\n'
        """
    def __getitem__(self, name):
        """
        '-'
        """
    def _default_value(self, name):
        """
        'UNKNOWN'
        """
    def _remove_line_prefix(self, value):
        """
        '1.0'
        """
    def __getattr__(self, name):
        """

         Public API


            dependencies = property(_get_dependencies, _set_dependencies)


        """
    def get_fullname(self, filesafe=False):
        """
        Return the distribution name with version.

                If filesafe is true, return a filename-escaped form.
        """
    def is_field(self, name):
        """
        return True if name is a valid metadata key
        """
    def is_multi_field(self, name):
        """
        Read the metadata values from a file path.
        """
    def read_file(self, fileob):
        """
        Read the metadata values from a file object.
        """
    def write(self, filepath, skip_unknown=False):
        """
        Write the metadata fields to filepath.
        """
    def write_file(self, fileobject, skip_unknown=False):
        """
        Write the PKG-INFO format data to a file object.
        """
    def update(self, other=None, **kwargs):
        """
        Set metadata values from the given iterable `other` and kwargs.

                Behavior is like `dict.update`: If `other` has a ``keys`` method,
                they are looped over and ``self[key]`` is assigned ``other[key]``.
                Else, ``other`` is an iterable of ``(key, value)`` iterables.

                Keys that don't match a metadata field or that have an empty value are
                dropped.
        
        """
        def _set(key, value):
            """
             other is None or empty container

            """
    def set(self, name, value):
        """
        Control then set a metadata field.
        """
    def get(self, name, default=_MISSING):
        """
        Get a metadata field.
        """
    def check(self, strict=False):
        """
        Check if the metadata is compliant. If strict is True then raise if
                no Name or Version are provided
        """
        def are_valid_constraints(value):
            """
            ';'
            """
    def todict(self, skip_missing=False):
        """
        Return fields as a dict.

                Field names will be converted to use the underscore-lowercase style
                instead of hyphen-mixed case (i.e. home_page instead of Home-page).
                This is as per https://www.python.org/dev/peps/pep-0566/#id17.
        
        """
    def add_requirements(self, requirements):
        """
        'Metadata-Version'
        """
    def keys(self):
        """
        'Metadata-Version'
        """
    def __iter__(self):
        """
        '<%s %s %s>'
        """
def Metadata(object):
    """

        The metadata of a release. This implementation uses 2.0 (JSON)
        metadata where possible. If not possible, it wraps a LegacyMetadata
        instance which handles the key-value metadata format.
    
    """
2021-03-02 20:48:46,476 : INFO : tokenize_signature : --> do i ever get here?
    def __init__(self, path=None, fileobj=None, mapping=None,
                 scheme='default'):
        """
        'path, fileobj and mapping are exclusive'
        """
    def __getattribute__(self, key):
        """
        'common_keys'
        """
    def _validate_value(self, key, value, scheme=None):
        """
        '%s' is an invalid value for 
        the '%s' property
        """
    def __setattr__(self, key, value):
        """
        'common_keys'
        """
    def name_and_version(self):
        """
        'Provides-Dist'
        """
    def provides(self, value):
        """
        'Provides-Dist'
        """
    def get_requirements(self, reqts, extras=None, env=None):
        """

                Base method to get dependencies, given a set of extras
                to satisfy and an optional environment context.
                :param reqts: A list of sometimes-wanted dependencies,
                              perhaps dependent on extras and environment.
                :param extras: A list of optional components being requested.
                :param env: An optional environment for marker evaluation.
        
        """
    def dictionary(self):
        """
        'metadata_version'
        """
    def validate(self):
        """
        'Metadata: missing: %s, warnings: %s'
        """
    def todict(self):
        """
        'metadata_version'
        """
    def _to_legacy(self):
        """
        'extra'
        """
    def write(self, path=None, fileobj=None, legacy=False, skip_unknown=True):
        """
        'Exactly one of path and fileobj is needed'
        """
    def add_requirements(self, requirements):
        """
        'run_requires'
        """
    def __repr__(self):
        """
        '(no name)'
        """
