def parse_marker(marker_string):
    """

        Parse a marker string and return a dictionary containing a marker expression.

        The dictionary will contain keys "op", "lhs" and "rhs" for non-terminals in
        the expression grammar, or strings. A string contained in quotes is to be
        interpreted as a literal string, and a string not contained in quotes is a
        variable (such as os_name).
    
    """
    def marker_var(remaining):
        """
         either identifier, or literal string

        """
    def marker_expr(remaining):
        """
        '('
        """
    def marker_and(remaining):
        """
        'op'
        """
    def marker(remaining):
        """
        'op'
        """
def parse_requirement(req):
    """

        Parse a requirement passed in as a string. Return a Container
        whose attributes contain the various parts of the requirement.
    
    """
            def get_versions(ver_remaining):
                """

                                Return a list of operator, version tuples if any are
                                specified, else None.
                
                """
def get_resources_dests(resources_root, rules):
    """
    Find destinations for resources files
    """
    def get_rel_path(root, path):
        """
         normalizes and returns a lstripped-/-separated path

        """
def in_venv():
    """
    'real_prefix'
    """
def get_executable():
    """
     The __PYVENV_LAUNCHER__ dance is apparently no longer needed, as
     changes to the stub launcher mean that sys.executable always points
     to the stub on OS X
        if sys.platform == 'darwin' and ('__PYVENV_LAUNCHER__'
                                         in os.environ):
            result =  os.environ['__PYVENV_LAUNCHER__']
        else:
            result = sys.executable
        return result

    """
def proceed(prompt, allowed_chars, error_prompt=None, default=None):
    """
    '%c: %s\n%s'
    """
def extract_by_key(d, keys):
    """
     needs to be a text stream

    """
    def read_stream(cp, stream):
        """
        'read_file'
        """
def write_exports(exports, stream):
    """
     needs to be a text stream

    """
def tempdir():
    """
    for attr in ('__name__', '__module__', '__doc__'):
        setattr(self, attr, getattr(func, attr, None))


    """
    def __get__(self, obj, cls=None):
        """
        obj.__dict__[self.func.__name__] = value = self.func(obj)

        """
def convert_path(pathname):
    """
    Return 'pathname' as a name that will work on the native filesystem.

        The path is split on '/' and put back together again using the current
        directory separator.  Needed because filenames in the setup script are
        always supplied in Unix style, and have to be converted to the local
        convention before we can actually use them in the filesystem.  Raises
        ValueError on non-Unix-ish systems if 'pathname' either starts or
        ends with a slash.
    
    """
def FileOperator(object):
    """
    Tell if the target is newer than the source.

            Returns true if 'source' exists and is more recently modified than
            'target', or if 'source' exists and 'target' doesn't.

            Returns false if both exist and 'target' is the same age or younger
            than 'source'. Raise PackagingFileError if 'source' does not exist.

            Note that this test is not very accurate: files created in the same
            second will have the same "age".
        
    """
    def copy_file(self, infile, outfile, check=True):
        """
        Copy a file respecting dry-run and force flags.
        
        """
    def copy_stream(self, instream, outfile, encoding=None):
        """
        'Copying stream %s to %s'
        """
    def write_binary_file(self, path, data):
        """
        'wb'
        """
    def write_text_file(self, path, data, encoding):
        """
        'posix'
        """
    def ensure_dir(self, path):
        """
        'Creating %s'
        """
    def byte_compile(self, path, optimize=False, force=False, prefix=None, hashed_invalidation=False):
        """
        'Byte-compiling %s to %s'
        """
    def ensure_removed(self, path):
        """
        'Removing directory tree at %s'
        """
    def is_writable(self, path):
        """

                Commit recorded changes, turn off recording, return
                changes.
        
        """
    def rollback(self):
        """
         dirs should all be empty now, except perhaps for
         __pycache__ subdirs
         reverse so that subdirs appear before their parents

        """
def resolve(module_name, dotted_path):
    """
    '.'
    """
def ExportEntry(object):
    """
     pragma: no cover
    """
    def __eq__(self, other):
        """
        r'''(?P<name>(\w|[-.+])+)
                              \s*=\s*(?P<callable>(\w+)([:\.]\w+)*)
                              \s*(\[\s*(?P<flags>[\w-]+(=\w+)?(,\s*\w+(=\w+)?)*)\s*\])?
                              '''
        """
def get_export_entry(specification):
    """
    '['
    """
def get_cache_base(suffix=None):
    """

        Return the default base location for distlib caches. If the directory does
        not exist, it is created. Use the suffix provided for the base directory,
        and default to '.distlib' if it isn't provided.

        On Windows, if LOCALAPPDATA is defined in the environment, then it is
        assumed to be a directory, and will be the parent directory of the result.
        On POSIX, and on Windows if LOCALAPPDATA is not defined, the user's home
        directory - using os.expanduser('~') - will be the parent directory of
        the result.

        The result is just the directory '.distlib' in the parent directory as
        determined above, or with the name specified with ``suffix``.
    
    """
def path_to_cache_dir(path):
    """

        Convert an absolute path to a directory name for use in a cache.

        The algorithm used is:

        #. On Windows, any ``':'`` in the drive is replaced with ``'---'``.
        #. Any occurrence of ``os.sep`` is replaced with ``'--'``.
        #. ``'.cache'`` is appended.
    
    """
def ensure_slash(s):
    """
    '/'
    """
def parse_credentials(netloc):
    """
    '@'
    """
def get_process_umask():
    """
    '([a-z0-9_]+([.-][a-z_][a-z0-9_]*)*)-'
    '([a-z0-9_.+-]+)'
    """
def split_filename(filename, project_name=None):
    """

        Extract name, version, python version from a filename (no extension)

        Return name, version, pyver or None
    
    """
def parse_name_and_version(p):
    """

        A utility method used to get name and version from a string.

        From e.g. a Provides-Dist value.

        :param p: A value in a form 'foo (1.0)'
        :return: The name and version as a tuple.
    
    """
def get_extras(requested, available):
    """
    '*'
    """
def _get_external_data(url):
    """
     urlopen might fail if it runs into redirections,
     because of Python issue #13696. Fixed in locators
     using a custom redirect handler.

    """
def get_project_data(name):
    """
    '%s/%s/project.json'
    """
def get_package_data(name, version):
    """
    '%s/%s/package-%s.json'
    """
def Cache(object):
    """

        A class implementing a cache for resources that need to live in the file system
        e.g. shared libraries. This class was moved from resources to here because it
        could be used by other modules, e.g. the wheel module.
    
    """
    def __init__(self, base):
        """

                Initialise an instance.

                :param base: The base directory where the cache should be located.
        
        """
    def prefix_to_dir(self, prefix):
        """

                Converts a resource prefix to a directory name in the cache.
        
        """
    def clear(self):
        """

                Clear the cache.
        
        """
def EventMixin(object):
    """

        A very simple publish/subscribe system.
    
    """
    def __init__(self):
        """

                Add a subscriber for an event.

                :param event: The name of an event.
                :param subscriber: The subscriber to be added (and called when the
                                   event is published).
                :param append: Whether to append or prepend the subscriber to an
                               existing subscriber list for the event.
        
        """
    def remove(self, event, subscriber):
        """

                Remove a subscriber for an event.

                :param event: The name of an event.
                :param subscriber: The subscriber to be removed.
        
        """
    def get_subscribers(self, event):
        """

                Return an iterator for the subscribers for an event.
                :param event: The event to return subscribers for.
        
        """
    def publish(self, event, *args, **kwargs):
        """

                Publish a event and return a list of values returned by its
                subscribers.

                :param event: The event to publish.
                :param args: The positional arguments to pass to the event's
                             subscribers.
                :param kwargs: The keyword arguments to pass to the event's
                               subscribers.
        
        """
def Sequencer(object):
    """
     nodes with no preds/succs
    """
    def add_node(self, node):
        """
         Remove empties

        """
    def add(self, pred, succ):
        """
         pragma: no cover
        """
    def is_step(self, step):
        """
        'Unknown: %r'
        """
    def strong_connections(self):
        """
        http://en.wikipedia.org/wiki/Tarjan%27s_strongly_connected_components_algorithm

        """
        def strongconnect(node):
            """
             set the depth index for this node to the smallest unused index

            """
    def dot(self):
        """
        'digraph G {'
        """
def unarchive(archive_filename, dest_dir, format=None, check=True):
    """
    'utf-8'
    """
def zip_dir(directory):
    """
    zip a directory tree into a BytesIO object
    """
def Progress(object):
    """
    'UNKNOWN'
    """
    def __init__(self, minval=0, maxval=100):
        """
        '100 %'
        """
    def format_duration(self, duration):
        """
        '??:??:??'
        """
    def ETA(self):
        """
        'Done'
        """
    def speed(self):
        """
        '%d %sB/s'
        """
def iglob(path_glob):
    """
    Extended globbing function that supports ** and {opt1,opt2,opt3}.
    """
def _iglob(path_glob):
    """
    ','
    """
    def HTTPSConnection(httplib.HTTPSConnection):
    """
     set this to the path to the certs file (.pem)
    """
        def connect(self):
            """
            '_tunnel_host'
            """
    def HTTPSHandler(BaseHTTPSHandler):
    """

                This is called to create a connection instance. Normally you'd
                pass a connection class to do_open, but it doesn't actually check for
                a class, and just expects a callable. As long as we behave just as a
                constructor would have, we should be OK. If it ever changes so that
                we *must* pass a class, we'll create an UnsafeHTTPSConnection class
                which just sets check_domain to False in the class definition, and
                choose which one to pass to do_open.
            
    """
        def https_open(self, req):
            """
            'certificate verify failed'
            """
    def HTTPSOnlyHandler(HTTPSHandler, HTTPHandler):
    """
    'Unexpected HTTP request on what should be a secure '
    'connection: %s'
    """
    def HTTP(httplib.HTTP):
    """
    ''
    """
        def HTTPS(httplib.HTTPS):
    """
    ''
    """
def Transport(xmlrpclib.Transport):
    """
    'timeout'
    """
def ServerProxy(xmlrpclib.ServerProxy):
    """
    'timeout'
    """
def _csv_open(fn, mode, **kwargs):
    """
    'b'
    """
def CSVBase(object):
    """
    'delimiter'
    """
    def __enter__(self):
        """
        'stream'
        """
    def __iter__(self):
        """
        'utf-8'
        """
def CSVWriter(CSVBase):
    """
    'w'
    """
    def writerow(self, row):
        """
        'utf-8'
        """
def Configurator(BaseConfigurator):
    """
    'inc'
    """
    def __init__(self, config, base=None):
        """
        '()'
        """
    def __getitem__(self, key):
        """
        '()'
        """
    def inc_convert(self, value):
        """
        Default converter for the inc:// protocol.
        """
def SubprocessMixin(object):
    """

        Mixin for running subprocesses and capturing their output
    
    """
    def __init__(self, verbose=False, progress=None):
        """

                Read lines from a subprocess' output stream and either pass to a progress
                callable (if specified) or write progress information to sys.stderr.
        
        """
    def run_command(self, cmd, **kwargs):
        """
        'stdout'
        """
def normalize_name(name):
    """
    Normalize a python package name a la PEP 503
    """
