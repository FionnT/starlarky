def error(Exception):
    """
    Exception raised for invalid regular expressions.

        Attributes:

            msg: The unformatted error message
            pattern: The regular expression pattern
            pos: The position in the pattern where compilation failed, or None
            lineno: The line number where compilation failed, unless pos is None
            colno: The column number where compilation failed, unless pos is None
    
    """
    def __init__(self, message, pattern=None, pos=None):
        """
        '\n'
        """
def _UnscopedFlagSet(Exception):
    """
     The exception for when parsing fails and we want to try something else.

    """
def ParseError(Exception):
    """
     The exception for when there isn't a valid first set.

    """
def _FirstSetError(Exception):
    """
     Flags.

    """
def Namespace:
    """
    Make room in the given cache.

        Args:
            cache_dict: The cache dictionary to modify.
            args_dict: The dictionary of named list args used by patterns.
            max_length: Maximum # of entries in cache_dict before it is shrunk.
            divisor: Cache will shrink to max_length - 1/divisor*max_length items.
    
    """
def _fold_case(info, string):
    """
    Folds the case of a string.
    """
def is_cased_i(info, char):
    """
    Checks whether a character is cased.
    """
def is_cased_f(flags, char):
    """
    Checks whether a character is cased.
    """
def _compile_firstset(info, fs):
    """
    Compiles the firstset for the pattern.
    """
def _check_firstset(info, reverse, fs):
    """
    Checks the firstset for the pattern.
    """
def _flatten_code(code):
    """
    Flattens the code from a list of tuples.
    """
def make_case_flags(info):
    """
    Makes the case flags.
    """
def make_character(info, value, in_set=False):
    """
    Makes a character literal.
    """
def make_ref_group(info, name, position):
    """
    Makes a group reference.
    """
def make_string_set(info, name):
    """
    Makes a string set.
    """
def make_property(info, prop, in_set):
    """
    Makes a property.
    """
def _parse_pattern(source, info):
    """
    Parses a pattern, eg. 'a|b|c'.
    """
def parse_sequence(source, info):
    """
    Parses a sequence, eg. 'abc'.
    """
2021-03-02 20:50:08,213 : INFO : tokenize_signature : --> do i ever get here?
def apply_quantifier(source, info, counts, case_flags, ch, saved_pos,
  sequence):
    """
    multiple repeat
    """
2021-03-02 20:50:08,214 : INFO : tokenize_signature : --> do i ever get here?
def apply_constraint(source, info, constraints, case_flags, saved_pos,
  sequence):
    """
    nothing for fuzzy constraint
    """
def parse_quantifier(source, info, ch):
    """
    Parses a quantifier.
    """
def is_above_limit(count):
    """
    Checks whether a count is above the maximum.
    """
def parse_limited_quantifier(source):
    """
    Parses a limited quantifier.
    """
def parse_fuzzy(source, info, ch):
    """
    Parses a fuzzy setting, if present.
    """
def parse_fuzzy_item(source, constraints):
    """
    Parses a fuzzy setting item.
    """
def parse_cost_constraint(source, constraints):
    """
    Parses a cost constraint.
    """
def parse_cost_limit(source):
    """
    Parses a cost limit.
    """
def parse_constraint(source, constraints, ch):
    """
    Parses a constraint.
    """
def parse_fuzzy_compare(source):
    """
    Parses a cost comparator.
    """
def parse_cost_equation(source, constraints):
    """
    Parses a cost equation.
    """
def parse_cost_term(source, cost):
    """
    Parses a cost equation term.
    """
def parse_fuzzy_test(source, info):
    """
    \\
    """
def parse_count(source):
    """
    Parses a quantifier's count, which can be empty.
    """
def parse_paren(source, info):
    """
    Parses a parenthesised subpattern or a flag. Returns FLAGS if it's an
        inline flag.
    
    """
def parse_extension(source, info):
    """
    Parses a Python extension.
    """
def parse_comment(source):
    """
    Parses a comment.
    """
def parse_lookaround(source, info, behind, positive):
    """
    Parses a lookaround.
    """
def parse_conditional(source, info):
    """
    Parses a conditional subpattern.
    """
def parse_lookaround_conditional(source, info, behind, positive):
    """
    )
    """
def parse_atomic(source, info):
    """
    Parses an atomic subpattern.
    """
def parse_common(source, info):
    """
    Parses a common groups branch.
    """
def parse_call_group(source, info, ch, pos):
    """
    Parses a call to a group.
    """
def parse_call_named_group(source, info, pos):
    """
    Parses a call to a named group.
    """
def parse_flag_set(source):
    """
    Parses a set of inline flags.
    """
def parse_flags(source, info):
    """
    Parses flags being turned on/off.
    """
def parse_subpattern(source, info, flags_on, flags_off):
    """
    Parses a subpattern with scoped flags.
    """
def parse_flags_subpattern(source, info):
    """
    Parses a flags subpattern. It could be inline flags or a subpattern
        possibly with local flags. If it's a subpattern, then that's returned;
        if it's a inline flags, then None is returned.
    
    """
def parse_positional_flags(source, info, flags_on, flags_off):
    """
    Parses positional flags.
    """
def parse_name(source, allow_numeric=False, allow_group_0=False):
    """
    Parses a name.
    """
def is_octal(string):
    """
    Checks whether a string is octal.
    """
def is_decimal(string):
    """
    Checks whether a string is decimal.
    """
def is_hexadecimal(string):
    """
    Checks whether a string is hexadecimal.
    """
def parse_escape(source, info, in_set):
    """
    Parses an escape sequence.
    """
def parse_numeric_escape(source, info, ch, in_set):
    """
    Parses a numeric escape sequence.
    """
def parse_octal_escape(source, info, digits, in_set):
    """
    Parses an octal escape sequence.
    """
def parse_hex_escape(source, info, esc, expected_len, in_set, type):
    """
    Parses a hex escape sequence.
    """
def parse_group_ref(source, info):
    """
    Parses a group reference.
    """
def parse_string_set(source, info):
    """
    Parses a string set reference.
    """
def parse_named_char(source, info, in_set):
    """
    Parses a named character.
    """
def parse_property(source, info, positive, in_set):
    """
    Parses a Unicode property.
    """
def parse_property_name(source):
    """
    Parses a property name, which may be qualified.
    """
def parse_set(source, info):
    """
    Parses a character set.
    """
def parse_set_union(source, info):
    """
    Parses a set union ([x||y]).
    """
def parse_set_symm_diff(source, info):
    """
    Parses a set symmetric difference ([x~~y]).
    """
def parse_set_inter(source, info):
    """
    Parses a set intersection ([x&&y]).
    """
def parse_set_diff(source, info):
    """
    Parses a set difference ([x--y]).
    """
def parse_set_imp_union(source, info):
    """
    Parses a set implicit union ([xy]).
    """
def parse_set_member(source, info):
    """
    Parses a member in a character set.
    """
def parse_set_item(source, info):
    """
    Parses an item in a character set.
    """
def parse_posix_class(source, info):
    """
    Parses a POSIX character class.
    """
def float_to_rational(flt):
    """
    Converts a float to a rational pair.
    """
def numeric_to_rational(numeric):
    """
    Converts a numeric string to a rational string, if possible.
    """
def standardise_name(name):
    """
    Standardises a property or value name.
    """
def lookup_property(property, value, positive, source=None, posix=False):
    """
    Looks up a property.
    """
def _compile_replacement(source, pattern, is_unicode):
    """
    Compiles a replacement template escape sequence.
    """
def parse_repl_hex_escape(source, expected_len, type):
    """
    Parses a hex escape sequence in a replacement string.
    """
def parse_repl_named_char(source):
    """
    Parses a named character in a replacement string.
    """
def compile_repl_group(source, pattern):
    """
    Compiles a replacement template group reference.
    """
def make_sequence(items):
    """
     Common base class for all nodes.

    """
def RegexBase:
    """
     Base class for zero-width nodes.

    """
def ZeroWidthBase(RegexBase):
    """
    {}{} {}
    """
    def max_width(self):
        """
        ANY
        """
    def has_simple_start(self):
        """
        {}{}
        """
    def max_width(self):
        """
        ANY_ALL
        """
def AnyU(Any):
    """
    ANY_U
    """
def Atomic(RegexBase):
    """
    {}ATOMIC
    """
    def is_empty(self):
        """
        BOUNDARY
        """
def Branch(RegexBase):
    """
     Flatten branches within branches.

    """
    def _add_precheck(self, info, reverse, branches):
        """
        {}BRANCH
        """
    def _flatten_branches(info, reverse, branches):
        """
         Flatten the branches so that there aren't branches of branches.

        """
    def _split_common_prefix(info, branches):
        """
         Common leading items can be moved out of the branches.
         Get the items in the branches.

        """
    def _split_common_suffix(info, branches):
        """
         Common trailing items can be moved out of the branches.
         Get the items in the branches.

        """
    def _can_split(items, count):
        """
         Check the characters either side of the proposed split.

        """
    def _can_split_rev(items, count):
        """
         Check the characters either side of the proposed split.

        """
    def _merge_common_prefixes(info, reverse, branches):
        """
         Branches with the same case-sensitive character prefix can be grouped
         together if they are separated only by other branches with a
         character prefix.

        """
    def _is_simple_character(c):
        """
         Can the branches be reduced to a set?

        """
    def _flush_char_prefix(info, reverse, prefixed, order, new_branches):
        """
         Flush the prefixed branches.

        """
    def _flush_set_members(info, reverse, items, case_flags, new_branches):
        """
         Flush the set members.

        """
    def _is_full_case(items, i):
        """

        """
    def is_empty(self):
        """
        invalid group reference
        """
    def remove_captures(self):
        """
        group reference not allowed
        """
    def _compile(self, reverse, fuzzy):
        """
        {}GROUP_CALL {}
        """
    def __eq__(self, other):
        """
         The character expands on full case-folding.

        """
    def dump(self, indent, reverse):
        """
        bu
        """
    def matches(self, ch):
        """
        'DEFINE'
        """
    def optimise(self, info, reverse):
        """
        {}GROUP_EXISTS {}
        """
    def is_empty(self):
        """
        DEFAULT_BOUNDARY
        """
def DefaultEndOfWord(ZeroWidthBase):
    """
    DEFAULT_END_OF_WORD
    """
def DefaultStartOfWord(ZeroWidthBase):
    """
    DEFAULT_START_OF_WORD
    """
def EndOfLine(ZeroWidthBase):
    """
    END_OF_LINE
    """
def EndOfLineU(EndOfLine):
    """
    END_OF_LINE_U
    """
def EndOfString(ZeroWidthBase):
    """
    END_OF_STRING
    """
def EndOfStringLine(ZeroWidthBase):
    """
    END_OF_STRING_LINE
    """
def EndOfStringLineU(EndOfStringLine):
    """
    END_OF_STRING_LINE_U
    """
def EndOfWord(ZeroWidthBase):
    """
    END_OF_WORD
    """
def Failure(ZeroWidthBase):
    """
    FAILURE
    """
    def _compile(self, reverse, fuzzy):
        """
         If an error type is mentioned in the cost equation, then its maximum
         defaults to unlimited.

        """
    def fix_groups(self, pattern, reverse, fuzzy):
        """
         The individual limits.

        """
    def dump(self, indent, reverse):
        """
 
        """
    def is_empty(self):
        """
        ids
        """
def Grapheme(RegexBase):
    """
     Match at least 1 character until a grapheme boundary is reached. Note
     that this is the same whether matching forwards or backwards.

    """
    def dump(self, indent, reverse):
        """
        {}GRAPHEME
        """
    def max_width(self):
        """
        GREEDY_REPEAT
        """
    def __init__(self, subpattern, min_count, max_count):
        """
        INF
        """
    def is_empty(self):
        """
        {}ATOMIC
        """
def Group(RegexBase):
    """
    {}GROUP {}
    """
    def __eq__(self, other):
        """
        KEEP
        """
def LazyRepeat(GreedyRepeat):
    """
    LAZY_REPEAT
    """
def LookAround(RegexBase):
    """
    AHEAD
    """
    def __init__(self, behind, positive, subpattern):
        """
        {}LOOK{} {}
        """
    def is_empty(self):
        """
        AHEAD
        """
    def __init__(self, behind, positive, subpattern, yes_item, no_item):
        """
        {}CONDITIONAL {} {}
        """
    def is_empty(self):
        """
        {}PROPERTY {} {}:{}{}
        """
    def matches(self, ch):
        """
        PRUNE
        """
    def _compile(self, reverse, fuzzy):
        """
        RANGE
        """
2021-03-02 20:50:08,285 : INFO : tokenize_signature : --> do i ever get here?
    def __init__(self, lower, upper, positive=True, case_flags=NOCASE,
      zerowidth=False):
        """
         Is the range case-sensitive?

        """
    def _compile(self, reverse, fuzzy):
        """
        bu
        """
    def matches(self, ch):
        """
        unknown group
        """
    def remove_captures(self):
        """
        group reference not allowed
        """
    def _compile(self, reverse, fuzzy):
        """
        {}REF_GROUP {}{}
        """
    def max_width(self):
        """
        SEARCH_ANCHOR
        """
def Sequence(RegexBase):
    """
     Flatten the sequences.

    """
    def pack_characters(self, info):
        """
        Packs sequences of characters into strings.
        """
    def remove_captures(self):
        """
         Disregard case_flags if all of the characters are case-less.

        """
    def _fix_full_casefold(characters):
        """
         Split a literal needing full case-folding into chunks that need it
         and chunks that can use simple case-folding, which is faster.

        """
    def _merge_chunks(chunks):
        """
        {}{} {}{}
        """
    def _handle_case_folding(self, info, in_set):
        """
         Is the set case-sensitive?

        """
    def max_width(self):
        """
         Is the set case-sensitive?

        """
    def __del__(self):
        """
        SET_DIFF
        """
    def optimise(self, info, reverse, in_set=False):
        """
        SET_INTER
        """
    def optimise(self, info, reverse, in_set=False):
        """
         Intersection in intersection.

        """
    def matches(self, ch):
        """
        SET_SYM_DIFF
        """
    def optimise(self, info, reverse, in_set=False):
        """
         Symmetric difference in symmetric difference.

        """
    def matches(self, ch):
        """
        SET_UNION
        """
    def optimise(self, info, reverse, in_set=False):
        """
         Union in union.

        """
    def _compile(self, reverse, fuzzy):
        """
        SKIP
        """
def StartOfLine(ZeroWidthBase):
    """
    START_OF_LINE
    """
def StartOfLineU(StartOfLine):
    """
    START_OF_LINE_U
    """
def StartOfString(ZeroWidthBase):
    """
    START_OF_STRING
    """
def StartOfWord(ZeroWidthBase):
    """
    START_OF_WORD
    """
def String(RegexBase):
    """

    """
    def max_width(self):
        """
        ''
        """
def StringSet(Branch):
    """
     Sort from longest to shortest.

    """
    def dump(self, indent, reverse):
        """
        {}STRING_SET {}{}
        """
    def __del__(self):
        """
        Scanner for the regular expression source string.
        """
    def __init__(self, string):
        """
        latin-1
        """
    def get(self, override_ignore=False):
        """
         Skip over the whitespace.

        """
    def get_many(self, count=1):
        """
         Skip over the whitespace.

        """
    def get_while(self, test_set, include=True):
        """
         Skip over the whitespace.

        """
    def skip_while(self, test_set, include=True):
        """
         Skip over the whitespace.

        """
    def match(self, substring):
        """
         Skip over the whitespace.

        """
    def expect(self, substring):
        """
        missing {}
        """
    def at_end(self):
        """

        """
def Info:
    """
    Info about the regular expression.
    """
    def __init__(self, flags=0, char_type=None, kwargs={}):
        """
         We have a nested named group. We'll assign it a private group
         number, initially negative until we can assign a proper
         (positive) number.

        """
    def close_group(self):
        """
         In version 1, a group reference can refer to an open group. We'll
         just pretend the group isn't open.

        """
def _check_group_features(info, parsed):
    """
    Checks whether the reverse and fuzzy features of the group calls match
        the groups which they call.
    
    """
def _get_required_string(parsed, flags):
    """
    Gets the required string and related info of a parsed pattern.
    """
def Scanner:
    """
     Combine phrases into a compound pattern.

    """
    def scan(self, string):
        """
        '__call__'
        """
