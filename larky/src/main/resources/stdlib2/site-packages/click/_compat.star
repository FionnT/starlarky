def get_filesystem_encoding():
    """
    replace
    """
def is_ascii_encoding(encoding):
    """
    Checks if a given encoding is ascii.
    """
def get_best_encoding(stream):
    """
    Returns the default stream encoding if not found.
    """
def _NonClosingTextIOWrapper(io.TextIOWrapper):
    """
     The io module is a place where the Python 3 text behavior
     was forced upon Python 2, so we need to unbreak
     it to look like Python 2.

    """
        def write(self, x):
            """
             https://bitbucket.org/pypy/pypy/issue/1803

            """
def _FixupStream(object):
    """
    The new io interface needs more from streams than streams
        traditionally implement.  As such, this fix-up code is necessary in
        some circumstances.

        The forcing of readable and writable flags are there because some tools
        put badly patched objects on sys (one such offender are certain version
        of jupyter notebook).
    
    """
    def __init__(self, stream, force_readable=False, force_writable=False):
        """
        read1
        """
    def readable(self):
        """
        readable
        """
    def writable(self):
        """
        writable
        """
    def seekable(self):
        """
        seekable
        """
    def is_bytes(x):
        """
        r"^[a-zA-Z_][a-zA-Z0-9_]*$
        """
    def set_binary_mode(f):
        """
        stdout
        """
    def get_binary_stderr():
        """
        stderr
        """
    def get_text_stdin(encoding=None, errors=None):
        """
        stdout
        """
    def get_text_stderr(encoding=None, errors=None):
        """
        stderr
        """
    def filename_to_ui(value):
        """
        replace
        """
    def is_bytes(x):
        """
         This happens in some cases where the stream was already
         closed.  In this case, we assume the default.


        """
    def _is_binary_writer(stream, default=False):
        """
        b
        """
    def _find_binary_reader(stream):
        """
         We need to figure out if the given stream is already binary.
         This can happen because the official docs recommend detaching
         the streams to get binary streams.  Some code might do this, so
         we need to deal with this case explicitly.

        """
    def _find_binary_writer(stream):
        """
         We need to figure out if the given stream is already binary.
         This can happen because the official docs recommend detatching
         the streams to get binary streams.  Some code might do this, so
         we need to deal with this case explicitly.

        """
    def _stream_is_misconfigured(stream):
        """
        A stream is misconfigured if its encoding is ASCII.
        """
    def _is_compat_stream_attr(stream, attr, value):
        """
        A stream attribute is compatible if it is equal to the
                desired value or the desired value is unset and the attribute
                has a value.
        
        """
    def _is_compatible_text_stream(stream, encoding, errors):
        """
        Check if a stream's encoding and errors attributes are
                compatible with the desired values.
        
        """
2021-03-02 20:50:07,040 : INFO : tokenize_signature : --> do i ever get here?
2021-03-02 20:50:07,040 : INFO : tokenize_signature : --> do i ever get here?
2021-03-02 20:50:07,040 : INFO : tokenize_signature : --> do i ever get here?
2021-03-02 20:50:07,040 : INFO : tokenize_signature : --> do i ever get here?
2021-03-02 20:50:07,040 : INFO : tokenize_signature : --> do i ever get here?
2021-03-02 20:50:07,040 : INFO : tokenize_signature : --> do i ever get here?
2021-03-02 20:50:07,040 : INFO : tokenize_signature : --> do i ever get here?
2021-03-02 20:50:07,040 : INFO : tokenize_signature : --> do i ever get here?
    def _force_correct_text_stream(
        text_stream,
        encoding,
        errors,
        is_binary,
        find_binary,
        force_readable=False,
        force_writable=False,
    ):
        """
         If the stream looks compatible, and won't default to a
         misconfigured ascii encoding, return it as-is.

        """
    def _force_correct_text_reader(text_reader, encoding, errors, force_readable=False):
        """
        Was not able to determine binary stream for sys.stdin.
        """
    def get_binary_stdout():
        """
        Was not able to determine binary stream for sys.stdout.

        """
    def get_binary_stderr():
        """
        Was not able to determine binary stream for sys.stderr.

        """
    def get_text_stdin(encoding=None, errors=None):
        """
        replace
        """
def get_streerror(e, default=None):
    """
    strerror
    """
def _wrap_io_open(file, mode, encoding, errors):
    """
    On Python 2, :func:`io.open` returns a text file wrapper that
        requires passing ``unicode`` to ``write``. Need to open the file in
        binary mode then wrap it in a subclass that can write ``str`` and
        ``unicode``.

        Also handles not passing ``encoding`` and ``errors`` in binary mode.
    
    """
def open_stream(filename, mode="r", encoding=None, errors="strict", atomic=False):
    """
    b
    """
def _AtomicFile(object):
    """

    """
def _is_jupyter_kernel_output(stream):
    """
     TODO: Couldn't test on Windows, should't try to support until
     someone tests the details wrt colorama.

    """
def should_strip_ansi(stream=None, color=None):
    """
     If we're on Windows, we provide transparent integration through
     colorama.  This will make ANSI colors through the echo function
     work automatically.

    """
    def _get_argv_encoding():
        """

        """
        def auto_wrap_for_ansi(stream, color=None):
            """
            This function wraps a stream so that calls through colorama
                        are issued to the win32 console API to recolor on demand.  It
                        also ensures to reset the colors if a write call is interrupted
                        to not destroy the console afterwards.
            
            """
            def _safe_write(s):
                """
                encoding
                """
def term_len(x):
    """
     In case wrapper_func() modified the stream
    """
