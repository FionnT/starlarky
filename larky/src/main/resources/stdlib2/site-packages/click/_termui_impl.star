def _length_hint(obj):
    """
    Returns the length hint of an object.
    """
def ProgressBar(object):
    """

    """
    def __enter__(self):
        """
        You need to use progress bars in a with block.
        """
    def __next__(self):
        """
         Iteration is defined in terms of a generator function,
         returned by iter(self); use that to define next(). This works
         because `self.iter` is an iterable consumed by that generator,
         so it is re-entry safe. Calling `next(self.generator())`
         twice works and does "what you want".

        """
    def is_fast(self):
        """
        {}d {:02}:{:02}:{:02}
        """
    def format_pos(self):
        """
        /{}
        """
    def format_pct(self):
        """
        {: 4}%
        """
    def format_bar(self):
        """

        """
    def format_progress_line(self):
        """
        label
        """
    def render_progress(self):
        """
         Update width in case the terminal has been resized

        """
    def make_step(self, n_steps):
        """
         self.avg is a rolling list of length <= 7 of steps where steps are
         defined as time elapsed divided by the total progress through
         self.length.

        """
    def update(self, n_steps):
        """
        Return a generator which yields the items added to the bar
                during construction, and updates the progress bar *after* the
                yielded block returns.
        
        """
def pager(generator, color=None):
    """
    Decide what method to use for paging through text.
    """
def _pipepager(generator, cmd, color):
    """
    Page through text by feeding it to another program.  Invoking a
        pager through this might support colors.
    
    """
def _tempfilepager(generator, cmd, color):
    """
    Page through text by invoking a program on a temporary file.
    """
def _nullpager(stream, generator, color):
    """
    Simply print unformatted text.  This is the ultimate fallback.
    """
def Editor(object):
    """
    .txt
    """
    def get_editor(self):
        """
        VISUAL
        """
    def edit_file(self, filename):
        """
        '{} "{}"'
        """
    def edit(self, text):
        """

        """
def open_url(url, wait=False, locate=False):
    """
    file://
    """
def _translate_ch_to_exc(ch):
    """
    u"\x03
    """
    def raw_terminal():
        """
         The function `getch` will return a bytes object corresponding to
         the pressed character. Since Windows 10 build 1803, it will also
         return \x00 when called a second time after pressing a regular key.

         `getwch` does not share this probably-bugged behavior. Moreover, it
         returns a Unicode object by default, which is what we want.

         Either of these functions will return \x00 or \xe0 to indicate
         a special key, and you need to call the same function again to get
         the "rest" of the code. The fun part is that \u00e0 is
         "latin small letter a with grave", so if you type that on a French
         keyboard, you _also_ get a \xe0.
         E.g., consider the Up arrow. This returns \xe0 and then \x48. The
         resulting Unicode string reads as "a with grave" + "capital H".
         This is indistinguishable from when the user actually types
         "a with grave" and then "capital H".

         When \xe0 is returned, we assume it's part of a special-key sequence
         and call `getwch` again, but that means that when the user types
         the \u00e0 character, `getchar` doesn't return until a second
         character is typed.
         The alternative is returning immediately, but that would mess up
         cross-platform handling of arrow keys and others that start with
         \xe0. Another option is using `getch`, but then we can't reliably
         read non-ASCII characters, because return values of `getch` are
         limited to the current 8-bit codepage.

         Anyway, Click doesn't claim to do this Right(tm), and using `getwch`
         is doing the right thing in more situations than with `getch`.

        """
    def raw_terminal():
        """
        /dev/tty
        """
    def getchar(echo):
        """
        replace
        """
