def formatannotation(annotation, base_module=None):
    """
    'builtins'
    """
def _get_user_defined_method(cls, method_name, *nested):
    """
     Once '__signature__' will be added to 'C'-level
     callables, this check won't be necessary

    """
def signature(obj):
    """
    '''Get a signature object for the passed callable.'''
    """
def _void(object):
    """
    '''A private marker - used in Parameter & Signature'''
    """
def _empty(object):
    """
    'name'
    """
    def __str__(self):
        """
        '<_ParameterKind: {0!r}>'
        """
def Parameter(object):
    """
    '''Represents a parameter in a function signature.

        Has the following public attributes:

        * name : str
            The name of the parameter as a string.
        * default : object
            The default value for the parameter if specified.  If the
            parameter has no default value, this attribute is not set.
        * annotation
            The annotation for the parameter if specified.  If the
            parameter has no annotation, this attribute is not set.
        * kind : str
            Describes how argument values are bound to the parameter.
            Possible values: `Parameter.POSITIONAL_ONLY`,
            `Parameter.POSITIONAL_OR_KEYWORD`, `Parameter.VAR_POSITIONAL`,
            `Parameter.KEYWORD_ONLY`, `Parameter.VAR_KEYWORD`.
        '''
    """
2021-03-02 20:48:02,246 : INFO : tokenize_signature : --> do i ever get here?
    def __init__(self, name, kind, default=_empty, annotation=_empty,
                 _partial_kwarg=False):
        """
        invalid value for 'Parameter.kind' attribute
        """
    def name(self):
        """
        '''Creates a customized copy of the Parameter.'''
        """
    def __str__(self):
        """
        ''
        """
    def __repr__(self):
        """
        '<{0} at {1:#x} {2!r}>'
        """
    def __hash__(self):
        """
        unhashable type: '{0}'
        """
    def __eq__(self, other):
        """
        '''Result of `Signature.bind` call.  Holds the mapping of arguments
            to the function's parameters.

            Has the following public attributes:

            * arguments : OrderedDict
                An ordered mutable mapping of parameters' names to arguments' values.
                Does not contain arguments' default values.
            * signature : Signature
                The Signature object that created this instance.
            * args : tuple
                Tuple of positional arguments values.
            * kwargs : dict
                Dict of keyword arguments values.
            '''
        """
    def __init__(self, signature, arguments):
        """
         Keyword arguments mapped by 'functools.partial'
         (Parameter._partial_kwarg is True) are mapped
         in 'BoundArguments.kwargs', along with VAR_KEYWORD &
         KEYWORD_ONLY

        """
    def kwargs(self):
        """
         **kwargs

        """
    def __hash__(self):
        """
        unhashable type: '{0}'
        """
    def __eq__(self, other):
        """
        '''A Signature object represents the overall signature of a function.
            It stores a Parameter object for each parameter accepted by the
            function, as well as information specific to the function itself.

            A Signature object has the following public attributes and methods:

            * parameters : OrderedDict
                An ordered mapping of parameters' names to the corresponding
                Parameter objects (keyword-only arguments are in the same order
                as listed in `code.co_varnames`).
            * return_annotation : object
                The annotation for the return type of the function if specified.
                If the function has no annotation for its return type, this
                attribute is not set.
            * bind(*args, **kwargs) -> BoundArguments
                Creates a mapping from positional and keyword arguments to
                parameters.
            * bind_partial(*args, **kwargs) -> BoundArguments
                Creates a partial mapping from positional and keyword arguments
                to parameters (simulating 'functools.partial' behavior.)
            '''
        """
2021-03-02 20:48:02,250 : INFO : tokenize_signature : --> do i ever get here?
    def __init__(self, parameters=None, return_annotation=_empty,
                 __validate_parameters__=True):
        """
        '''Constructs Signature from the given list of Parameter
                objects and 'return_annotation'.  All arguments are optional.
                '''
        """
    def from_function(cls, func):
        """
        '''Constructs Signature for the given python function'''
        """
    def parameters(self):
        """
        '''Creates a customized copy of the Signature.
                Pass 'parameters' and/or 'return_annotation' arguments
                to override them in the new copy.
                '''
        """
    def __hash__(self):
        """
        unhashable type: '{0}'
        """
    def __eq__(self, other):
        """
        '''Private method.  Don't use directly.'''
        """
    def bind(self, *args, **kwargs):
        """
        '''Get a BoundArguments object, that maps the passed `args`
                and `kwargs` to the function's signature.  Raises `TypeError`
                if the passed arguments can not be bound.
                '''
        """
    def bind_partial(self, *args, **kwargs):
        """
        '''Get a BoundArguments object, that partially maps the
                passed `args` and `kwargs` to the function's signature.
                Raises `TypeError` if the passed arguments can not be bound.
                '''
        """
    def __str__(self):
        """
         OK, we have an '*args'-like parameter, so we won't need
         a '*' to separate keyword-only arguments

        """
