def filefind(filename, path_dirs=None):
    """
    Find a file by looking through a sequence of paths.

        This iterates through a sequence of paths looking for a file and returns
        the full, absolute path of the first occurence of the file.  If no set of
        path dirs is given, the filename is tested as is, after running through
        :func:`expandvars` and :func:`expanduser`.  Thus a simple call::

            filefind('myfile.txt')

        will find the file in the current working dir, but::

            filefind('~/myfile.txt')

        Will find the file in the users home directory.  This function does not
        automatically try any paths, such as the cwd or the user's home directory.

        Parameters
        ----------
        filename : str
            The filename to look for.
        path_dirs : str, None or sequence of str
            The sequence of paths to look for the file in.  If None, the filename
            need to be absolute or be in the cwd.  If a string, the string is
            put into a sequence and the searched.  If a sequence, walk through
            each element and join with ``filename``, calling :func:`expandvars`
            and :func:`expanduser` before testing for existence.

        Returns
        -------
        Raises :exc:`IOError` or returns absolute path to file.
    
    """
def expand_path(s):
    """
    Expand $VARS and ~names in a string, like a shell

        :Examples:

           In [2]: os.environ['FOO']='test'

           In [3]: expand_path('variable FOO is $FOO')
           Out[3]: 'variable FOO is test'
    
    """
def link(src, dst):
    """
    Hard links ``src`` to ``dst``, returning 0 or errno.

        Note that the special errno ``ENOLINK`` will be returned if ``os.link`` isn't
        supported by the operating system.
    
    """
def link_or_copy(src, dst):
    """
    Attempts to hardlink ``src`` to ``dst``, copying if the link fails.

        Attempts to maintain the semantics of ``shutil.copy``.

        Because ``os.link`` does not overwrite files, a unique temporary file
        will be used if the target already exists, then that file will be moved
        into place.
    
    """
def ensure_dir_exists(path, mode=0o755):
    """
    ensure that a directory exists
    
        If it doesn't exist, try to create it and protect against a race condition
        if another process is doing the same.
    
        The default permissions are 755, which differ from os.makedirs default of 777.
    
    """
