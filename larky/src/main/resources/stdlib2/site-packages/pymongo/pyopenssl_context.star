def _is_ip_address(address):
    """
     According to the docs for Connection.send it can raise
     WantX509LookupError and should be retried.

    """
def _ragged_eof(exc):
    """
    Return True if the OpenSSL.SSL.SysCallError is a ragged EOF.
    """
def _sslConn(_SSL.Connection):
    """
    timed out
    """
    def do_handshake(self, *args, **kwargs):
        """
         Suppress ragged EOFs to match the stdlib.

        """
    def recv_into(self, *args, **kwargs):
        """
         Suppress ragged EOFs to match the stdlib.

        """
    def sendall(self, buf, flags=0):
        """
         XXX: It's not clear if this can actually happen. PyOpenSSL
         doesn't appear to have any interrupt handling, nor any interrupt
         errors for OpenSSL connections.

        """
def _CallbackData(object):
    """
    Data class which is passed to the OCSP callback.
    """
    def __init__(self):
        """
        A CPython compatible SSLContext implementation wrapping PyOpenSSL's
            context.
    
        """
    def __init__(self, protocol):
        """
         OCSP
         XXX: Find a better place to do this someday, since this is client
         side configuration and wrap_socket tries to support both client and
         server side sockets.

        """
    def protocol(self):
        """
        The protocol version chosen when constructing the context.
                This attribute is read-only.
        
        """
    def __get_verify_mode(self):
        """
        Whether to try to verify other peers' certificates and how to
                behave if verification fails. This attribute must be one of
                ssl.CERT_NONE, ssl.CERT_OPTIONAL or ssl.CERT_REQUIRED.
        
        """
    def __set_verify_mode(self, value):
        """
        Setter for verify_mode.
        """
        def _cb(connobj, x509obj, errnum, errdepth, retcode):
            """
             It seems we don't need to do anything here. Twisted doesn't,
             and OpenSSL's SSL_CTX_set_verify let's you pass NULL
             for the callback option. It's weird that PyOpenSSL requires
             this.

            """
    def __get_check_hostname(self):
        """
        check_hostname must be True or False
        """
    def __get_check_ocsp_endpoint(self):
        """
        check_ocsp must be True or False
        """
    def __get_options(self):
        """
         Calling set_options adds the option to the existing bitmask and
         returns the new bitmask.
         https://www.pyopenssl.org/en/stable/api/ssl.html#OpenSSL.SSL.Context.set_options

        """
    def __set_options(self, value):
        """
         Explcitly convert to int, since newer CPython versions
         use enum.IntFlag for options. The values are the same
         regardless of implementation.

        """
    def load_cert_chain(self, certfile, keyfile=None, password=None):
        """
        Load a private key and the corresponding certificate. The certfile
                string must be the path to a single file in PEM format containing the
                certificate as well as any number of CA certificates needed to
                establish the certificate's authenticity. The keyfile string, if
                present, must point to a file containing the private key. Otherwise
                the private key will be taken from certfile as well.
        
        """
            def _pwcb(max_length, prompt_twice, user_data):
                """
                 XXX:We could check the password length against what OpenSSL
                 tells us is the max, but we can't raise an exception, so...
                 warn?

                """
    def load_verify_locations(self, cafile=None, capath=None):
        """
        Load a set of "certification authority"(CA) certificates used to
                validate other peers' certificates when `~verify_mode` is other than
                ssl.CERT_NONE.
        
        """
    def set_default_verify_paths(self):
        """
        Specify that the platform provided CA certificates are to be used
                for verification purposes.
        """
2021-03-02 20:50:14,933 : INFO : tokenize_signature : --> do i ever get here?
2021-03-02 20:50:14,933 : INFO : tokenize_signature : --> do i ever get here?
2021-03-02 20:50:14,933 : INFO : tokenize_signature : --> do i ever get here?
    def wrap_socket(self, sock, server_side=False,
                    do_handshake_on_connect=True,
                    suppress_ragged_eofs=True,
                    server_hostname=None, session=None):
        """
        Wrap an existing Python socket sock and return a TLS socket
                object.
        
        """
