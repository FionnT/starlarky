def ConnectionPool(object):
    """

        Base class for all connection pools, such as
        :class:`.HTTPConnectionPool` and :class:`.HTTPSConnectionPool`.

        .. note::
           ConnectionPool.urlopen() does not normalize or percent-encode target URIs
           which is useful if your target server doesn't support percent-encoded
           target URIs.
    
    """
    def __init__(self, host, port=None):
        """
        No host specified.
        """
    def __str__(self):
        """
        %s(host=%r, port=%r)
        """
    def __enter__(self):
        """
         Return False to re-raise any potential exceptions

        """
    def close(self):
        """

                Close all pooled connections and disable the pool.
        
        """
def HTTPConnectionPool(ConnectionPool, RequestMethods):
    """

        Thread-safe connection pool for one host.

        :param host:
            Host used for this HTTP Connection (e.g. "localhost"), passed into
            :class:`httplib.HTTPConnection`.

        :param port:
            Port used for this HTTP Connection (None is equivalent to 80), passed
            into :class:`httplib.HTTPConnection`.

        :param strict:
            Causes BadStatusLine to be raised if the status line can't be parsed
            as a valid HTTP/1.0 or 1.1 status line, passed into
            :class:`httplib.HTTPConnection`.

            .. note::
               Only works in Python 2. This parameter is ignored in Python 3.

        :param timeout:
            Socket timeout in seconds for each individual connection. This can
            be a float or integer, which sets the timeout for the HTTP request,
            or an instance of :class:`urllib3.util.Timeout` which gives you more
            fine-grained control over request timeouts. After the constructor has
            been parsed, this is always a `urllib3.util.Timeout` object.

        :param maxsize:
            Number of connections to save that can be reused. More than 1 is useful
            in multithreaded situations. If ``block`` is set to False, more
            connections will be created but they will not be saved once they've
            been used.

        :param block:
            If set to True, no more than ``maxsize`` connections will be used at
            a time. When no free connections are available, the call will block
            until a connection has been released. This is a useful side effect for
            particular multithreaded situations where one does not want to use more
            than maxsize connections per host to prevent flooding.

        :param headers:
            Headers to include with all requests, unless other headers are given
            explicitly.

        :param retries:
            Retry configuration to use by default with requests in this pool.

        :param _proxy:
            Parsed proxy URL, should not be used directly, instead, see
            :class:`urllib3.connectionpool.ProxyManager`"

        :param _proxy_headers:
            A dictionary with proxy headers, should not be used directly,
            instead, see :class:`urllib3.connectionpool.ProxyManager`"

        :param \\**conn_kw:
            Additional parameters are used to create fresh :class:`urllib3.connection.HTTPConnection`,
            :class:`urllib3.connection.HTTPSConnection` instances.
    
    """
2021-03-02 20:52:24,452 : INFO : tokenize_signature : --> do i ever get here?
2021-03-02 20:52:24,452 : INFO : tokenize_signature : --> do i ever get here?
2021-03-02 20:52:24,452 : INFO : tokenize_signature : --> do i ever get here?
2021-03-02 20:52:24,452 : INFO : tokenize_signature : --> do i ever get here?
2021-03-02 20:52:24,452 : INFO : tokenize_signature : --> do i ever get here?
2021-03-02 20:52:24,452 : INFO : tokenize_signature : --> do i ever get here?
2021-03-02 20:52:24,452 : INFO : tokenize_signature : --> do i ever get here?
2021-03-02 20:52:24,453 : INFO : tokenize_signature : --> do i ever get here?
2021-03-02 20:52:24,453 : INFO : tokenize_signature : --> do i ever get here?
2021-03-02 20:52:24,453 : INFO : tokenize_signature : --> do i ever get here?
2021-03-02 20:52:24,453 : INFO : tokenize_signature : --> do i ever get here?
2021-03-02 20:52:24,453 : INFO : tokenize_signature : --> do i ever get here?
2021-03-02 20:52:24,453 : INFO : tokenize_signature : --> do i ever get here?
    def __init__(
        self,
        host,
        port=None,
        strict=False,
        timeout=Timeout.DEFAULT_TIMEOUT,
        maxsize=1,
        block=False,
        headers=None,
        retries=None,
        _proxy=None,
        _proxy_headers=None,
        **conn_kw
    ):
        """
         Fill the queue up so that doing get() on it will block properly

        """
    def _new_conn(self):
        """

                Return a fresh :class:`HTTPConnection`.
        
        """
    def _get_conn(self, timeout=None):
        """

                Get a connection. Will return a pooled connection if one is available.

                If no connections are available and :prop:`.block` is ``False``, then a
                fresh connection is returned.

                :param timeout:
                    Seconds to wait before giving up and raising
                    :class:`urllib3.exceptions.EmptyPoolError` if the pool is empty and
                    :prop:`.block` is ``True``.
        
        """
    def _put_conn(self, conn):
        """

                Put a connection back into the pool.

                :param conn:
                    Connection object for the current host and port as returned by
                    :meth:`._new_conn` or :meth:`._get_conn`.

                If the pool is already full, the connection is closed and discarded
                because we exceeded maxsize. If connections are discarded frequently,
                then maxsize should be increased.

                If the pool is closed, then the connection will be closed and discarded.
        
        """
    def _validate_conn(self, conn):
        """

                Called right before a request is made, after the socket is created.
        
        """
    def _prepare_proxy(self, conn):
        """
         Nothing to do for HTTP connections.

        """
    def _get_timeout(self, timeout):
        """
         Helper that always returns a :class:`urllib3.util.Timeout` 
        """
    def _raise_timeout(self, err, url, timeout_value):
        """
        Is the error actually a timeout? Will raise a ReadTimeout or pass
        """
2021-03-02 20:52:24,456 : INFO : tokenize_signature : --> do i ever get here?
2021-03-02 20:52:24,456 : INFO : tokenize_signature : --> do i ever get here?
    def _make_request(
        self, conn, method, url, timeout=_Default, chunked=False, **httplib_request_kw
    ):
        """

                Perform a request on a given urllib connection object taken from our
                pool.

                :param conn:
                    a connection from one of our connection pools

                :param timeout:
                    Socket timeout in seconds for the request. This can be a
                    float or integer, which will set the same timeout value for
                    the socket connect and the socket read, or an instance of
                    :class:`urllib3.util.Timeout`, which gives you more fine-grained
                    control over your timeouts.
        
        """
    def _absolute_url(self, path):
        """

                Close all pooled connections and disable the pool.
        
        """
    def is_same_host(self, url):
        """

                Check if the given ``url`` is a member of the same host as this
                connection pool.
        
        """
2021-03-02 20:52:24,459 : INFO : tokenize_signature : --> do i ever get here?
2021-03-02 20:52:24,459 : INFO : tokenize_signature : --> do i ever get here?
2021-03-02 20:52:24,459 : INFO : tokenize_signature : --> do i ever get here?
2021-03-02 20:52:24,459 : INFO : tokenize_signature : --> do i ever get here?
2021-03-02 20:52:24,460 : INFO : tokenize_signature : --> do i ever get here?
2021-03-02 20:52:24,460 : INFO : tokenize_signature : --> do i ever get here?
2021-03-02 20:52:24,460 : INFO : tokenize_signature : --> do i ever get here?
2021-03-02 20:52:24,460 : INFO : tokenize_signature : --> do i ever get here?
2021-03-02 20:52:24,460 : INFO : tokenize_signature : --> do i ever get here?
2021-03-02 20:52:24,460 : INFO : tokenize_signature : --> do i ever get here?
2021-03-02 20:52:24,460 : INFO : tokenize_signature : --> do i ever get here?
2021-03-02 20:52:24,460 : INFO : tokenize_signature : --> do i ever get here?
2021-03-02 20:52:24,460 : INFO : tokenize_signature : --> do i ever get here?
2021-03-02 20:52:24,460 : INFO : tokenize_signature : --> do i ever get here?
2021-03-02 20:52:24,460 : INFO : tokenize_signature : --> do i ever get here?
    def urlopen(
        self,
        method,
        url,
        body=None,
        headers=None,
        retries=None,
        redirect=True,
        assert_same_host=True,
        timeout=_Default,
        pool_timeout=None,
        release_conn=None,
        chunked=False,
        body_pos=None,
        **response_kw
    ):
        """

                Get a connection from the pool and perform an HTTP request. This is the
                lowest level call for making a request, so you'll need to specify all
                the raw details.

                .. note::

                   More commonly, it's appropriate to use a convenience method provided
                   by :class:`.RequestMethods`, such as :meth:`request`.

                .. note::

                   `release_conn` will only behave as expected if
                   `preload_content=False` because we want to make
                   `preload_content=False` the default behaviour someday soon without
                   breaking backwards compatibility.

                :param method:
                    HTTP request method (such as GET, POST, PUT, etc.)

                :param body:
                    Data to send in the request body (useful for creating
                    POST requests, see HTTPConnectionPool.post_url for
                    more convenience).

                :param headers:
                    Dictionary of custom headers to send, such as User-Agent,
                    If-None-Match, etc. If None, pool headers are used. If provided,
                    these headers completely replace any pool-specific headers.

                :param retries:
                    Configure the number of retries to allow before raising a
                    :class:`~urllib3.exceptions.MaxRetryError` exception.

                    Pass ``None`` to retry until you receive a response. Pass a
                    :class:`~urllib3.util.retry.Retry` object for fine-grained control
                    over different types of retries.
                    Pass an integer number to retry connection errors that many times,
                    but no other types of errors. Pass zero to never retry.

                    If ``False``, then retries are disabled and any exception is raised
                    immediately. Also, instead of raising a MaxRetryError on redirects,
                    the redirect response will be returned.

                :type retries: :class:`~urllib3.util.retry.Retry`, False, or an int.

                :param redirect:
                    If True, automatically handle redirects (status codes 301, 302,
                    303, 307, 308). Each redirect counts as a retry. Disabling retries
                    will disable redirect, too.

                :param assert_same_host:
                    If ``True``, will make sure that the host of the pool requests is
                    consistent else will raise HostChangedError. When False, you can
                    use the pool on an HTTP proxy and request foreign hosts.

                :param timeout:
                    If specified, overrides the default timeout for this one
                    request. It may be a float (in seconds) or an instance of
                    :class:`urllib3.util.Timeout`.

                :param pool_timeout:
                    If set and the pool is set to block=True, then this method will
                    block for ``pool_timeout`` seconds and raise EmptyPoolError if no
                    connection is available within the time period.

                :param release_conn:
                    If False, then the urlopen call will not release the connection
                    back into the pool once a response is received (but will release if
                    you read the entire contents of the response such as when
                    `preload_content=True`). This is useful if you're not preloading
                    the response's content immediately. You will need to call
                    ``r.release_conn()`` on the response ``r`` to return the connection
                    back into the pool. If None, it takes the value of
                    ``response_kw.get('preload_content', True)``.

                :param chunked:
                    If True, urllib3 will send the body using chunked transfer
                    encoding. Otherwise, urllib3 will send the body using the standard
                    content-length form. Defaults to False.

                :param int body_pos:
                    Position to seek to in file-like body in the event of a retry or
                    redirect. Typically this won't need to be set because urllib3 will
                    auto-populate the value when needed.

                :param \\**response_kw:
                    Additional parameters are passed to
                    :meth:`urllib3.response.HTTPResponse.from_httplib`
        
        """
def HTTPSConnectionPool(HTTPConnectionPool):
    """

        Same as :class:`.HTTPConnectionPool`, but HTTPS.

        When Python is compiled with the :mod:`ssl` module, then
        :class:`.VerifiedHTTPSConnection` is used, which *can* verify certificates,
        instead of :class:`.HTTPSConnection`.

        :class:`.VerifiedHTTPSConnection` uses one of ``assert_fingerprint``,
        ``assert_hostname`` and ``host`` in this order to verify connections.
        If ``assert_hostname`` is False, no verification is done.

        The ``key_file``, ``cert_file``, ``cert_reqs``, ``ca_certs``,
        ``ca_cert_dir``, ``ssl_version``, ``key_password`` are only used if :mod:`ssl`
        is available and are fed into :meth:`urllib3.util.ssl_wrap_socket` to upgrade
        the connection socket into an SSL socket.
    
    """
2021-03-02 20:52:24,465 : INFO : tokenize_signature : --> do i ever get here?
2021-03-02 20:52:24,465 : INFO : tokenize_signature : --> do i ever get here?
2021-03-02 20:52:24,465 : INFO : tokenize_signature : --> do i ever get here?
2021-03-02 20:52:24,465 : INFO : tokenize_signature : --> do i ever get here?
2021-03-02 20:52:24,465 : INFO : tokenize_signature : --> do i ever get here?
2021-03-02 20:52:24,465 : INFO : tokenize_signature : --> do i ever get here?
2021-03-02 20:52:24,465 : INFO : tokenize_signature : --> do i ever get here?
2021-03-02 20:52:24,465 : INFO : tokenize_signature : --> do i ever get here?
2021-03-02 20:52:24,465 : INFO : tokenize_signature : --> do i ever get here?
2021-03-02 20:52:24,465 : INFO : tokenize_signature : --> do i ever get here?
2021-03-02 20:52:24,465 : INFO : tokenize_signature : --> do i ever get here?
2021-03-02 20:52:24,466 : INFO : tokenize_signature : --> do i ever get here?
2021-03-02 20:52:24,466 : INFO : tokenize_signature : --> do i ever get here?
2021-03-02 20:52:24,466 : INFO : tokenize_signature : --> do i ever get here?
2021-03-02 20:52:24,466 : INFO : tokenize_signature : --> do i ever get here?
2021-03-02 20:52:24,466 : INFO : tokenize_signature : --> do i ever get here?
2021-03-02 20:52:24,466 : INFO : tokenize_signature : --> do i ever get here?
2021-03-02 20:52:24,466 : INFO : tokenize_signature : --> do i ever get here?
2021-03-02 20:52:24,466 : INFO : tokenize_signature : --> do i ever get here?
2021-03-02 20:52:24,466 : INFO : tokenize_signature : --> do i ever get here?
2021-03-02 20:52:24,466 : INFO : tokenize_signature : --> do i ever get here?
2021-03-02 20:52:24,466 : INFO : tokenize_signature : --> do i ever get here?
    def __init__(
        self,
        host,
        port=None,
        strict=False,
        timeout=Timeout.DEFAULT_TIMEOUT,
        maxsize=1,
        block=False,
        headers=None,
        retries=None,
        _proxy=None,
        _proxy_headers=None,
        key_file=None,
        cert_file=None,
        cert_reqs=None,
        key_password=None,
        ca_certs=None,
        ssl_version=None,
        assert_hostname=None,
        assert_fingerprint=None,
        ca_cert_dir=None,
        **conn_kw
    ):
        """

                Prepare the ``connection`` for :meth:`urllib3.util.ssl_wrap_socket`
                and establish the tunnel if proxy is used.
        
        """
    def _prepare_proxy(self, conn):
        """

                Establish tunnel connection early, because otherwise httplib
                would improperly set Host: header to proxy's IP:port.
        
        """
    def _new_conn(self):
        """

                Return a fresh :class:`httplib.HTTPSConnection`.
        
        """
    def _validate_conn(self, conn):
        """

                Called right before a request is made, after the socket is created.
        
        """
def connection_from_url(url, **kw):
    """

        Given a url, return an :class:`.ConnectionPool` instance of its host.

        This is a shortcut for not having to parse out the scheme, host, and port
        of the url before creating an :class:`.ConnectionPool` instance.

        :param url:
            Absolute URL string that must include the scheme. Port is optional.

        :param \\**kw:
            Passes additional parameters to the constructor of the appropriate
            :class:`.ConnectionPool`. Useful for specifying things like
            timeout, maxsize, headers, etc.

        Example::

            >>> conn = connection_from_url('http://google.com/')
            >>> r = conn.request('GET', '/')
    
    """
def _normalize_host(host, scheme):
    """

        Normalize hosts for comparisons and use with sockets.
    
    """
