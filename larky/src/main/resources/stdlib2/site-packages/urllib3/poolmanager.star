def _default_key_normalizer(key_class, request_context):
    """

        Create a pool key out of a request context dictionary.

        According to RFC 3986, both the scheme and host are case-insensitive.
        Therefore, this function normalizes both before constructing the pool
        key for an HTTPS request. If you wish to change this behaviour, provide
        alternate callables to ``key_fn_by_scheme``.

        :param key_class:
            The class to use when constructing the key. This should be a namedtuple
            with the ``scheme`` and ``host`` keys at a minimum.
        :type  key_class: namedtuple
        :param request_context:
            A dictionary-like object that contain the context for a request.
        :type  request_context: dict

        :return: A namedtuple that can be used as a connection pool key.
        :rtype:  PoolKey
    
    """
def PoolManager(RequestMethods):
    """

        Allows for arbitrary requests while transparently keeping track of
        necessary connection pools for you.

        :param num_pools:
            Number of connection pools to cache before discarding the least
            recently used pool.

        :param headers:
            Headers to include with all requests, unless other headers are given
            explicitly.

        :param \\**connection_pool_kw:
            Additional parameters are used to create fresh
            :class:`urllib3.connectionpool.ConnectionPool` instances.

        Example::

            >>> manager = PoolManager(num_pools=2)
            >>> r = manager.request('GET', 'http://google.com/')
            >>> r = manager.request('GET', 'http://google.com/mail')
            >>> r = manager.request('GET', 'http://yahoo.com/')
            >>> len(manager.pools)
            2

    
    """
    def __init__(self, num_pools=10, headers=None, **connection_pool_kw):
        """
         Locally set the pool classes and keys so other PoolManagers can
         override them.

        """
    def __enter__(self):
        """
         Return False to re-raise any potential exceptions

        """
    def _new_pool(self, scheme, host, port, request_context=None):
        """

                Create a new :class:`ConnectionPool` based on host, port, scheme, and
                any additional pool keyword arguments.

                If ``request_context`` is provided, it is provided as keyword arguments
                to the pool class used. This method is used to actually create the
                connection pools handed out by :meth:`connection_from_url` and
                companion methods. It is intended to be overridden for customization.
        
        """
    def clear(self):
        """

                Empty our store of pools and direct them all to close.

                This will not affect in-flight connections, but they will not be
                re-used after completion.
        
        """
    def connection_from_host(self, host, port=None, scheme="http", pool_kwargs=None):
        """

                Get a :class:`ConnectionPool` based on the host, port, and scheme.

                If ``port`` isn't given, it will be derived from the ``scheme`` using
                ``urllib3.connectionpool.port_by_scheme``. If ``pool_kwargs`` is
                provided, it is merged with the instance's ``connection_pool_kw``
                variable and used to create the new connection pool, if one is
                needed.
        
        """
    def connection_from_context(self, request_context):
        """

                Get a :class:`ConnectionPool` based on the request context.

                ``request_context`` must at least contain the ``scheme`` key and its
                value must be a key in ``key_fn_by_scheme`` instance variable.
        
        """
    def connection_from_pool_key(self, pool_key, request_context=None):
        """

                Get a :class:`ConnectionPool` based on the provided pool key.

                ``pool_key`` should be a namedtuple that only contains immutable
                objects. At a minimum it must have the ``scheme``, ``host``, and
                ``port`` fields.
        
        """
    def connection_from_url(self, url, pool_kwargs=None):
        """

                Similar to :func:`urllib3.connectionpool.connection_from_url`.

                If ``pool_kwargs`` is not provided and a new pool needs to be
                constructed, ``self.connection_pool_kw`` is used to initialize
                the :class:`urllib3.connectionpool.ConnectionPool`. If ``pool_kwargs``
                is provided, it is used instead. Note that if a new pool does not
                need to be created for the request, the provided ``pool_kwargs`` are
                not used.
        
        """
    def _merge_pool_kwargs(self, override):
        """

                Merge a dictionary of override values for self.connection_pool_kw.

                This does not modify self.connection_pool_kw and returns a new dict.
                Any keys in the override dictionary with a value of ``None`` are
                removed from the merged dictionary.
        
        """
    def urlopen(self, method, url, redirect=True, **kw):
        """

                Same as :meth:`urllib3.connectionpool.HTTPConnectionPool.urlopen`
                with custom cross-host redirect logic and only sends the request-uri
                portion of the ``url``.

                The given ``url`` parameter must be absolute, such that an appropriate
                :class:`urllib3.connectionpool.ConnectionPool` can be chosen for it.
        
        """
def ProxyManager(PoolManager):
    """

        Behaves just like :class:`PoolManager`, but sends all requests through
        the defined proxy, using the CONNECT method for HTTPS URLs.

        :param proxy_url:
            The URL of the proxy to be used.

        :param proxy_headers:
            A dictionary containing headers that will be sent to the proxy. In case
            of HTTP they are being sent with each request, while in the
            HTTPS/CONNECT case they are sent only once. Could be used for proxy
            authentication.

        Example:
            >>> proxy = urllib3.ProxyManager('http://localhost:3128/')
            >>> r1 = proxy.request('GET', 'http://google.com/')
            >>> r2 = proxy.request('GET', 'http://httpbin.org/')
            >>> len(proxy.pools)
            1
            >>> r3 = proxy.request('GET', 'https://httpbin.org/')
            >>> r4 = proxy.request('GET', 'https://twitter.com/')
            >>> len(proxy.pools)
            3

    
    """
2021-03-02 20:52:20,505 : INFO : tokenize_signature : --> do i ever get here?
2021-03-02 20:52:20,506 : INFO : tokenize_signature : --> do i ever get here?
2021-03-02 20:52:20,506 : INFO : tokenize_signature : --> do i ever get here?
2021-03-02 20:52:20,506 : INFO : tokenize_signature : --> do i ever get here?
2021-03-02 20:52:20,506 : INFO : tokenize_signature : --> do i ever get here?
2021-03-02 20:52:20,506 : INFO : tokenize_signature : --> do i ever get here?
2021-03-02 20:52:20,506 : INFO : tokenize_signature : --> do i ever get here?
    def __init__(
        self,
        proxy_url,
        num_pools=10,
        headers=None,
        proxy_headers=None,
        **connection_pool_kw
    ):
        """
        %s://%s:%i
        """
    def connection_from_host(self, host, port=None, scheme="http", pool_kwargs=None):
        """
        https
        """
    def _set_proxy_headers(self, url, headers=None):
        """

                Sets headers needed by proxies: specifically, the Accept and Host
                headers. Only sets headers not provided by the user.
        
        """
    def _validate_proxy_scheme_url_selection(self, url_scheme):
        """
        https
        """
    def urlopen(self, method, url, redirect=True, **kw):
        """
        Same as HTTP(S)ConnectionPool.urlopen, ``url`` must be absolute.
        """
def proxy_from_url(url, **kw):
