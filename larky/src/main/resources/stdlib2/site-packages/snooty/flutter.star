def HasAnnotations(Protocol):
    """
    _A
    """
def mapping_dict(Dict[str, Any]):
    """
    A dictionary that also contains source line information.
    """
def _Field:
    """
    A single field in a _TypeThunk.
    """
def _TypeThunk:
    """
    Type hints cannot be fully resolved at module runtime due to ForwardRefs. Instead,
           store the type here, and resolve type hints only when needed. By that time, hopefully all
           types have been declared.
    """
    def __init__(self, klass: Type[Any]) -> None:
        """
         This is gnarly. Sorry. For each field, store its default_factory if present; otherwise
         create a factory returning its default if present; otherwise None. Default parameter
         in the lambda is a ~~hack~~ to avoid messing up the variable binding.

        """
def _add_indefinite_article(s: str) -> str:
    """
    nothing
    """
def _get_typename(ty: type) -> str:
    """
    typing.
    """
def _pluralize(s: str) -> str:
    """
    s
    """
def _generate_hint(ty: type, get_description: Callable[[type], str]) -> str:
    """
    \n
    """
def english_description_of_type(ty: type) -> Tuple[str, Dict[type, str]]:
    """
    s
    """
def checked(klass: Type[_A]) -> Type[_A]:
    """
    Marks a dataclass as being deserializable.
    """
def LoadError(TypeError):
    """
    \n\n
    """
def LoadWrongArity(LoadWrongType):
    """
    'Unexpected field: "{}"'
    """
def check_type(ty: Type[_C], data: object) -> _C:
    """
     Check for a primitive type

    """
