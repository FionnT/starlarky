def _ClassifierDelimiterPatch:
    """
     Monkey patch out the docutils name mutatation. We handle this ourselves

    """
def parse_explicit_title(text: str) -> Tuple[str, Optional[str]]:
    """
    target
    """
def strip_parameters(target: str) -> str:
    """
    Remove trailing ALGOL-style parameters from a target name;
           e.g. foo(bar, baz) -> foo.
    """
def LegacyTabDefinition(nodes.Node):
    """
    Represents a Card within a CardGroup.

        Attributes:
            id          Unique identifier for the card, to be used as an anchor tag
            headline    Card title heading
            image       Path to an image used as the body of the card
            link        URL to be linked to by the card
    
    """
def CardGroupDefinition(nodes.Node):
    """
    A list of cards as specified in CardDefinition
    """
def directive_argument(docutils.nodes.General, docutils.nodes.TextElement):
    """
    Docutils node representing the title which should be used for refs to this node's
           parent target, if no explicit title is given.
    """
def directive(docutils.nodes.General, docutils.nodes.Element):
    """
    domain
    """
def target_directive(directive):
    """
    Docutils node representing a named target which can be referenced by the ref_role node.
    """
def code(docutils.nodes.General, docutils.nodes.FixedTextElement):
    """
    Docutils node representing a role.
    """
2021-03-02 20:52:16,510 : INFO : tokenize_signature : --> do i ever get here?
2021-03-02 20:52:16,511 : INFO : tokenize_signature : --> do i ever get here?
    def __init__(
        self, domain: str, name: str, lineno: int, target: Optional[str]
    ) -> None:
        """
        domain
        """
def ref_role(role):
    """
    Docutils node representing a reference to a reStructuredText target.
    """
def snooty_diagnostic(docutils.nodes.Element):
    """

    """
2021-03-02 20:52:16,511 : INFO : tokenize_signature : --> do i ever get here?
2021-03-02 20:52:16,511 : INFO : tokenize_signature : --> do i ever get here?
2021-03-02 20:52:16,511 : INFO : tokenize_signature : --> do i ever get here?
2021-03-02 20:52:16,511 : INFO : tokenize_signature : --> do i ever get here?
2021-03-02 20:52:16,511 : INFO : tokenize_signature : --> do i ever get here?
2021-03-02 20:52:16,512 : INFO : tokenize_signature : --> do i ever get here?
2021-03-02 20:52:16,512 : INFO : tokenize_signature : --> do i ever get here?
2021-03-02 20:52:16,512 : INFO : tokenize_signature : --> do i ever get here?
def handle_role_null(
    typ: str,
    rawtext: str,
    text: str,
    lineno: int,
    inliner: docutils.parsers.rst.states.Inliner,
    options: Dict[str, object] = {},
    content: List[object] = [],
) -> Tuple[List[docutils.nodes.Node], List[docutils.nodes.Node]]:
    """
    Handle unnamed roles by raising a warning.
    """
def TextRoleHandler:
    """
    Handle roles with plain text content.
    """
    def __init__(self, domain: str) -> None:
        """
        Handle link-like roles with a target and an optional title.
        """
    def __init__(self, domain: str) -> None:
        """
        Format a docutils node with a set of inline formatting roles.
        """
2021-03-02 20:52:16,514 : INFO : tokenize_signature : --> do i ever get here?
2021-03-02 20:52:16,514 : INFO : tokenize_signature : --> do i ever get here?
def layer_formatting(
    formatting: AbstractSet[specparser.FormattingType],
) -> Optional[docutils.nodes.Node]:
    """
    Create a nested sequence of formatting nodes.
    """
def RefRoleHandler:
    """

    """
def LinkRoleHandler:
    """
    Handle roles which generate a link from a template.
    """
2021-03-02 20:52:16,516 : INFO : tokenize_signature : --> do i ever get here?
2021-03-02 20:52:16,516 : INFO : tokenize_signature : --> do i ever get here?
    def __init__(
        self, url_template: str, format: AbstractSet[specparser.FormattingType]
    ) -> None:
        """
        rfc
        """
def parse_linenos(term: str, max_val: int) -> List[Tuple[int, int]]:
    """
    Parse a comma-delimited list of line numbers and ranges.
    """
def BaseDocutilsDirective(docutils.parsers.rst.Directive):
    """

    """
    def parse_argument(self, node: directive, source: str, line: int) -> None:
        """
        Parse the directive's argument.

                An argument spans from the 0th line to the first non-option line; this
                is a heuristic that is not part of docutils, since docutils requires
                each directive to define its syntax.
        
        """
    def add_name(self, node: docutils.nodes.Node) -> None:
        """
        Docutils by default will, if a "name" option is given to a directive,
                   change the shape of the node. We don't want that and it muddles up higher layers.
        """
    def parse_options(option: str) -> Iterable[Union[str, ValueError]]:
        """
        , 
        """
    def parse_date(date: str) -> Union[str, ValueError]:
        """
         Remove any leading blank lines.

        """
def BaseCardGroupDirective(BaseDocutilsDirective):
    """
    \n
    """
    def make_card_node(self, source: str, child: CardDefinition) -> docutils.nodes.Node:
        """
        Synthesize a new-style tab node out of a legacy (YAML) tab definition.
        """
def BaseTabsDirective(BaseDocutilsDirective):
    """
     Support the old-style tabset definition where the tabset is embedded in the
     directive's name.

    """
2021-03-02 20:52:16,526 : INFO : tokenize_signature : --> do i ever get here?
2021-03-02 20:52:16,526 : INFO : tokenize_signature : --> do i ever get here?
    def make_tab_node(
        self, tabid: str, title: Optional[str], source: str, child: LegacyTabDefinition
    ) -> docutils.nodes.Node:
        """
        Synthesize a new-style tab node out of a legacy (YAML) tab definition.
        """
def BaseCodeDirective(docutils.parsers.rst.Directive):
    """
    copyable
    """
def BaseVersionDirective(docutils.parsers.rst.Directive):
    """
    Special handling for version change directives.

        These directives include one required argument and an optional argument on the next line.
        We need to ensure that these are both included in the `argument` field of the AST, and that
        subsequent indented directives are included as children of the node.
    
    """
    def run(self) -> List[docutils.nodes.Node]:
        """

        """
def DeprecatedVersionDirective(BaseVersionDirective):
    """
    Variant of BaseVersionDirective for the deprecated directive, which does not
           require an argument.
    """
def BaseTocTreeDirective(docutils.parsers.rst.Directive):
    """
    Special handling for toctree directives.

        Produces a node that includes an `entries` property, represented as a list of objects. Each entry in entries includes:
        - slug OR url: a string representing the absolute url or path of the page to navigate to
        - [optional] title: a string representing the title to use in the TOC sidebar
    
    """
    def run(self) -> List[docutils.nodes.Node]:
        """

        """
2021-03-02 20:52:16,530 : INFO : tokenize_signature : --> do i ever get here?
2021-03-02 20:52:16,531 : INFO : tokenize_signature : --> do i ever get here?
    def make_toc_entry(
        self, source: str, child: str
    ) -> Tuple[Optional[n.TocTreeDirectiveEntry], List[docutils.nodes.Node]]:
        """
        Parse entry for either url or slug and optional title
        """
def NoTransformRstParser(docutils.parsers.rst.Parser):
    """
    _V
    """
def Domain:
    """
    Registry
    """
2021-03-02 20:52:16,533 : INFO : tokenize_signature : --> do i ever get here?
2021-03-02 20:52:16,533 : INFO : tokenize_signature : --> do i ever get here?
    def __init__(
        self, default_domain: Optional[str], domains: Dict[str, Domain]
    ) -> None:
        """
         Remove the built-in directives we don't want

        """
2021-03-02 20:52:16,534 : INFO : tokenize_signature : --> do i ever get here?
2021-03-02 20:52:16,534 : INFO : tokenize_signature : --> do i ever get here?
    def lookup_role(
        self, role_name: str, language_module: object, lineno: int, reporter: object
    ) -> Tuple[Optional[RoleHandler], List[object]]:
        """
        Unfortunately, the docutils API uses global state for dispatching directives
                   and roles. Bind the docutils dispatchers to this registry.
        """
    def get(cls, default_domain: Optional[str]) -> "Registry":
        """
        code-block
        """
2021-03-02 20:52:16,535 : INFO : tokenize_signature : --> do i ever get here?
2021-03-02 20:52:16,535 : INFO : tokenize_signature : --> do i ever get here?
2021-03-02 20:52:16,536 : INFO : tokenize_signature : --> do i ever get here?
2021-03-02 20:52:16,536 : INFO : tokenize_signature : --> do i ever get here?
2021-03-02 20:52:16,536 : INFO : tokenize_signature : --> do i ever get here?
def make_docutils_directive_handler(
    directive: specparser.Directive,
    base_class: Type[docutils.parsers.rst.Directive],
    name: str,
    options: Dict[str, object],
) -> Type[docutils.parsers.rst.Directive]:
    """
     type: ignore
    """
2021-03-02 20:52:16,537 : INFO : tokenize_signature : --> do i ever get here?
2021-03-02 20:52:16,537 : INFO : tokenize_signature : --> do i ever get here?
def register_spec_with_docutils(
    spec: specparser.Spec, default_domain: Optional[str]
) -> Registry:
    """
    Register all of the definitions in the spec with docutils, overwriting the previous
           call to this function. This function should only be called once in the
           process lifecycle.
    """
def Parser(Generic[_V]):
    """
    project_config
    """
    def __init__(self, project_config: ProjectConfig, visitor_class: Type[_V]) -> None:
