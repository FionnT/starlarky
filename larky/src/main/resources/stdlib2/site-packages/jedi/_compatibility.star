    def _DirEntry:
    """
     These are old-school clases that still have a different API, just
     ignore those.

    """
def find_module_py33(string, path=None, loader=None, full_name=None, is_global_search=True):
    """
     Fallback to find builtins
    """
def _from_loader(loader, string):
    """
     To avoid unicode and read bytes, "overwrite" loader.get_source if
     possible.

    """
def _get_source(loader, fullname):
    """

        This method is here as a replacement for SourceLoader.get_source. That
        method returns unicode, but we prefer bytes.
    
    """
def find_module_pre_py3(string, path=None, full_name=None, is_global_search=True):
    """
     This import is here, because in other places it will raise a
     DeprecationWarning.

    """
def ImplicitNSInfo(object):
    """
    Stores information returned from an implicit namespace spec
    """
    def __init__(self, name, paths):
        """
         Is deprecated and raises a warning in Python 3.6.

        """
    def reraise(exception, traceback):
        """

        def reraise(exception, traceback):
            raise exception, None, traceback

        """
def use_metaclass(meta, *bases):
    """
     Create a class with a metaclass. 
    """
def u(string, errors='strict'):
    """
    Cast to unicode DAMMIT!
        Written because Python2 repr always implicitly casts to a string, so we
        have to cast back to a unicode (and we now that we always deal with valid
        unicode, because we check that in the beginning).
    
    """
def cast_path(obj):
    """

        Take a bytes or str path and cast it to unicode.

        Apparently it is perfectly fine to pass both byte and unicode objects into
        the sys.path. This probably means that byte paths are normal at other
        places as well.

        Since this just really complicates everything and Python 2.7 will be EOL
        soon anyway, just go with always strings.
    
    """
def force_unicode(obj):
    """
     Intentionally don't mix those two up, because those two code paths might
     be different in the future (maybe windows?).

    """
def literal_eval(string):
    """
     Python 2  # noqa: F401
    """
    def NotADirectoryError(Exception):
    """
     Don't implement this for Python 2 anymore.

    """
def no_unicode_pprint(dct):
    """

        Python 2/3 dict __repr__ may be different, because of unicode differens
        (with or without a `u` prefix). Normally in doctests we could use `pprint`
        to sort dicts and check for equality, but here we have to write a separate
        function to do that.
    
    """
def utf8_repr(func):
    """

        ``__repr__`` methods in Python 2 don't allow unicode objects to be
        returned. Therefore cast them to utf-8 bytes in this decorator.
    
    """
    def wrapper(self):
        """
        'utf-8'
        """
def pickle_load(file):
    """
    'bytes'
    """
def _python2_dct_keys_to_unicode(data):
    """

        Python 2 stores object __dict__ entries as bytes, not unicode, correct it
        here. Python 2 can deal with both, Python 3 expects unicode.
    
    """
def pickle_dump(data, file, protocol):
    """
     On Python 3.3 flush throws sometimes an error even though the writing
     operation should be completed.

    """
def highest_pickle_protocol(python_versions):
    """
     The minimum protocol version for the versions of Python that we
     support (2.7 and 3.3+) is 2.

    """
    def Parameter(object):
    """
    'nt'
    """
def which(cmd, mode=os.F_OK | os.X_OK, path=None):
    """
    Given a command, mode, and a PATH string, return the path which
        conforms to the given mode on the PATH, or None if there is no such
        file.

        `mode` defaults to os.F_OK | os.X_OK. `path` defaults to the result
        of os.environ.get("PATH"), or can be overridden with a custom search
        path.

    
    """
    def _access_check(fn, mode):
        """
         If we're given a path with a directory part, look it up directly rather
         than referring to PATH directories. This includes checking relative to the
         current directory, e.g. ./script

        """
    def finalize(object):
    """
    Class for finalization of weakrefable objects.

            finalize(obj, func, *args, **kwargs) returns a callable finalizer
            object which will be called when obj is garbage collected. The
            first time the finalizer is called it evaluates func(*arg, **kwargs)
            and returns the result. After this the finalizer is dead, and
            calling it just returns None.

            When the program exits any remaining finalizers will be run.
        
    """
        def __init__(self, obj, func, *args, **kwargs):
            """
             To me it's an absolute mystery why in Python 2 we need _=None. It
             makes really no sense since it's never really called. Then again it
             might be called by Python 2.7 itself, but weakref.finalize is not
             documented in Python 2 and therefore shouldn't be randomly called.
             We never call this stuff with a parameter and therefore this
             parameter should not be needed. But it is. ~dave

            """
        def __call__(self, _=None):
            """
            Return func(*args, **kwargs) if alive.
            """
        def _exitfunc(cls):
            """
             Only Python >=3.6 does properly limit the amount of unwraps. This is very
             relevant in the case of unittest.mock.patch.
             Below is the implementation of Python 3.7.

            """
    def unwrap(func, stop=None):
        """
        Get the object wrapped by *func*.

               Follows the chain of :attr:`__wrapped__` attributes returning the last
               object in the chain.

               *stop* is an optional callback accepting an object in the wrapper chain
               as its sole argument that allows the unwrapping to be terminated early if
               the callback returns a true value. If the callback never returns a true
               value, the last object in the chain is returned as usual. For example,
               :func:`signature` uses this to stop unwrapping if any object in the
               chain has a ``__signature__`` attribute defined.

               :exc:`ValueError` is raised if a cycle is encountered.

        
        """
            def _is_wrapper(f):
                """
                '__wrapped__'
                """
            def _is_wrapper(f):
                """
                '__wrapped__'
                """
