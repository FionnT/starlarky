def InvalidPythonEnvironment(Exception):
    """

        If you see this exception, the Python executable or Virtualenv you have
        been trying to use is probably not a correct Python version.
    
    """
def _BaseEnvironment(object):
    """
    '%s.%s'
    """
    def _sha256(self):
        """

            This class is supposed to be created by internal Jedi architecture. You
            should not create it directly. Please use create_environment or the other
            functions instead. It is then returned by that function.
    
        """
    def __init__(self, executable, env_vars=None):
        """
         Initialize the environment

        """
    def _get_subprocess(self):
        """
        Could not get version information for %r: %r
        """
    def __repr__(self):
        """
        '.'
        """
    def get_inference_state_subprocess(self, inference_state):
        """

                The sys path for this environment. Does not include potential
                modifications from e.g. appending to :data:`sys.path`.

                :returns: list of str
        
        """
def _SameEnvironmentMixin(object):
    """
    'VIRTUAL_ENV'
    """
def _calculate_sha256_for_file(path):
    """
    'rb'
    """
def get_default_environment():
    """

        Tries to return an active Virtualenv or conda environment.
        If there is no VIRTUAL_ENV variable or no CONDA_PREFIX variable set
        set it will return the latest Python version installed on the system. This
        makes it possible to use as many new Python features as possible when using
        autocompletion and other functionality.

        :returns: :class:`.Environment`
    
    """
def _try_get_same_env():
    """
    'python'
    """
def get_cached_default_environment():
    """
    'VIRTUAL_ENV'
    """
def _get_cached_default_environment():
    """
     It's possible that `sys.executable` is wrong. Typically happens
     when Jedi is used in an executable that embeds Python. For further
     information, have a look at:
     https://github.com/davidhalter/jedi/issues/1531

    """
def find_virtualenvs(paths=None, **kwargs):
    """

        :param paths: A list of paths in your file system to be scanned for
            Virtualenvs. It will search in these paths and potentially execute the
            Python binaries.
        :param safe: Default True. In case this is False, it will allow this
            function to execute potential `python` environments. An attacker might
            be able to drop an executable in a path this function is searching by
            default. If the executable has not been installed by root, it will not
            be executed.
        :param use_environment_vars: Default True. If True, the VIRTUAL_ENV
            variable will be checked if it contains a valid VirtualEnv.
            CONDA_PREFIX will be checked to see if it contains a valid conda
            environment.

        :yields: :class:`.Environment`
    
    """
    def py27_comp(paths=None, safe=True, use_environment_vars=True):
        """
         Using this variable should be safe, because attackers might be
         able to drop files (via git) but not environment variables.

        """
def find_system_environments(**kwargs):
    """

        Ignores virtualenvs and returns the Python versions that were installed on
        your system. This might return nothing, if you're running Python e.g. from
        a portable version.

        The environments are sorted from latest to oldest Python version.

        :yields: :class:`.Environment`
    
    """
def get_system_environment(version, **kwargs):
    """

        Return the first Python environment found for a string of the form 'X.Y'
        where X and Y are the major and minor versions of Python.

        :raises: :exc:`.InvalidPythonEnvironment`
        :returns: :class:`.Environment`
    
    """
def create_environment(path, safe=True, **kwargs):
    """

        Make it possible to manually create an Environment object by specifying a
        Virtualenv path or an executable path and optional environment variables.

        :raises: :exc:`.InvalidPythonEnvironment`
        :returns: :class:`.Environment`

        TODO: make env_vars a kwarg when Python 2 is dropped. For now, preserve API
    
    """
def _create_environment(path, safe=True, env_vars=None):
    """

        Returns None if it's not actually a virtual env.
    
    """
def _get_executables_from_windows_registry(version):
    """
     The winreg module is named _winreg on Python 2.

    """
def _assert_safe(executable_path, safe):
    """
    The python binary is potentially unsafe.
    """
def _is_safe(executable_path):
    """
     Resolve sym links. A venv typically is a symlink to a known Python
     binary. Only virtualenvs copy symlinks around.

    """
def _is_unix_safe_simple(real_path):
    """
     In case we are root, just be conservative and
     only execute known paths.

    """
def _is_unix_admin():
    """
     Windows
    """
