def _start_match(string, like_name):
    """
     Note: `or ''` below is required because `module_path` could be

    """
def get_on_completion_name(module_node, lines, position):
    """
    'string'
    """
def _get_code(code_lines, start_pos, end_pos):
    """
     Get relevant lines.

    """
def OnErrorLeaf(Exception):
    """
     It might happen that we're on whitespace or on a comment. This means
     that we would not get the right leaf.

    """
def get_stack_at_position(grammar, code_lines, leaf, pos):
    """

        Returns the possible node names (e.g. import_from, xor_test or yield_stmt).
    
    """
    def EndMarkerReached(Exception):
    """
     TODO This is for now not an official parso API that exists purely
       for Jedi.

    """
def infer(inference_state, context, leaf):
    """
    'name'
    """
def filter_follow_imports(names, follow_builtin_imports=False):
    """
    'bracket_leaf'
    """
    def index(self):
        """
         For now do nothing, we don't know what's in there here.
        """
    def iter_used_keyword_arguments(self):
        """
        'name'
        """
def _get_index_and_key(nodes, position):
    """

        Returns the amount of commas and the keyword argument string.
    
    """
def _get_signature_details_from_error_node(node, additional_children, position):
    """
     `index > 0` means that it's a trailer and not an atom.

    """
def get_signature_details(module, position):
    """
     It's easier to deal with the previous token than the next one in this
     case.

    """
def cache_signatures(inference_state, context, bracket_leaf, code_lines, user_pos):
    """
    This function calculates the cache key.
    """
def validate_line_column(func):
    """
    '`line` parameter is not in a valid range.'
    """
def get_module_names(module, all_scopes, definitions=True, references=False):
    """

        Returns a dictionary with name parts as keys and their call paths as
        values.
    
    """
    def def_ref_filter(name):
        """
         We have to filter all the names that don't have the module as a
         parent_scope. There's None as a parent, because nodes in the module
         node have the parent module and not suite as all the others.
         Therefore it's important to catch that case.


        """
        def is_module_scope_name(name):
            """
             async functions have an extra wrapper. Strip it.

            """
def split_search_string(name):
    """
    ' '
    """
