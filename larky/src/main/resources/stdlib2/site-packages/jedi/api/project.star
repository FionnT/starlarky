def _try_to_skip_duplicates(func):
    """
    'module'
    """
def _remove_duplicates_from_path(path):
    """

        Projects are a simple way to manage Python folders and define how Jedi does
        import resolution. It is mostly used as a parameter to :class:`.Script`.
        Additionally there are functions to search a whole project.
    
    """
    def _get_config_folder_path(base_path):
        """
        'project.json'
        """
    def load(cls, path):
        """

                Loads a project from a specific path. You should not provide the path
                to ``.jedi/project.json``, but rather the path to the project folder.

                :param path: The path of the directory you want to use as a project.
        
        """
    def save(self):
        """

                Saves the project configuration in the project in ``.jedi/project.json``.
        
        """
    def __init__(self, path, **kwargs):
        """

                :param path: The base path for this project.
                :param environment_path: The Python executable path, typically the path
                    of a virtual environment.
                :param load_unsafe_extensions: Default False, Loads extensions that are not in the
                    sys path and in the local directories. With this option enabled,
                    this is potentially unsafe if you clone a git repository and
                    analyze it's code, because those compiled extensions will be
                    important and therefore have execution privileges.
                :param sys_path: list of str. You can override the sys path if you
                    want. By default the ``sys.path.`` is generated by the
                    environment (virtualenvs, etc).
                :param added_sys_path: list of str. Adds these paths at the end of the
                    sys path.
                :param smart_sys_path: If this is enabled (default), adds paths from
                    local directories. Otherwise you will have to rely on your packages
                    being properly configured on the ``sys.path``.
        
        """
2021-03-02 20:49:51,264 : INFO : tokenize_signature : --> do i ever get here?
        def py2_comp(path, environment_path=None, load_unsafe_extensions=False,
                     sys_path=None, added_sys_path=(), smart_sys_path=True):
            """
            The sys path that is going to be added at the end of the 
            """
    def path(self):
        """

                The base path for this project.
        
        """
    def _get_base_sys_path(self, inference_state):
        """
         The sys path has not been set explicitly.

        """
    def _get_sys_path(self, inference_state, add_parent_paths=True, add_init_paths=False):
        """

                Keep this method private for all users of jedi. However internally this
                one is used like a public method.
        
        """
    def get_environment(self):
        """

                Searches a name in the whole project. If the project is very big,
                at some point Jedi will stop searching. However it's also very much
                recommended to not exhaust the generator. Just display the first ten
                results to the user.

                There are currently three different search patterns:

                - ``foo`` to search for a definition foo in any file or a file called
                  ``foo.py`` or ``foo.pyi``.
                - ``foo.bar`` to search for the ``foo`` and then an attribute ``bar``
                  in it.
                - ``class foo.bar.Bar`` or ``def foo.bar.baz`` to search for a specific
                  API type.

                :param bool all_scopes: Default False; searches not only for
                    definitions on the top level of a module level, but also in
                    functions and classes.
                :yields: :class:`.Name`
        
        """
    def complete_search(self, string, **kwargs):
        """

                Like :meth:`.Script.search`, but completes that string. An empty string
                lists all definitions in a project, so be careful with that.

                :param bool all_scopes: Default False; searches not only for
                    definitions on the top level of a module level, but also in
                    functions and classes.
                :yields: :class:`.Completion`
        
        """
    def _search(self, string, all_scopes=False):  # Python 2..
        """
         Python 2..
        """
    def _search_func(self, string, complete=False, all_scopes=False):
        """
         Using a Script is they easiest way to get an empty module context.

        """
    def __repr__(self):
        """
        '<%s: %s>'
        """
def _is_potential_project(path):
    """
     Detects the path of the very well known Django library (if used) 
    """
def get_default_project(path=None):
    """

        If a project is not defined by the user, Jedi tries to define a project by
        itself as well as possible. Jedi traverses folders until it finds one of
        the following:

        1. A ``.jedi/config.json``
        2. One of the following files: ``setup.py``, ``.git``, ``.hg``,
           ``requirements.txt`` and ``MANIFEST.in``.
    
    """
def _remove_imports(names):
    """
    'module'

    """
