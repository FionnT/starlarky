def _sort_names_by_start_pos(names):
    """

        List sub-definitions (e.g., methods in class).

        :type scope: Scope
        :rtype: list of Name
    
    """
def _values_to_definitions(values):
    """

        The base class for all definitions, completions and signatures.
    
    """
    def __init__(self, inference_state, name):
        """

                An instance of :class:`parso.python.tree.Name` subclass.
        
        """
    def _get_module_context(self):
        """
         This can take a while to complete, because in the worst case of
         imports (consider `import a` completions), we need to load all
         modules starting with a first.

        """
    def module_path(self):
        """

                Shows the file path of a module. e.g. ``/usr/lib/python2.7/os.py``

                :rtype: str or None
        
        """
    def name(self):
        """

                Name of variable/function/class/module.

                For example, for ``x = None`` it returns ``'x'``.

                :rtype: str or None
        
        """
    def type(self):
        """

                The type of the definition.

                Here is an example of the value of this attribute.  Let's consider
                the following source.  As what is in ``variable`` is unambiguous
                to Jedi, :meth:`jedi.Script.infer` should return a list of
                definition for ``sys``, ``f``, ``C`` and ``x``.

                >>> from jedi._compatibility import no_unicode_pprint
                >>> from jedi import Script
                >>> source = '''
                ... import keyword
                ...
                ... class C:
                ...     pass
                ...
                ... class D:
                ...     pass
                ...
                ... x = D()
                ...
                ... def f():
                ...     pass
                ...
                ... for variable in [keyword, f, C, x]:
                ...     variable'''

                >>> script = Script(source)
                >>> defs = script.infer()

                Before showing what is in ``defs``, let's sort it by :attr:`line`
                so that it is easy to relate the result to the source code.

                >>> defs = sorted(defs, key=lambda d: d.line)
                >>> no_unicode_pprint(defs)  # doctest: +NORMALIZE_WHITESPACE
                [<Name full_name='keyword', description='module keyword'>,
                 <Name full_name='__main__.C', description='class C'>,
                 <Name full_name='__main__.D', description='instance D'>,
                 <Name full_name='__main__.f', description='def f'>]

                Finally, here is what you can get from :attr:`type`:

                >>> defs = [str(d.type) for d in defs]  # It's unicode and in Py2 has u before it.
                >>> defs[0]
                'module'
                >>> defs[1]
                'class'
                >>> defs[2]
                'instance'
                >>> defs[3]
                'function'

                Valid values for type are ``module``, ``class``, ``instance``, ``function``,
                ``param``, ``path``, ``keyword`` and ``statement``.

        
        """
    def module_name(self):
        """

                The module name, a bit similar to what ``__name__`` is in a random
                Python module.

                >>> from jedi import Script
                >>> source = 'import json'
                >>> script = Script(source, path='example.py')
                >>> d = script.infer()[0]
                >>> print(d.module_name)  # doctest: +ELLIPSIS
                json
        
        """
    def in_builtin_module(self):
        """

                Returns True, if this is a builtin module.
        
        """
    def line(self):
        """
        The line where the definition occurs (starting with 1).
        """
    def column(self):
        """
        The column where the definition occurs (starting with 0).
        """
    def get_definition_start_position(self):
        """

                The (row, column) of the start of the definition range. Rows start with
                1, columns start with 0.

                :rtype: Optional[Tuple[int, int]]
        
        """
    def get_definition_end_position(self):
        """

                The (row, column) of the end of the definition range. Rows start with
                1, columns start with 0.

                :rtype: Optional[Tuple[int, int]]
        
        """
    def docstring(self, raw=False, fast=True):
        """
        r"""
                Return a document string for this completion object.

                Example:

                >>> from jedi import Script
                >>> source = '''\
                ... def f(a, b=1):
                ...     "Document for function f."
                ... '''
                >>> script = Script(source, path='example.py')
                >>> doc = script.infer(1, len('def f'))[0].docstring()
                >>> print(doc)
                f(a, b=1)
                <BLANKLINE>
                Document for function f.

                Notice that useful extra information is added to the actual
                docstring, e.g. function signatures are prepended to their docstrings.
                If you need the actual docstring, use ``raw=True`` instead.

                >>> print(script.infer(1, len('def f'))[0].docstring(raw=True))
                Document for function f.

                :param fast: Don't follow imports that are only one level deep like
                    ``import foo``, but follow ``from foo import bar``. This makes
                    sense for speed reasons. Completing `import a` is slow if you use
                    the ``foo.docstring(fast=False)`` on every object, because it
                    parses all libraries starting with ``a``.
        
        """
    def _get_docstring(self):
        """
        '\n'
        """
    def description(self):
        """

                A description of the :class:`.Name` object, which is heavily used
                in testing. e.g. for ``isinstance`` it returns ``def isinstance``.

                Example:

                >>> from jedi._compatibility import no_unicode_pprint
                >>> from jedi import Script
                >>> source = '''
                ... def f():
                ...     pass
                ...
                ... class C:
                ...     pass
                ...
                ... variable = f if random.choice([0,1]) else C'''
                >>> script = Script(source)  # line is maximum by default
                >>> defs = script.infer(column=3)
                >>> defs = sorted(defs, key=lambda d: d.line)
                >>> no_unicode_pprint(defs)  # doctest: +NORMALIZE_WHITESPACE
                [<Name full_name='__main__.f', description='def f'>,
                 <Name full_name='__main__.C', description='class C'>]
                >>> str(defs[0].description)  # strip literals in python2
                'def f'
                >>> str(defs[1].description)
                'class C'

        
        """
    def full_name(self):
        """

                Dot-separated path of this object.

                It is in the form of ``<module>[.<submodule>[...]][.<object>]``.
                It is useful when you want to look up Python manual of the
                object at hand.

                Example:

                >>> from jedi import Script
                >>> source = '''
                ... import os
                ... os.path.join'''
                >>> script = Script(source, path='example.py')
                >>> print(script.infer(3, len('os.path.join'))[0].full_name)
                os.path.join

                Notice that it returns ``'os.path.join'`` instead of (for example)
                ``'posixpath.join'``. This is not correct, since the modules name would
                be ``<module 'posixpath' ...>```. However most users find the latter
                more practical.
        
        """
    def is_stub(self):
        """

                Returns True if the current name is defined in a stub file.
        
        """
    def is_side_effect(self):
        """

                Checks if a name is defined as ``self.foo = 3``. In case of self, this
                function would return False, for foo it would return True.
        
        """
    def goto(self, **kwargs):
        """

                Like :meth:`.Script.goto` (also supports the same params), but does it
                for the current name. This is typically useful if you are using
                something like :meth:`.Script.get_names()`.

                :param follow_imports: The goto call will follow imports.
                :param follow_builtin_imports: If follow_imports is True will try to
                    look up names in builtins (i.e. compiled or extension modules).
                :param only_stubs: Only return stubs for this goto call.
                :param prefer_stubs: Prefer stubs to Python objects for this goto call.
                :rtype: list of :class:`Name`
        
        """
    def goto_assignments(self, **kwargs):  # Python 2...
        """
         Python 2...
        """
2021-03-02 20:49:50,363 : INFO : tokenize_signature : --> do i ever get here?
    def _goto(self, follow_imports=False, follow_builtin_imports=False,
              only_stubs=False, prefer_stubs=False):
        """
         Python 2...
        """
    def _infer(self, only_stubs=False, prefer_stubs=False):
        """
         First we need to make sure that we have stub names (if possible) that
         we can follow. If we don't do that, we can end up with the inferred
         results of Python objects instead of stubs.

        """
    def params(self):
        """
        Deprecated since version 0.16.0. Use get_signatures()[...].params
        """
    def parent(self):
        """

                Returns the parent scope of this identifier.

                :rtype: Name
        
        """
    def __repr__(self):
        """
        <%s %sname=%r, description=%r>
        """
    def get_line_code(self, before=0, after=0):
        """

                Returns the line of code where this object was defined.

                :param before: Add n lines before the current line to the output.
                :param after: Add n lines after the current line to the output.

                :return str: Returns the line(s) of code or an empty string if it's a
                             builtin.
        
        """
    def _get_signatures(self, for_docstring=False):
        """
        'statement'
        """
    def get_signatures(self):
        """

                Returns all potential signatures for a function or a class. Multiple
                signatures are typical if you use Python stubs with ``@overload``.

                :rtype: list of :class:`BaseSignature`
        
        """
    def execute(self):
        """

                Uses type inference to "execute" this identifier and returns the
                executed objects.

                :rtype: list of :class:`Name`
        
        """
    def get_type_hint(self):
        """

                Returns type hints like ``Iterable[int]`` or ``Union[int, str]``.

                This method might be quite slow, especially for functions. The problem
                is finding executions for those functions to return something like
                ``Callable[[int, str], str]``.

                :rtype: str
        
        """
def Completion(BaseName):
    """

        ``Completion`` objects are returned from :meth:`.Script.complete`. They
        provide additional information about a completion.
    
    """
2021-03-02 20:49:50,367 : INFO : tokenize_signature : --> do i ever get here?
    def __init__(self, inference_state, name, stack, like_name_length,
                 is_fuzzy, cached_name=None):
        """
         Completion objects with the same Completion name (which means
         duplicate items in the completion)

        """
    def _complete(self, like_name):
        """
        ''
        """
    def complete(self):
        """

                Only works with non-fuzzy completions. Returns None if fuzzy
                completions are used.

                Return the rest of the word, e.g. completing ``isinstance``::

                    isinstan# <-- Cursor is here

                would return the string 'ce'. It also adds additional stuff, depending
                on your ``settings.py``.

                Assuming the following function definition::

                    def foo(param=0):
                        pass

                completing ``foo(par`` would give a ``Completion`` which ``complete``
                would be ``am=``.
        
        """
    def name_with_symbols(self):
        """

                Similar to :attr:`.name`, but like :attr:`.name` returns also the
                symbols, for example assuming the following function definition::

                    def foo(param=0):
                        pass

                completing ``foo(`` would give a ``Completion`` which
                ``name_with_symbols`` would be "param=".

        
        """
    def docstring(self, raw=False, fast=True):
        """

                Documented under :meth:`BaseName.docstring`.
        
        """
    def _get_docstring(self):
        """

                Documented under :meth:`BaseName.type`.
        
        """
    def __repr__(self):
        """
        '<%s: %s>'
        """
def Name(BaseName):
    """

        *Name* objects are returned from many different APIs including
        :meth:`.Script.goto` or :meth:`.Script.infer`.
    
    """
    def __init__(self, inference_state, definition):
        """
        Deprecated since version 0.17.0. No replacement for now, maybe .full_name helps
        """
    def defined_names(self):
        """

                List sub-definitions (e.g., methods in class).

                :rtype: list of :class:`Name`
        
        """
    def is_definition(self):
        """

                Returns True, if defined as a name in a statement, function or class.
                Returns False, if it's a reference to such a definition.
        
        """
    def __eq__(self, other):
        """

            These signatures are returned by :meth:`BaseName.get_signatures`
            calls.
    
        """
    def __init__(self, inference_state, signature):
        """

                Returns definitions for all parameters that a signature defines.
                This includes stuff like ``*args`` and ``**kwargs``.

                :rtype: list of :class:`.ParamName`
        
        """
    def to_string(self):
        """

                Returns a text representation of the signature. This could for example
                look like ``foo(bar, baz: int, **kwargs)``.

                :rtype: str
        
        """
def Signature(BaseSignature):
    """

        A full signature object is the return value of
        :meth:`.Script.get_signatures`.
    
    """
    def __init__(self, inference_state, signature, call_details):
        """

                Returns the param index of the current cursor position.
                Returns None if the index cannot be found in the curent call.

                :rtype: int
        
        """
    def bracket_start(self):
        """

                Returns a line/column tuple of the bracket that is responsible for the
                last function call. The first line is 1 and the first column 0.

                :rtype: int, int
        
        """
    def __repr__(self):
        """
        '<%s: index=%r %s>'
        """
def ParamName(Name):
    """

            Returns default values like the ``1`` of ``def foo(x=1):``.

            :rtype: list of :class:`.Name`
        
    """
    def infer_annotation(self, **kwargs):
        """

                :param execute_annotation: Default True; If False, values are not
                    executed and classes are returned instead of instances.
                :rtype: list of :class:`.Name`
        
        """
    def to_string(self):
        """

                Returns a simple representation of a param, like
                ``f: Callable[..., Any]``.

                :rtype: str
        
        """
    def kind(self):
        """

                Returns an enum instance of :mod:`inspect`'s ``Parameter`` enum.

                :rtype: :py:attr:`inspect.Parameter.kind`
        
        """
