def _no_python2_support(func):
    """
     TODO remove when removing Python 2/3.5

    """
    def wrapper(self, *args, **kwargs):
        """
        No support for refactorings/search on Python 2/3.5

        """
def Script(object):
    """

        A Script is the base for completions, goto or whatever you want to do with
        Jedi. The counter part of this class is :class:`Interpreter`, which works
        with actual dictionaries and can work with a REPL. This class
        should be used when a user edits code in an editor.

        You can either use the ``code`` parameter or ``path`` to read a file.
        Usually you're going to want to use both of them (in an editor).

        The Script's ``sys.path`` is very customizable:

        - If `project` is provided with a ``sys_path``, that is going to be used.
        - If `environment` is provided, its ``sys.path`` will be used
          (see :func:`Environment.get_sys_path <jedi.api.environment.Environment.get_sys_path>`);
        - Otherwise ``sys.path`` will match that of the default environment of
          Jedi, which typically matches the sys path that was used at the time
          when Jedi was imported.

        Most methods have a ``line`` and a ``column`` parameter. Lines in Jedi are
        always 1-based and columns are always zero based. To avoid repetition they
        are not always documented. You can omit both line and column. Jedi will
        then just do whatever action you are calling at the end of the file. If you
        provide only the line, just will complete at the end of that line.

        .. warning:: By default :attr:`jedi.settings.fast_parser` is enabled, which means
            that parso reuses modules (i.e. they are not immutable). With this setting
            Jedi is **not thread safe** and it is also not safe to use multiple
            :class:`.Script` instances and its definitions at the same time.

            If you are a normal plugin developer this should not be an issue. It is
            an issue for people that do more complex stuff with Jedi.

            This is purely a performance optimization and works pretty well for all
            typical usages, however consider to turn the setting off if it causes
            you problems. See also
            `this discussion <https://github.com/davidhalter/jedi/issues/1240>`_.

        :param code: The source code of the current file, separated by newlines.
        :type code: str
        :param line: Deprecated, please use it directly on e.g. ``.complete``
        :type line: int
        :param column: Deprecated, please use it directly on e.g. ``.complete``
        :type column: int
        :param path: The path of the file in the file system, or ``''`` if
            it hasn't been saved yet.
        :type path: str or None
        :param encoding: Deprecated, cast to unicode yourself. The encoding of
            ``code``, if it is not a ``unicode`` object (default ``'utf-8'``).
        :type encoding: str
        :param sys_path: Deprecated, use the project parameter.
        :type sys_path: typing.List[str]
        :param Environment environment: Provide a predefined :ref:`Environment <environments>`
            to work with a specific Python version or virtualenv.
        :param Project project: Provide a :class:`.Project` to make sure finding
            references works well, because the right folder is searched. There are
            also ways to modify the sys path and other things.
    
    """
2021-03-02 20:49:49,293 : INFO : tokenize_signature : --> do i ever get here?
2021-03-02 20:49:49,293 : INFO : tokenize_signature : --> do i ever get here?
    def __init__(self, code=None, line=None, column=None, path=None,
                 encoding=None, sys_path=None, environment=None,
                 project=None, source=None):
        """
         An empty path (also empty string) should always result in no path.

        """
    def _get_module(self):
        """
        '.pyi'
        """
    def _get_module_context(self):
        """
        '<%s: %s %r>'
        """
    def complete(self, line=None, column=None, **kwargs):
        """

                Completes objects under the cursor.

                Those objects contain information about the completions, more than just
                names.

                :param fuzzy: Default False. Will return fuzzy completions, which means
                    that e.g. ``ooa`` will match ``foobar``.
                :return: Completion objects, sorted by name. Normal names appear
                    before "private" names that start with ``_`` and those appear
                    before magic methods and name mangled names that start with ``__``.
                :rtype: list of :class:`.Completion`
        
        """
    def _complete(self, line, column, fuzzy=False):  # Python 2...
        """
         Python 2...
        """
    def completions(self, fuzzy=False):
        """
        Deprecated since version 0.16.0. Use Script(...).complete instead.
        """
    def infer(self, line=None, column=None, **kwargs):
        """

                Return the definitions of under the cursor. It is basically a wrapper
                around Jedi's type inference.

                This method follows complicated paths and returns the end, not the
                first definition. The big difference between :meth:`goto` and
                :meth:`infer` is that :meth:`goto` doesn't
                follow imports and statements. Multiple objects may be returned,
                because depending on an option you can have two different versions of a
                function.

                :param only_stubs: Only return stubs for this method.
                :param prefer_stubs: Prefer stubs to Python objects for this method.
                :rtype: list of :class:`.Name`
        
        """
    def goto_definitions(self, **kwargs):
        """
        Deprecated since version 0.16.0. Use Script(...).infer instead.
        """
    def _infer(self, line, column, only_stubs=False, prefer_stubs=False):
        """
        'string'
        """
    def goto_assignments(self, follow_imports=False, follow_builtin_imports=False, **kwargs):
        """
        Deprecated since version 0.16.0. Use Script(...).goto instead.
        """
    def goto(self, line=None, column=None, **kwargs):
        """

                Goes to the name that defined the object under the cursor. Optionally
                you can follow imports.
                Multiple objects may be returned, depending on an if you can have two
                different versions of a function.

                :param follow_imports: The method will follow imports.
                :param follow_builtin_imports: If ``follow_imports`` is True will try
                    to look up names in builtins (i.e. compiled or extension modules).
                :param only_stubs: Only return stubs for this method.
                :param prefer_stubs: Prefer stubs to Python objects for this method.
                :rtype: list of :class:`.Name`
        
        """
2021-03-02 20:49:49,299 : INFO : tokenize_signature : --> do i ever get here?
    def _goto(self, line, column, follow_imports=False, follow_builtin_imports=False,
              only_stubs=False, prefer_stubs=False):
        """
         Without a name we really just want to jump to the result e.g.
         executed by `foo()`, if we the cursor is after `)`.

        """
    def search(self, string, **kwargs):
        """

                Searches a name in the current file. For a description of how the
                search string should look like, please have a look at
                :meth:`.Project.search`.

                :param bool all_scopes: Default False; searches not only for
                    definitions on the top level of a module level, but also in
                    functions and classes.
                :yields: :class:`.Name`
        
        """
    def _search(self, string, all_scopes=False):
        """

                Like :meth:`.Script.search`, but completes that string. If you want to
                have all possible definitions in a file you can also provide an empty
                string.

                :param bool all_scopes: Default False; searches not only for
                    definitions on the top level of a module level, but also in
                    functions and classes.
                :param fuzzy: Default False. Will return fuzzy completions, which means
                    that e.g. ``ooa`` will match ``foobar``.
                :yields: :class:`.Completion`
        
        """
    def help(self, line=None, column=None):
        """

                Used to display a help window to users.  Uses :meth:`.Script.goto` and
                returns additional definitions for keywords and operators.

                Typically you will want to display :meth:`.BaseName.docstring` to the
                user for all the returned definitions.

                The additional definitions are ``Name(...).type == 'keyword'``.
                These definitions do not have a lot of value apart from their docstring
                attribute, which contains the output of Python's :func:`help` function.

                :rtype: list of :class:`.Name`
        
        """
            def need_pydoc():
                """
                '('
                """
    def usages(self, **kwargs):
        """
        Deprecated since version 0.16.0. Use Script(...).get_references instead.
        """
    def get_references(self, line=None, column=None, **kwargs):
        """

                Lists all references of a variable in a project. Since this can be
                quite hard to do for Jedi, if it is too complicated, Jedi will stop
                searching.

                :param include_builtins: Default ``True``. If ``False``, checks if a reference
                    is a builtin (e.g. ``sys``) and in that case does not return it.
                :param scope: Default ``'project'``. If ``'file'``, include references in
                    the current module only.
                :rtype: list of :class:`.Name`
        
        """
        def _references(include_builtins=True, scope='project'):
            """
            'project'
            """
    def call_signatures(self):
        """
        Deprecated since version 0.16.0. Use Script(...).get_signatures instead.
        """
    def get_signatures(self, line=None, column=None):
        """

                Return the function object of the call under the cursor.

                E.g. if the cursor is here::

                    abs(# <-- cursor is here

                This would return the ``abs`` function. On the other hand::

                    abs()# <-- cursor is here

                This would return an empty list..

                :rtype: list of :class:`.Signature`
        
        """
    def get_context(self, line=None, column=None):
        """

                Returns the scope context under the cursor. This basically means the
                function, class or module where the cursor is at.

                :rtype: :class:`.Name`
        
        """
    def _analysis(self):
        """
        'funcdef'
        """
    def get_names(self, **kwargs):
        """

                Returns names defined in the current file.

                :param all_scopes: If True lists the names of all scopes instead of
                    only the module namespace.
                :param definitions: If True lists the names that have been defined by a
                    class, function or a statement (``a = b`` returns ``a``).
                :param references: If True lists all the names that are not listed by
                    ``definitions=True``. E.g. ``a = b`` returns ``b``.
                :rtype: list of :class:`.Name`
        
        """
    def get_syntax_errors(self):
        """

                Lists all syntax errors in the current file.

                :rtype: list of :class:`.SyntaxError`
        
        """
    def _names(self, all_scopes=False, definitions=True, references=False):
        """
         Set line/column to a random position, because they don't matter.

        """
    def rename(self, line=None, column=None, **kwargs):
        """

                Renames all references of the variable under the cursor.

                :param new_name: The variable under the cursor will be renamed to this
                    string.
                :raises: :exc:`.RefactoringError`
                :rtype: :class:`.Refactoring`
        
        """
    def _rename(self, line, column, new_name):  # Python 2...
        """
         Python 2...
        """
    def extract_variable(self, line, column, **kwargs):
        """

                Moves an expression to a new statemenet.

                For example if you have the cursor on ``foo`` and provide a
                ``new_name`` called ``bar``::

                    foo = 3.1
                    x = int(foo + 1)

                the code above will become::

                    foo = 3.1
                    bar = foo + 1
                    x = int(bar)

                :param new_name: The expression under the cursor will be renamed to
                    this string.
                :param int until_line: The the selection range ends at this line, when
                    omitted, Jedi will be clever and try to define the range itself.
                :param int until_column: The the selection range ends at this column, when
                    omitted, Jedi will be clever and try to define the range itself.
                :raises: :exc:`.RefactoringError`
                :rtype: :class:`.Refactoring`
        
        """
    def _extract_variable(self, line, column, new_name, until_line=None, until_column=None):
        """

                Moves an expression to a new function.

                For example if you have the cursor on ``foo`` and provide a
                ``new_name`` called ``bar``::

                    global_var = 3

                    def x():
                        foo = 3.1
                        x = int(foo + 1 + global_var)

                the code above will become::

                    global_var = 3

                    def bar(foo):
                        return int(foo + 1 + global_var)

                    def x():
                        foo = 3.1
                        x = bar(foo)

                :param new_name: The expression under the cursor will be replaced with
                    a function with this name.
                :param int until_line: The the selection range ends at this line, when
                    omitted, Jedi will be clever and try to define the range itself.
                :param int until_column: The the selection range ends at this column, when
                    omitted, Jedi will be clever and try to define the range itself.
                :raises: :exc:`.RefactoringError`
                :rtype: :class:`.Refactoring`
        
        """
    def _extract_function(self, line, column, new_name, until_line=None, until_column=None):
        """

                Inlines a variable under the cursor. This is basically the opposite of
                extracting a variable. For example with the cursor on bar::

                    foo = 3.1
                    bar = foo + 1
                    x = int(bar)

                the code above will become::

                    foo = 3.1
                    x = int(foo + 1)

                :raises: :exc:`.RefactoringError`
                :rtype: :class:`.Refactoring`
        
        """
def Interpreter(Script):
    """

        Jedi's API for Python REPLs.

        Implements all of the methods that are present in :class:`.Script` as well.

        In addition to completions that normal REPL completion does like
        ``str.upper``, Jedi also supports code completion based on static code
        analysis. For example Jedi will complete ``str().upper``.

        >>> from os.path import join
        >>> namespace = locals()
        >>> script = Interpreter('join("").up', [namespace])
        >>> print(script.complete()[0].name)
        upper

        All keyword arguments are same as the arguments for :class:`.Script`.

        :param str code: Code to parse.
        :type namespaces: typing.List[dict]
        :param namespaces: A list of namespace dictionaries such as the one
            returned by :func:`globals` and :func:`locals`.
    
    """
    def __init__(self, code, namespaces, **kwds):
        """
        namespaces must be a non-empty list of dicts.
        """
    def _get_module_context(self):
        """
        '__main__'
        """
2021-03-02 20:49:49,309 : INFO : tokenize_signature : --> do i ever get here?
def names(source=None, path=None, encoding='utf-8', all_scopes=False,
          definitions=True, references=False, environment=None):
    """
    Deprecated since version 0.16.0. Use Script(...).get_names instead.
    """
def preload_module(*modules):
    """

        Preloading modules tells Jedi to load a module now, instead of lazy parsing
        of modules. This can be useful for IDEs, to control which modules to load
        on startup.

        :param modules: different module names, list of string.
    
    """
2021-03-02 20:49:49,309 : INFO : tokenize_signature : --> do i ever get here?
def set_debug_function(func_cb=debug.print_to_stdout, warnings=True,
                       notices=True, speed=True):
    """

        Define a callback debug function to get all the debug messages.

        If you don't specify any arguments, debug messages will be printed to stdout.

        :param func_cb: The callback function for debug messages.
    
    """
