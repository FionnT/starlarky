def _merge_name_docs(names):
    """
    ''
    """
def AbstractNameDefinition(object):
    """

        Used for the Jedi API to know if it's a keyword or an actual name.
    
    """
    def infer(self):
        """
         Typically names are already definitions and therefore a goto on that
         name will always result on itself.

        """
    def get_qualified_names(self, include_module_names=False):
        """
         By default, a name has no qualified names.

        """
    def get_root_context(self):
        """
        '<%s: string_name=%s>'
        """
    def is_import(self):
        """
        ''
        """
    def api_type(self):
        """

                Returns either None or the value that is public and qualified. Won't
                return a function, because a name in a function is never public.
        
        """
def AbstractArbitraryName(AbstractNameDefinition):
    """

        When you e.g. want to complete dicts keys, you probably want to complete
        string literals, which is not really a name, but for Jedi we use this
        concept of Name for completions as well.
    
    """
    def __init__(self, inference_state, string):
        """
        'import_name'
        """
    def _get_qualified_names(self):
        """
        Shouldn't really happen, please report
        """
    def goto(self):
        """
        'expr_stmt'
        """
    def is_import(self):
        """
        'import_from'
        """
    def string_name(self):
        """
         A module
        """
    def get_defining_qualified_value(self):
        """
         Might be None
        """
    def api_type(self):
        """
        'module'
        """
    def infer(self):
        """
         Refactor this, should probably be here.

        """
    def api_type(self):
        """
        'statement'
        """
    def assignment_indexes(self):
        """

                Returns an array of tuple(int, node) of the indexes that are used in
                tuple assignments.

                For example if the name is ``y`` in the following code::

                    x, (y, z) = 2, ''

                would result in ``[(1, xyz_node), (0, yz_node)]``.

                When searching for b in the case ``a, *b, c = [...]`` it will return::

                    [(slice(1, -1), abc_node)]
        
        """
    def py__doc__(self):
        """
        'function'
        """
def _ParamMixin(object):
    """
     *args
    """
    def get_qualified_names(self, include_module_names=False):
        """
        u'param'
        """
    def get_kind(self):
        """

                For dealing with type inference and working around the graph, we
                sometimes want to have the param name of the execution. This feels a
                bit strange and we might have to refactor at some point.

                For now however it exists to avoid infering params when we don't really
                need them (e.g. when we can just instead use annotations.
        
        """
    def star_count(self):
        """
        ': '
        """
    def get_public_name(self):
        """
        '__'
        """
    def goto(self, **kwargs):
        """
        'param'
        """
    def annotation_node(self):
        """
         *args
        """
    def infer(self):
        """
        'goto_anonymous_param'
        """
    def goto(self):
        """
        'infer_anonymous_param'
        """
    def infer(self):
        """
        '<%s: %s>'
        """
def ImportName(AbstractNameDefinition):
    """
    Everything else is not supported for now
    """
    def parent_context(self):
        """
         It's almost always possible to find the import or to not find it. The
         importing returns only one value, pretty much always.

        """
    def infer(self):
        """
        'module'
        """
    def py__doc__(self):
        """
        '%s(%s)'
        """
def StubNameMixin(object):
    """
     Stubs are not complicated and we can just follow simple statements
     that have an equals in them, because they typically make something
     else public. See e.g. stubs for `requests`.

    """
def StubName(StubNameMixin, TreeNameDefinition):
    """
    'version_info'
    """
def ModuleName(ValueNameMixin, AbstractNameDefinition):
