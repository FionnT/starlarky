def CheckAttribute(object):
    """
    Raises :exc:`AttributeError` if the attribute X is not available.
    """
    def __init__(self, check_name=None):
        """
         Remove the py in front of e.g. py__call__.

        """
    def __call__(self, func):
        """
         This might raise an AttributeError. That's wanted.

        """
def CompiledValue(Value):
    """
     TODO the return annotation may also be a string.

    """
    def py__class__(self):
        """
         Has no signature
        """
    def get_signatures(self):
        """
        '<%s: %s>'
        """
    def _parse_function_doc(self):
        """
        ''
        """
    def api_type(self):
        """
         This means basically that no __getitem__ has been defined on this
         object.

        """
    def py__iter__(self, contextualized_node=None):
        """
         Python iterators are a bit strange, because there's no need for
         the __iter__ function as long as __getitem__ is defined (it will
         just start with __getitem__(0). This is especially true for
         Python 2 strings, where `str.__iter__` is not even defined.

        """
    def py__name__(self):
        """
        'function'
        """
    def get_safe_value(self, default=_sentinel):
        """
        'None'
        """
    def negate(self):
        """
        'None'
        """
def CompiledModule(CompiledValue):
    """
     For modules
    """
    def _as_context(self):
        """
         For modules

        """
    def py__file__(self):
        """
         Might be None
        """
    def __repr__(self):
        """
         __name__ is not defined all the time
        """
    def api_type(self):
        """
         If we can't find the type, assume it is an instance variable

        """
    def infer(self):
        """
        ': '
        """
    def get_kind(self):
        """
        '='
        """
    def infer(self):
        """

            Accessing some names will raise an exception. To avoid not having any
            completions, just give Jedi the option to return this object. It infers to
            nothing.
    
        """
    def __init__(self, inference_state, name):
        """

                To remove quite a few access calls we introduced the callback here.
        
        """
    def _get_cached_name(self, name, is_empty=False):
        """
         We could use `unsafe` here as well, especially as a parameter to
         get_dir_infos. But this would lead to a lot of property executions
         that are probably not wanted. The drawback for this is that we
         have a different name for `get` and `values`. For `get` we always
         execute.

        """
    def _create_name(self, name):
        """
        <%s: %s>
        """
def _parse_function_doc(doc):
    """

        Takes a function and returns the params and return value as a tuple.
        This is nothing more than a docstring parser.

        TODO docstrings like utime(path, (atime, mtime)) and a(b [, b]) -> None
        TODO docstrings like 'tuple of integers'
    
    """
        def change_options(m):
            """
            ','
            """
def create_from_name(inference_state, compiled_value, name):
    """
    The cache doesn't care about keyword vs. normal args.
    """
    def wrapper(inference_state, obj, parent_context=None):
