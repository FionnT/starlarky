def _enqueue_output(out, queue):
    """
    b''
    """
def _add_stderr_to_debug(stderr_queue):
    """
     Try to do some error reporting from the subprocess and print its
     stderr contents.

    """
def _get_function(name):
    """
     Raised if the process is already killed.

    """
def _InferenceStateProcess(object):
    """

        Basically just an easy access to functions.py. It has the same API
        as InferenceStateSubprocess and does the same thing without using a subprocess.
        This is necessary for the Interpreter process.
    
    """
    def __getattr__(self, name):
        """
         IMO it should be possible to create a hook in pickle.load to
         mess with the loaded objects. However it's extremely complicated
         to work around this so just do it with this call. ~ dave

        """
    def _convert_access_handles(self, obj):
        """
         Rewrite the access handle to one we're already having.

        """
    def __del__(self):
        """
         Start with 2, gets set after _get_info.

        """
    def __init__(self, executable, env_vars=None):
        """
        '<%s _executable=%r, _pickle_protocol=%r, is_crashed=%r, pid=%r>'
        """
    def _get_process(self):
        """
        'Start environment subprocess %s'
        """
    def run(self, inference_state, function, args=(), kwargs={}):
        """
         Delete old inference_states.

        """
    def get_sys_path(self):
        """
        The subprocess %s has crashed.
        """
    def delete_inference_state(self, inference_state_id):
        """

                Currently we are not deleting inference_state instantly. They only get
                deleted once the subprocess is used again. It would probably a better
                solution to move all of this into a thread. However, the memory usage
                of a single inference_state shouldn't be that high.
        
        """
def Listener(object):
    """
     TODO refactor so we don't need to process anymore just handle
     controlling.

    """
    def _get_inference_state(self, function, inference_state_id):
        """
         The project is not actually needed. Nothing should need to
         access it.

        """
    def _run(self, inference_state_id, function, args, kwargs):
        """
         Exchange all handles

        """
    def listen(self):
        """
         Mute stdout. Nobody should actually be able to write to it,
         because stdout is used for IPC.

        """
def AccessHandle(object):
    """
    '#'
    """
    def __getstate__(self):
        """
        'id'
        """
    def _workaround(self, name, *args, **kwargs):
        """

                TODO Currently we're passing slice objects around. This should not
                happen. They are also the only unhashable objects that we're passing
                around.
        
        """
    def _cached_results(self, name, *args, **kwargs):
