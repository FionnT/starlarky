def _add_argument_issue(error_name, lazy_value, message):
    """
    'argument'
    """
def ExecutedParamName(ParamName):
    """
     If we cannot infer annotations - or there aren't any - pretend
     that the signature matches.

    """
    def __repr__(self):
        """
        '<%s: %s>'
        """
def get_executed_param_names_and_issues(function_value, arguments):
    """

        Return a tuple of:
          - a list of `ExecutedParamName`s corresponding to the arguments of the
            function execution `function_value`, containing the inferred value of
            those arguments (whether explicit or default)
          - a list of the issues encountered while building that list

        For example, given:
        ```
        def foo(a, b, c=None, d='d'): ...

        foo(42, c='c')
        ```

        Then for the execution of `foo`, this will return a tuple containing:
          - a list with entries for each parameter a, b, c & d; the entries for a,
            c, & d will have their values (42, 'c' and 'd' respectively) included.
          - a list with a single entry about the lack of a value for `b`
    
    """
    def too_many_args(argument):
        """
         Just report an error for the first param that is not needed (like
         cPython).

        """
def get_executed_param_names(function_value, arguments):
    """

        Return a list of `ExecutedParamName`s corresponding to the arguments of the
        function execution `function_value`, containing the inferred value of those
        arguments (whether explicit or default). Any issues building this list (for
        example required arguments which are missing in the invocation) are ignored.

        For example, given:
        ```
        def foo(a, b, c=None, d='d'): ...

        foo(42, c='c')
        ```

        Then for the execution of `foo`, this will return a list containing entries
        for each parameter a, b, c & d; the entries for a, c, & d will have their
        values (42, 'c' and 'd' respectively) included.
    
    """
def _error_argument_count(funcdef, actual_count):
    """
    'exactly '
    """
