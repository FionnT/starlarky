def AbstractContext(object):
    """
     Must be defined: inference_state and tree_node and parent_context as an attribute/property


    """
    def __init__(self, inference_state):
        """
        'context.goto %s in (%s): %s'
        """
2021-03-02 20:49:59,127 : INFO : tokenize_signature : --> do i ever get here?
    def py__getattribute__(self, name_or_str, name_context=None, position=None,
                           analysis_errors=True):
        """

                :param position: Position of the last statement -> tuple of line, column
        
        """
    def _check_for_additional_knowledge(self, name_or_str, name_context, position):
        """
         Add isinstance and other if/assert knowledge.

        """
    def get_root_context(self):
        """
        ''
        """
    def predefine_names(self, flow_scope, dct):
        """

            Should be defined, otherwise the API returns empty types.
    
        """
    def __init__(self, value):
        """
        '%s(%s)'
        """
def TreeContextMixin(object):
    """
    'funcdef'
    """
    def create_context(self, node):
        """
        'funcdef'
        """
        def parent_scope(node):
            """
            'argument'
            """
    def create_name(self, tree_name):
        """
        'param'
        """
def FunctionContext(TreeContextMixin, ValueContext):
    """
     Skip the first filter and replace it.

    """
    def get_global_filter(self):
        """

                This is the only function that converts a context back to a value.
                This is necessary for stub -> python conversion and vice versa. However
                this method shouldn't be moved to AbstractContext.
        
        """
def NamespaceContext(TreeContextMixin, ValueContext):
    """
    '<comprehension context>'
    """
    def __repr__(self):
        """
        '%s(%s)'
        """
def CompiledContext(ValueContext):
    """
     For functions and classes the defaults don't belong to the
     function and get inferred in the value before the function. So
     make sure to exclude the function/class name.

    """
def get_global_filters(context, until_position, origin_scope):
    """

        Returns all filters in order of priority for name resolution.

        For global name lookups. The filters will handle name resolution
        themselves, but here we gather possible filters downwards.

        >>> from jedi._compatibility import u, no_unicode_pprint
        >>> from jedi import Script
        >>> script = Script(u('''
        ... x = ['a', 'b', 'c']
        ... def func():
        ...     y = None
        ... '''))
        >>> module_node = script._module_node
        >>> scope = next(module_node.iter_funcdefs())
        >>> scope
        <Function: func@3-5>
        >>> context = script._get_module_context().create_context(scope)
        >>> filters = list(get_global_filters(context, (4, 0), None))

        First we get the names from the function scope.

        >>> no_unicode_pprint(filters[0])  # doctest: +ELLIPSIS
        MergedFilter(<ParserTreeFilter: ...>, <GlobalNameFilter: ...>)
        >>> sorted(str(n) for n in filters[0].values())  # doctest: +NORMALIZE_WHITESPACE
        ['<TreeNameDefinition: string_name=func start_pos=(3, 4)>',
         '<TreeNameDefinition: string_name=x start_pos=(2, 0)>']
        >>> filters[0]._filters[0]._until_position
        (4, 0)
        >>> filters[0]._filters[1]._until_position

        Then it yields the names from one level "lower". In this example, this is
        the module scope (including globals).
        As a side note, you can see, that the position in the filter is None on the
        globals filter, because there the whole module is searched.

        >>> list(filters[1].values())  # package modules -> Also empty.
        []
        >>> sorted(name.string_name for name in filters[2].values())  # Module attributes
        ['__doc__', '__name__', '__package__']

        Finally, it yields the builtin filter, if `include_builtin` is
        true (default).

        >>> list(filters[3].values())  # doctest: +ELLIPSIS
        [...]
    
    """
