def LambdaName(AbstractNameDefinition):
    """
    '<lambda>'
    """
    def __init__(self, lambda_value):
        """
         This means that the parent class lives within a function.

        """
def FunctionMixin(object):
    """
    u'function'
    """
    def get_filters(self, origin_scope=None):
        """
         Calling the Foo.bar results in the original bar function.

        """
    def get_param_names(self):
        """
        'lambdef'
        """
    def is_function(self):
        """
        ': '
        """
    def py__call__(self, arguments):
        """
         Get them into the correct order: lower line first.

        """
    def py__class__(self):
        """
        u'types'
        """
    def get_default_param_context(self):
        """
         Might be None.
        """
def MethodValue(FunctionValue):
    """
     Need to implement this, because the parent value of a method
     value is not the class value but the module.

    """
    def name(self):
        """
        'lambdef'
        """
    def _get_yield_lazy_value(self, yield_expr):
        """
        'keyword'
        """
    def get_yield_lazy_values(self, is_async=False):
        """
         TODO: if is_async, wrap yield statements in Awaitable/async_generator_asend

        """
    def merge_yield_values(self, is_async=False):
        """

                Created to be used by inheritance.
        
        """
def FunctionExecutionContext(BaseFunctionExecutionContext):
    """
     I don't think inferring anonymous executions is a big thing.
     Anonymous contexts are mostly there for the user to work in. ~ dave

    """
    def get_filters(self, until_position=None, origin_scope=None):
        """
        Execute overloaded function %s
        """
    def get_signature_functions(self):
        """
        'Union[%s]'
        """
def _find_overload_functions(context, tree_node):
    """
    'decorated'
    """
