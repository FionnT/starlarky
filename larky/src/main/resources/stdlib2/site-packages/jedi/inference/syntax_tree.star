def _limit_value_infers(func):
    """

        This is for now the way how we limit type inference going wild. There are
        other ways to ensure recursion limits as well. This is mostly necessary
        because of instance (self) access that can be quite tricky to limit.

        I'm still not sure this is the way to go, but it looks okay for now and we
        can still go anther way in the future. Tests are there. ~ dave
    
    """
    def wrapper(context, *args, **kwargs):
        """
         Builtins should have a more generous inference limit.
         It is important that builtins can be executed, otherwise some
         functions that depend on certain builtins features would be
         broken, see e.g. GH #1432

        """
def infer_node(context, element):
    """
    'if_stmt'
    """
def _infer_node_if_inferred(context, element):
    """

        TODO This function is temporary: Merge with infer_node.
    
    """
def _infer_node_cached(context, element):
    """
    'infer_node %s@%s in %s'
    """
def infer_trailer(context, atom_values, trailer):
    """
    ')'
    """
def infer_atom(context, atom):
    """

        Basically to process ``atom`` nodes. The parser sometimes doesn't
        generate the node (because it has just one child). In that case an atom
        might be a name or a literal as well.
    
    """
def infer_expr_stmt(context, stmt, seek_name=None):
    """

        The starting point of the completion. A statement always owns a call
        list, which are the calls, that a statement does. In case multiple
        names are defined in the statement, `seek_name` returns the result for
        this name.

        expr_stmt: testlist_star_expr (annassign | augassign (yield_expr|testlist) |
                         ('=' (yield_expr|testlist_star_expr))*)
        annassign: ':' test ['=' test]
        augassign: ('+=' | '-=' | '*=' | '@=' | '/=' | '%=' | '&=' | '|=' | '^=' |
                    '<<=' | '>>=' | '**=' | '//=')

        :param stmt: A `tree.ExprStmt`.
    
    """
    def check_setitem(stmt):
        """
        'atom_expr'
        """
            def to_mod(v):
                """
                'dict'
                """
def infer_or_test(context, or_test):
    """
    'comp_op'
    """
def infer_factor(value_set, operator):
    """

        Calculates `+`, `-`, `~` and `not` prefixes.
    
    """
def _literals_to_types(inference_state, result):
    """
     Changes literals ('a', 1, 1.0, etc) to its type instances (str(),
     int(), float(), etc).

    """
def _infer_comparison(context, left_values, operator, right_values):
    """
     illegal slices e.g. cause left/right_result to be None

    """
def _is_annotation_name(name):
    """
    'param'
    """
def _is_list(value):
    """
    'list'
    """
def _is_tuple(value):
    """
    'tuple'
    """
def _bool_to_value(inference_state, bool_):
    """
    'number'
    """
def _infer_comparison_part(inference_state, context, left, operator, right):
    """
    '*'
    """
    def check(obj):
        """
        Checks if a Jedi object is either a float or an int.
        """
def tree_name_to_values(inference_state, context, tree_name):
    """
     First check for annotations, like: `foo: int = 3`

    """
def _apply_decorators(context, node):
    """

        Returns the function, that should to be executed in the end.
        This is also the places where the decorators are processed.
    
    """
def check_tuple_assignments(name, value_set):
    """

        Checks if tuples are assigned.
    
    """
def ContextualizedSubscriptListNode(ContextualizedNode):
    """

        Handles slices in subscript nodes.
    
    """
