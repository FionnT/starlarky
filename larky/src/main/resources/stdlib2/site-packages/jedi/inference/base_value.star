def HelperValueMixin(object):
    """
     This covers the case where a stub files are incomplete.

    """
    def goto(self, name_or_str, name_context=None, analysis_errors=True):
        """
        'context.goto %s in (%s): %s'
        """
2021-03-02 20:49:53,916 : INFO : tokenize_signature : --> do i ever get here?
    def py__getattribute__(self, name_or_str, name_context=None, position=None,
                           analysis_errors=True):
        """

                :param position: Position of the last statement -> tuple of line, column
        
        """
    def py__await__(self):
        """
        u"__await__
        """
    def py__name__(self):
        """
        'iterate %s'
        """
    def is_sub_class_of(self, class_value):
        """
        'subclass matching of %s <=> %s'
        """
    def is_same_class(self, class2):
        """
         Class matching should prefer comparisons that are not this function.

        """
    def as_context(self, *args, **kwargs):
        """

            To be implemented by subclasses.
    
        """
    def __init__(self, inference_state, parent_context=None):
        """
         TODO this value is probably not right.

        """
    def py__simple_getitem__(self, index):
        """
        'type-error-not-iterable'
        """
    def py__next__(self, contextualized_node=None):
        """

                Since Wrapper is a super class for classes, functions and modules,
                the return value will always be true.
        
        """
    def py__doc__(self):
        """
        ''
        """
    def get_safe_value(self, default=sentinel):
        """
        There exists no safe value for value %s
        """
    def execute_operation(self, other, operator):
        """
        %s not possible between %s and %s
        """
    def py__call__(self, arguments):
        """
        no execution possible %s
        """
    def py__stop_iteration_returns(self):
        """
        Not possible to return the stop iterations of %s
        """
    def py__getattribute__alternatives(self, name_or_str):
        """

                For now a way to add values in cases like __getattr__.
        
        """
    def py__get__(self, instance, class_value):
        """
        No __get__ defined on %s
        """
    def py__get__on_class(self, calling_instance, instance, class_value):
        """
         Returns Optional[Tuple[str, ...]]

        """
    def is_stub(self):
        """
         The root value knows if it's a stub or not.

        """
    def _as_context(self):
        """
        'Not all values need to be converted to contexts: %s'
        """
    def name(self):
        """

                When the current instance represents a type annotation, this method
                tries to find information about undefined type vars and returns a dict
                from type var name to value set.

                This is for example important to understand what `iter([1])` returns.
                According to typeshed, `iter` returns an `Iterator[_T]`:

                    def iter(iterable: Iterable[_T]) -> Iterator[_T]: ...

                This functions would generate `int` for `_T` in this case, because it
                unpacks the `Iterable`.

                Parameters
                ----------

                `self`: represents the annotation of the current parameter to infer the
                    value for. In the above example, this would initially be the
                    `Iterable[_T]` of the `iterable` parameter and then, when recursing,
                    just the `_T` generic parameter.

                `value_set`: represents the actual argument passed to the parameter
                    we're inferrined for, or (for recursive calls) their types. In the
                    above example this would first be the representation of the list
                    `[1]` and then, when recursing, just of `1`.
        
        """
def iterate_values(values, contextualized_node=None, is_async=False):
    """

        Calls `iterate`, on all values but ignores the ordering and just returns
        all values that the iterate functions yield.
    
    """
def _ValueWrapperBase(HelperValueMixin):
    """
    '_wrapped_value'
    """
def LazyValueWrapper(_ValueWrapperBase):
    """
    'Resolve lazy value wrapper'
    """
    def __repr__(self):
        """
        '<%s>'
        """
    def _get_wrapped_value(self):
        """
        '%s(%s)'
        """
def TreeValue(Value):
    """
    '<%s: %s>'
    """
def ContextualizedNode(object):
    """
    '<%s: %s in %s>'
    """
def _getitem(value, index_values, contextualized_node):
    """
     The actual getitem call.

    """
def ValueSet(object):
    """

            Used to work with an iterable of set.
        
    """
    def __or__(self, other):
        """
        'S{%s}'
        """
    def filter(self, filter_func):
        """
        'None'
        """
    def infer_type_vars(self, value_set):
        """
         Circular

        """
def iterator_to_value_set(func):
