def ClassName(TreeNameDefinition):
    """
     We're using a different value to infer, so we cannot call super().

    """
def ClassFilter(ParserTreeFilter):
    """
     Filter for ClassVar variables
     TODO this is not properly done, yet. It just checks for the string
     ClassVar in the annotation, which can be quite imprecise. If we
     wanted to do this correct, we would have to infer the ClassVar.

    """
    def _filter(self, names):
        """
        u'type'
        """
    def name(self):
        """
         TODO Do a proper mro resolution. Currently we are just listing
         classes. However, it's a complicated algorithm.

        """
2021-03-02 20:49:55,536 : INFO : tokenize_signature : --> do i ever get here?
    def get_filters(self, origin_scope=None, is_instance=False,
                    include_metaclasses=True, include_type_when_class=True):
        """
         Python 2..
        """
    def get_signatures(self):
        """
         Since calling staticmethod without a function is illegal, the Jedi
         plugin doesn't return anything. Therefore call directly and get what
         we want: An instance of staticmethod.

        """
    def _as_context(self):
        """
        'Type[%s]'
        """
    def is_typeddict(self):
        """
         TODO Do a proper mro resolution. Currently we are just listing
         classes. However, it's a complicated algorithm.

        """
    def py__getitem__(self, index_value_set, contextualized_node):
        """
        'Class indexes inferred to nothing. Returning class instead'
        """
    def with_generics(self, generics_tuple):
        """

                    The TypeVars in the resulting classes have sometimes different names
                    and we need to check for that, e.g. a signature can be:

                    def iter(iterable: Iterable[_T]) -> Iterator[_T]: ...

                    However, the iterator is defined as Iterator[_T_co], which means it has
                    a different type var name.
            
        """
def ClassValue(use_metadef(CachedMetaClass, ClassMixin, FunctionAndClassBase)):
    """
    u'class'
    """
    def list_type_vars(self):
        """
         These are not relevant for this search.
        """
    def _get_bases_arguments(self):
        """
        'object'
        """
    def get_metaclass_filters(self, metaclasses, is_instance):
        """
        'Unprocessed metaclass %s'
        """
    def get_metaclasses(self):
        """
        'metaclass'
        """
    def get_metaclass_signatures(self, metaclasses):
