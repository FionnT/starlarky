def is_stdlib_path(path):
    """
     Python standard library paths look like this:
     /usr/lib/python3.5/...
     TODO The implementation below is probably incorrect and not complete.

    """
def deep_ast_copy(obj):
    """

        Much, much faster than copy.deepcopy, but just for parser tree nodes.
    
    """
def infer_call_of_leaf(context, leaf, cut_own_trailer=False):
    """

        Creates a "call" node that consist of all ``trailer`` and ``power``
        objects.  E.g. if you call it with ``append``::

            list([]).append(3) or None

        You would get a node with the content ``list([]).append`` back.

        This generates a copy of the original ast node.

        If you're using the leaf, e.g. the bracket `)` it will return ``list([])``.

        We use this function for two purposes. Given an expression ``bar.foo``,
        we may want to
          - infer the type of ``foo`` to offer completions after foo
          - infer the type of ``bar`` to be able to jump to the definition of foo
        The option ``cut_own_trailer`` must be set to true for the second purpose.
    
    """
def get_names_of_node(node):
    """
    'name'
    """
def is_string(value):
    """
    '.'
    """
def values_from_qualified_names(inference_state, *names):
    """
     Especially pandas and tensorflow are huge complicated Python libraries
     that get even slower than they already are when Jedi tries to undrstand
     dynamic features like decorators, ifs and other stuff.

    """
