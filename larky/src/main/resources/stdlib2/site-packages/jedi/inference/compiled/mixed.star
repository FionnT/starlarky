def MixedObject(ValueWrapper):
    """

        A ``MixedObject`` is used in two ways:

        1. It uses the default logic of ``parser.python.tree`` objects,
        2. except for getattr calls and signatures. The names dicts are generated
           in a fashion like ``CompiledValue``.

        This combined logic makes it possible to provide more powerful REPL
        completion. It allows side effects that are not noticable with the default
        parser structure to still be completeable.

        The biggest difference from CompiledValue to MixedObject is that we are
        generally dealing with Python code and not with C code. This will generate
        fewer special cases, because we in Python you don't have the same freedoms
        to modify the runtime.
    
    """
    def __init__(self, compiled_value, tree_value):
        """
         Prefer `inspect.signature` over somehow analyzing Python code. It
         should be very precise, especially for stuff like `partial`.

        """
    def py__call__(self, arguments):
        """
         Fallback to the wrapped value if to stub returns no values.

        """
    def get_safe_value(self, default=_sentinel):
        """
        '<%s: %s; %s>'
        """
def MixedContext(CompiledContext, TreeContextMixin):
    """

        The ``CompiledName._compiled_value`` is our MixedObject.
    
    """
    def __init__(self, wrapped_name, parent_tree_value):
        """
         This means a start_pos that doesn't exist (compiled objects).

        """
    def infer(self):
        """
        Check if inspect.getfile has a chance to find the source.
        """
def _find_syntax_node_name(inference_state, python_object):
    """
     The type might not be known (e.g. class_with_dict.__weakref__)

    """
def _create(inference_state, compiled_value, module_context):
    """
     TODO accessing this is bad, but it probably doesn't matter that much,
     because we're working with interpreteters only here.

    """
