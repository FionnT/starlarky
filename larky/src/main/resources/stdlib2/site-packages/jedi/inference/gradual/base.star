def _BoundTypeVarName(AbstractNameDefinition):
    """

        This type var was bound to a certain type, e.g. int.
    
    """
    def __init__(self, type_var, value_set):
        """
         Replace any with the constraints if they are there.

        """
    def py__name__(self):
        """
        '<%s %s -> %s>'
        """
def _TypeVarFilter(object):
    """

        A filter for all given variables in a class.

            A = TypeVar('A')
            B = TypeVar('B')
            class Foo(Mapping[A, B]):
                ...

        In this example we would have two type vars given: A and B
    
    """
    def __init__(self, generics, type_vars):
        """
         The values are not relevant. If it's not searched exactly, the type
         vars are just global and should be looked up as that.

        """
def _AnnotatedClassContext(ClassContext):
    """
     The type vars can only be looked up if it's a global search and
     not a direct lookup on the class.

    """
def DefineGenericBaseClass(LazyValueWrapper):
    """
     There might not be any type vars that change. In that case just
     return itself, because it does not make sense to potentially lose
     cached results.

    """
    def is_same_class(self, other):
        """
         TODO not sure if this is nice.

        """
    def __repr__(self):
        """
        '<%s: %s%s>'
        """
def GenericClass(DefineGenericBaseClass, ClassMixin):
    """

        A class that is defined with generics, might be something simple like:

            class Foo(Generic[T]): ...
            my_foo_int_cls = Foo[int]
    
    """
    def __init__(self, class_value, generics_manager):
        """
         Not sure if this is the best way to do this, but all of these types
         are a bit special in that they have type aliases and other ways to
         become lower case. It's probably better to make them upper case,
         because that's what you can use in annotations.

        """
    def get_type_var_filter(self):
        """
         Circular

        """
def _LazyGenericBaseClass(object):
    """
     Here we have to recalculate the given types.

    """
    def _remap_type_vars(self, base):
        """
         Mostly will be type vars, except if in some cases
         a concrete type will already be there. In that
         case just add it to the value set.

        """
    def __repr__(self):
        """
        '<%s: %s>'
        """
def _GenericInstanceWrapper(ValueWrapper):
    """
    'Generator'
    """
    def get_type_hint(self, add_class_info=True):
        """

            In typeshed, some classes are defined like this:

                Tuple: _SpecialForm = ...

            Now this is not a real class, therefore we have to do some workarounds like
            this class. Essentially this class makes it possible to goto that `Tuple`
            name, without affecting anything else negatively.
    
        """
    def __init__(self, parent_context, tree_name):
        """
         TODO this is obviously wrong. Is it though?

        """
        def EmptyFilter(ClassFilter):
    """
     This might not be 100% correct, but it is good enough. The details of
     the typing library are not really an issue for Jedi.

    """
    def name(self):
        """
        '%s(%s)'
        """
def BaseTypingValue(LazyValueWrapper):
    """
    '%s(%s)'
    """
def BaseTypingClassWithGenerics(DefineGenericBaseClass):
    """
    '%s(%s%s)'
    """
def BaseTypingInstance(LazyValueWrapper):
    """
    u'object'
    """
    def __repr__(self):
        """
        '<%s: %s>'
        """
