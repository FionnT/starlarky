def InstanceExecutedParamName(ParamName):
    """
     set the self name

    """
def MethodExecutionContext(FunctionExecutionContext):
    """
    u'instance'
    """
    def __init__(self, inference_state, parent_context, class_value):
        """
         Generated instances are classes that are just generated by self
         (No arguments) used.

        """
    def is_instance(self):
        """
         This is the default.
        """
    def py__class__(self):
        """
         Signalize that we don't know about the bool type.

        """
    def name(self):
        """
        '__call__'
        """
    def get_function_slot_names(self, name):
        """
         Searches for Python functions in classes.

        """
    def execute_function_slots(self, names, *inferred_args):
        """
        <%s of %s>
        """
def CompiledInstance(AbstractInstanceValue):
    """
     This is not really a compiled class, it's just an instance from a
     compiled class.

    """
    def __init__(self, inference_state, parent_context, class_value, arguments):
        """
        'list'
        """
    def name(self):
        """
         In this case we're excluding compiled objects that are
         not fake objects. It doesn't make sense for normal
         compiled objects to search for self variables.

        """
    def create_instance_context(self, class_context, node):
        """
        'funcdef'
        """
    def py__getattribute__alternatives(self, string_name):
        """
        '''
                Since nothing was inferred, now check the __getattr__ and
                __getattribute__ methods. Stubs don't need to be checked, because
                they don't contain any logic.
                '''
        """
    def py__getitem__(self, index_value_set, contextualized_node):
        """
        u'__getitem__'
        """
    def py__iter__(self, contextualized_node=None):
        """
        u'__iter__'
        """
        def iterate():
            """
             `__next__` logic.

            """
    def py__call__(self, arguments):
        """
        u'__call__'
        """
    def py__get__(self, instance, class_value):
        """

                obj may be None.
        
        """
    def get_function_slot_names(self, name):
        """
         Python classes don't look at the dictionary of the instance when
         looking up `__call__`. This is something that has to do with Python's
         internal slot system (note: not __slots__, but C slots).

        """
def TreeInstance(_BaseTreeInstance):
    """
     I don't think that dynamic append lookups should happen here. That
     sounds more like something that should go to py__iter__.

    """
    def _get_annotated_class_object(self):
        """
        '__init__'
        """
    def get_annotated_class_object(self):
        """
        'dict'
        """
    def py__simple_getitem__(self, index):
        """
        'dict'
        """
    def __repr__(self):
        """
        <%s of %s(%s)>
        """
def AnonymousInstance(_BaseTreeInstance):
    """
    How? Please reproduce and report
    """
    def infer(self):
        """
        'function'
        """
def CompiledInstanceClassFilter(AbstractFilter):
    """
    u'types'
    """
    def _get_arguments(self, arguments):
        """
        '<%s: %s>'
        """
def CompiledBoundMethod(ValueWrapper):
    """

        This name calculates the parent_context lazily.
    
    """
    def __init__(self, instance, class_context, tree_name):
        """

            This filter is special in that it uses the class filter and wraps the
            resulting names in LazyInstanceClassName. The idea is that the class name
            filtering can be very flexible and always be reflected in instances.
    
        """
    def __init__(self, instance, class_filter):
        """
        '<%s for %s>'
        """
def SelfAttributeFilter(ClassFilter):
    """

        This class basically filters all the use cases where `self.*` was assigned.
    
    """
    def __init__(self, instance, instance_class, node_context, origin_scope):
        """
        'trailer'
        """
    def _is_in_right_scope(self, self_name, name):
        """
        'param'

        """
    def _convert_names(self, names):
