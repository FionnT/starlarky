def ModuleCache(object):
    """
     This memoization is needed, because otherwise we will infinitely loop on
     certain imports.

    """
def infer_import(context, tree_name):
    """
    'after import: %s'
    """
def goto_import(context, tree_name):
    """
     Avoid recursion on the same names.

    """
def _prepare_infer_import(module_context, tree_name):
    """
    'import_name'
    """
def _add_error(value, name, message):
    """
    'parent'
    """
def _level_to_base_import_path(project_path, directory, level):
    """

        In case the level is outside of the currently known package (something like
        import .....foo), we can still try our best to help the user for
        completions.
    
    """
def Importer(object):
    """

            An implementation similar to ``__import__``. Use `follow`
            to actually follow the imports.

            *level* specifies whether to use absolute or relative imports. 0 (the
            default) means only perform absolute imports. Positive values for level
            indicate the number of parent directories to search relative to the
            directory of the module calling ``__import__()`` (see PEP 328 for the
            details).

            :param import_path: List of namespaces (strings or Names).
        
    """
    def _str_import_path(self):
        """
        Returns the import path as pure strings instead of `Name`.
        """
    def _sys_path_with_modifications(self, is_completion):
        """
         For import completions we don't want to see init paths, but for
         inference we want to show the user as much as possible.
         See GH #1446.

        """
    def follow(self):
        """
         Check caches first

        """
    def _get_module_names(self, search_path=None, in_module=None):
        """

                Get the names of all modules in the search_path. This means file names
                and not names defined in the files.
        
        """
    def completion_names(self, inference_state, only_modules=False):
        """

                :param only_modules: Indicates wheter it's possible to import a
                    definition that is not defined in a module.
        
        """
2021-03-02 20:49:58,551 : INFO : tokenize_signature : --> do i ever get here?
def import_module_by_names(inference_state, import_names, sys_path=None,
                           module_context=None, prefer_stubs=True):
    """
    'No module named '
    """
def import_module(inference_state, import_names, parent_module_value, sys_path):
    """

        This method is very similar to importlib's `_gcd_import`.
    
    """
2021-03-02 20:49:58,553 : INFO : tokenize_signature : --> do i ever get here?
def _load_python_module(inference_state, file_io,
                        import_names=None, is_package=False):
    """
    '.'
    """
def load_module_from_path(inference_state, file_io, import_names=None, is_package=None):
    """

        This should pretty much only be used for get_modules_containing_name. It's
        here to ensure that a random path is still properly loaded into the Jedi
        module structure.
    
    """
def load_namespace_from_path(inference_state, folder_io):
    """
    'error_node'
    """
2021-03-02 20:49:58,557 : INFO : tokenize_signature : --> do i ever get here?
def iter_module_names(inference_state, module_context, search_path,
                      module_cls=ImportName, add_builtin_modules=True):
    """

        Get the names of all modules in the search_path. This means file names
        and not names defined in the files.
    
    """
