def IterableMixin(object):
    """
    u'None'
    """
        def get_safe_value(self, default=sentinel):
            """
            There exists no safe value for value %s
            """
def GeneratorBase(LazyAttributeOverwrite, IterableMixin):
    """
    'Generator'
    """
    def py__bool__(self):
        """
        '__iter__'
        """
    def _iter(self, arguments):
        """
        'send'
        """
    def _next(self, arguments):
        """
        u'None'
        """
    def name(self):
        """
        'Generator'
        """
    def get_annotated_class_object(self):
        """
        Handling of `yield` functions.
        """
    def __init__(self, inference_state, func_execution_context):
        """
        <%s of %s>
        """
def comprehension_from_atom(inference_state, value, atom):
    """
    '{'
    """
def ComprehensionMixin(object):
    """
    'comp_for'
    """
    def _iterate(self):
        """
        <%s of %s>
        """
def _DictMixin(object):
    """
    u'instance'
    """
    def name(self):
        """
         We don't know the length, because of appends.
        """
    def parent(self):
        """
        'dict'
        """
def _BaseComprehension(ComprehensionMixin):
    """
    'sync_comp_for'
    """
def ListComprehension(_BaseComprehension, Sequence):
    """
    u'list'
    """
    def py__simple_getitem__(self, index):
        """
        u'set'
        """
def GeneratorComprehension(_BaseComprehension, GeneratorBase):
    """
     TODO merge with _DictMixin?

    """
    def get_mapping_item_values(self):
        """
         TODO merge with _dict_keys?

        """
def DictComprehension(ComprehensionMixin, Sequence, _DictKeyMixin):
    """
    u'dict'
    """
    def __init__(self, inference_state, defining_context, sync_comp_for_node, key_node, value_node):
        """
        'sync_comp_for'
        """
    def py__iter__(self, contextualized_node=None):
        """
         Be careful in the future if refactoring, index could be a
         slice object.

        """
    def _dict_keys(self):
        """
        'values'
        """
    def _imitate_values(self, arguments):
        """
        'items'
        """
    def _imitate_items(self, arguments):
        """
         NOTE: A smarter thing can probably done here to achieve better
         completions, but at least like this jedi doesn't crash

        """
def SequenceLiteralValue(Sequence):
    """
    'testlist_star_expr'
    """
    def __init__(self, inference_state, defining_context, atom):
        """
        u'tuple'
        """
    def _get_generics(self):
        """
        u'tuple'
        """
    def py__simple_getitem__(self, index):
        """
        Here the index is an int/str. Raises IndexError/KeyError.
        """
    def py__iter__(self, contextualized_node=None):
        """

                While values returns the possible values for any array field, this
                function returns the value for a certain index.
        
        """
    def py__len__(self):
        """
         This function is not really used often. It's more of a try.

        """
    def get_tree_entries(self):
        """
        ']'
        """
    def exact_key_items(self):
        """

                Returns a generator of tuples like dict.items(), where the key is
                resolved (as a string) and the values are still lazy values.
        
        """
    def __repr__(self):
        """
        <%s of %s>
        """
def DictLiteralValue(_DictMixin, SequenceLiteralValue, _DictKeyMixin):
    """
    u'dict'
    """
    def __init__(self, inference_state, defining_context, atom):
        """
        Here the index is an int/str. Raises IndexError/KeyError.
        """
    def py__iter__(self, contextualized_node=None):
        """

                While values returns the possible values for any array field, this
                function returns the value for a certain index.
        
        """
    def _imitate_values(self, arguments):
        """
        'items'
        """
    def _imitate_items(self, arguments):
        """

                type should be one of "tuple", "list"
        
        """
    def py__simple_getitem__(self, index):
        """
        <%s of %s>
        """
def FakeTuple(_FakeSequence):
    """
    u'tuple'
    """
def FakeList(_FakeSequence):
    """
    u'tuple'
    """
def FakeDict(_DictMixin, Sequence, _DictKeyMixin):
    """
    u'dict'
    """
    def __init__(self, inference_state, dct):
        """
         In Python 2 bytes and unicode compare.

        """
    def _values(self, arguments):
        """
        '<%s: %s>'
        """
def MergedArray(Sequence):
    """

        Unpacking tuple assignments in for statements and expr_stmts.
    
    """
def Slice(LazyValueWrapper):
    """
     All of them are either a Precedence or None.

    """
    def _get_wrapped_value(self):
        """
        'slice'
        """
    def get_safe_value(self, default=sentinel):
        """

                Imitate CompiledValue.obj behavior and return a ``builtin.slice()``
                object.
        
        """
        def get(element):
            """
             For simplicity, we want slices to be clear defined with just
             one type.  Otherwise we will return an empty slice object.

            """
