def execute(callback):
    """
    'builtins'
    """
def _follow_param(inference_state, arguments, index):
    """

        Works like Argument Clinic (PEP 436), to validate function params.
    
    """
    def f(func):
        """
        'builtin start %s'
        """
def builtins_next(iterators, defaults, inference_state):
    """
    'next'
    """
def builtins_iter(iterators_or_callables, defaults):
    """
     TODO implement this if it's a callable.

    """
def builtins_getattr(objects, names, defaults=None):
    """
     follow the first param

    """
def builtins_type(objects, bases, dicts):
    """
     It's a type creation... maybe someday...

    """
def SuperInstance(LazyValueWrapper):
    """
    To be used like the object ``super`` returns.
    """
    def __init__(self, inference_state, instance):
        """
         Corresponds to super().__self__
        """
    def _get_bases(self):
        """
         This is just a fallback and will only be used, if it's not
         possible to find a class

        """
    def get_filters(self, origin_scope=None):
        """
        '[type[, value]], /'
        """
def builtins_super(types, objects, context):
    """
    'next'
    """
    def _next(self, arguments):
        """
        'sequence, /'
        """
def builtins_reversed(sequences, value, arguments):
    """
     While we could do without this variable (just by using sequences), we
     want static analysis to work well. Therefore we need to generated the
     values again.

    """
def builtins_isinstance(objects, types, arguments, inference_state):
    """
     This is temporary. Everything should have a class attribute in
     Python?! Maybe we'll leave it here, because some numpy objects or
     whatever might not.

    """
def StaticMethodObject(ValueWrapper):
    """
    'sequence, /'
    """
def builtins_staticmethod(functions):
    """
    '__get__'
    """
def ClassMethodGet(ValueWrapper):
    """
    'sequence, /'
    """
def builtins_classmethod(functions, value, arguments):
    """
    'deleter'
    """
    def _return_self(self, arguments):
        """
        'func, /'
        """
def builtins_property(functions, callback):
    """

        Implementation of the namedtuple function.

        This has to be done by processing the namedtuple class template and
        inferring the result.

    
    """
def PartialObject(ValueWrapper):
    """
    Partial should have a proper function %s
    """
    def get_signatures(self):
        """

                In CPython partial does not replace the docstring. However we are still
                imitating it here, because we want this docstring to be worth something
                for the user.
        
        """
    def py__get__(self, instance, class_value):
        """
         Ignore this one, it's the function. It was checked before that it's
         there.

        """
def functools_partial(value, arguments, callback):
    """
    'first, /'
    """
def _return_first_param(firsts):
    """
    'seq'
    """
def _random_choice(sequences):
    """
     .values ordering is not guaranteed, at least not in
     Python < 3.6, when dicts where not ordered, which is an
     implementation detail anyway.

    """
def DatadefSignature(AbstractSignature):
    """
    'item, /'
    """
    def py__call__(self, item_value_set):
        """
         TODO we need to add the contextualized value.

        """
def _functools_wraps(funcs):
    """
     XXX this is not the correct wrapped value, it should be a weird
         partials object, but it doesn't matter, because it's always used as a
         decorator anyway.

    """
    def py__call__(self, funcs):
        """
        '*args, /'
        """
def _operator_itemgetter(args_value_set, value, arguments):
    """
    'string, /'
    """
    def wrapper(strings, value, arguments):
        """
        '*args, /'
        """
def _os_path_join(args_set, callback):
    """
    u''
    """
def get_metaclass_filters(func):
    """
    'EnumMeta'
    """
def EnumInstance(LazyValueWrapper):
    """
     Corresponds to super().__self__
    """
    def name(self):
        """
        'sep'
        """
