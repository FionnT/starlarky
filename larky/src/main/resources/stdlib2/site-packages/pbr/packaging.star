def get_requirements_files():
    """
    PBR_REQUIREMENTS_FILES
    """
def append_text_list(config, key, text_list):
    """
    Append a \n separated list to possibly existing value.
    """
def _any_existing(file_list):
    """
     Get requirements from the first file that exists

    """
def get_reqs_from_files(requirements_files):
    """
     TODO(stephenfin): Remove this in pbr 6.0+

    """
def egg_fragment(match):
    """
    r'(?P<PackageName>[\w.-]+)-'
    r'(?P<GlobalVersion>'
    r'(?P<VersionTripple>'
    r'(?P<Major>0|[1-9][0-9]*)\.'
    r'(?P<Minor>0|[1-9][0-9]*)\.'
    r'(?P<Patch>0|[1-9][0-9]*)){1}'
    r'(?P<Tags>(?:\-'
    r'(?P<Prerelease>(?:(?=[0]{1}[0-9A-Za-z-]{0})(?:[0]{1})|'
    r'(?=[1-9]{1}[0-9]*[A-Za-z]{0})(?:[0-9]+)|'
    r'(?=[0-9]*[A-Za-z-]+[0-9A-Za-z-]*)(?:[0-9A-Za-z-]+)){1}'
    r'(?:\.(?=[0]{1}[0-9A-Za-z-]{0})(?:[0]{1})|'
    r'\.(?=[1-9]{1}[0-9]*[A-Za-z]{0})(?:[0-9]+)|'
    r'\.(?=[0-9]*[A-Za-z-]+[0-9A-Za-z-]*)'
    r'(?:[0-9A-Za-z-]+))*){1}){0,1}(?:\+'
    r'(?P<Meta>(?:[0-9A-Za-z-]+(?:\.[0-9A-Za-z-]+)*))){0,1}))'
    """
def parse_requirements(requirements_files=None, strip_markers=False):
    """
     Ignore comments

    """
def parse_dependency_links(requirements_files=None):
    """
     dependency_links inject alternate locations to find packages listed
     in requirements

    """
def InstallWithGit(install.install):
    """
    Extracts ChangeLog and AUTHORS from git then installs.

        This is useful for e.g. readthedocs where the package is
        installed and then docs built.
    
    """
    def run(self):
        """
        Runs python setup.py install in a sensible manner.

            Force a non-egg installed in the manner of
            single-version-externally-managed, which allows us to install manpages
            and config files.
    
        """
    def run(self):
        """
        Make setup.py test do the right thing.
        """
    def run(self):
        """
        'testr integration is deprecated in pbr 4.2 and will '
        'be removed in a future release. Please call your test '
        'runner directly'
        """
def LocalRPMVersion(setuptools.Command):
    """
    Output the rpm *compatible* version string of this package
    """
    def run(self):
        """
        [pbr] Extracting rpm version
        """
    def initialize_options(self):
        """
        Output the deb *compatible* version string of this package
        """
    def run(self):
        """
        [pbr] Extracting deb version
        """
    def initialize_options(self):
        """
        Fallback test runner if testr is a no-go.
        """
        def run(self):
            """
            'nose integration in pbr is deprecated. Please use '
            'the native nose setuptools configuration or call '
            'nose directly'
            """
def have_nose():
    """
    PBR Generated from %(group)r

    import threading

    from %(module_name)s import %(import_target)s

    if __name__ == "__main__":
        import argparse
        import socket
        import sys
        import wsgiref.simple_server as wss

        parser = argparse.ArgumentParser(
            description=%(import_target)s.__doc__,
            formatter_class=argparse.ArgumentDefaultsHelpFormatter,
            usage='%%(prog)s [-h] [--port PORT] [--host IP] -- [passed options]')
        parser.add_argument('--port', '-p', type=int, default=8000,
                            help='TCP port to listen on')
        parser.add_argument('--host', '-b', default='',
                            help='IP to bind the server to')
        parser.add_argument('args',
                            nargs=argparse.REMAINDER,
                            metavar='-- [passed options]',
                            help="'--' is the separator of the arguments used "
                            "to start the WSGI server and the arguments passed "
                            "to the WSGI application.")
        args = parser.parse_args()
        if args.args:
            if args.args[0] == '--':
                args.args.pop(0)
            else:
                parser.error("unrecognized arguments: %%s" %% ' '.join(args.args))
        sys.argv[1:] = args.args
        server = wss.make_server(args.host, args.port, %(invoke_target)s())

        print("*" * 80)
        print("STARTING test server %(module_name)s.%(invoke_target)s")
        url = "http://%%s:%%d/" %% (server.server_name, server.server_port)
        print("Available at %%s" %% url)
        print("DANGER! For testing only, do not use in production")
        print("*" * 80)
        sys.stdout.flush()

        server.serve_forever()
    else:
        application = None
        app_lock = threading.Lock()

        with app_lock:
            if application is None:
                application = %(invoke_target)s()


    """
def generate_script(group, entry_point, header, template):
    """
    Generate the script based on the template.

        :param str group:
            The entry-point group name, e.g., "console_scripts".
        :param str header:
            The first line of the script, e.g., "!#/usr/bin/env python".
        :param str template:
            The script template.
        :returns:
            The templated script content
        :rtype:
            str
    
    """
2021-03-02 20:53:25,308 : INFO : tokenize_signature : --> do i ever get here?
def override_get_script_args(
        dist, executable=os.path.normpath(sys.executable)):
    """
    Override entrypoints console_script.
    """
def LocalDevelop(develop.develop):
    """
    'develop'
    """
    def install_wrapper_scripts(self, dist):
        """
        'win32'
        """
def LocalInstallScripts(install_scripts.install_scripts):
    """
    Intercepts console scripts entry_points.
    """
    def _make_wsgi_scripts_only(self, dist, executable):
        """
         get_script_header() is deprecated since Setuptools 12.0

        """
    def run(self):
        """
        egg_info
        """
def LocalManifestMaker(egg_info.manifest_maker):
    """
    Add any files that are in git and some standard sensible files.
    """
    def _add_pbr_defaults(self):
        """
        'include AUTHORS'
        """
    def add_defaults(self):
        """
        Add all the default files to self.filelist:

                Extends the functionality provided by distutils to also included
                additional sane defaults, such as the ``AUTHORS`` and ``ChangeLog``
                files generated by *pbr*.

                Warns if (``README`` or ``README.txt``) or ``setup.py`` are missing;
                everything else is optional.
        
        """
def LocalEggInfo(egg_info.egg_info):
    """
    Override the egg_info command to regenerate SOURCES.txt sensibly.
    """
    def find_sources(self):
        """
        Generate SOURCES.txt only if there isn't one already.

                If we are in an sdist command, then we always want to update
                SOURCES.txt. If we are not in an sdist command, then it doesn't
                matter one flip, and is actually destructive.
                However, if we're in a git context, it's always the right thing to do
                to recreate SOURCES.txt
        
        """
def _from_git(distribution):
    """
    'pbr'
    """
def LocalSDist(sdist.sdist):
    """
    Builds the ChangeLog and Authors files from VC first.
    """
    def checking_reno(self):
        """
        Ensure reno is installed and configured.

                We can't run reno-based commands if reno isn't installed/available, and
                don't want to if the user isn't using it.
        
        """
    def run(self):
        """
         sdist.sdist is an old style class, can't use super()

        """
    def make_distribution(self):
        """
         This is included in make_distribution because setuptools doesn't use
         'get_file_list'. As such, this is the only hook point that runs after
         the commands in 'sub_commands'

        """
def have_sphinx():
    """
    Calculate the sort of semver increment needed from git history.

        Every commit from HEAD to tag is consider for Sem-Ver metadata lines.
        See the pbr docs for their syntax.

        :return: a dict of kwargs for passing into SemanticVersion.increment.
    
    """
    def _handle_symbol(symbol, symbols, impact):
        """
        'bugfix'
        """
def _get_revno_and_last_tag(git_dir):
    """
    Return the commit data about the most recent tag.

        We use git-describe to find this out, but if there are no
        tags then we fall back to counting commits since the beginning
        of time.
    
    """
def _get_version_from_git_target(git_dir, target_version):
    """
    Calculate a version from a target version in git_dir.

        This is used for untagged versions only. A new version is calculated as
        necessary based on git metadata - distance to tags, current hash, contents
        of commit messages.

        :param git_dir: The git directory we're working from.
        :param target_version: If None, the last tagged version (or 0 if there are
            no tags yet) is incremented as needed to produce an appropriate target
            version following semver rules. Otherwise target_version is used as a
            constraint - if semver rules would result in a newer version then an
            exception is raised.
        :return: A semver version object.
    
    """
def _get_version_from_git(pre_version=None):
    """
    Calculate a version string from git.

        If the revision is tagged, return that. Otherwise calculate a semantic
        version description of the tree.

        The number of revisions since the last tag is included in the dev counter
        in the version for untagged versions.

        :param pre_version: If supplied use this as the target version rather than
            inferring one from the last tag + commit messages.
    
    """
def _get_version_from_pkg_metadata(package_name):
    """
    Get the version from package metadata if present.

        This looks for PKG-INFO if present (for sdists), and if not looks
        for METADATA (for wheels) and failing that will return None.
    
    """
def get_version(package_name, pre_version=None):
    """
    Get the version of the project.

        First, try getting it from PKG-INFO or METADATA, if it exists. If it does,
        that means we're in a distribution tarball or that install has happened.
        Otherwise, if there is no PKG-INFO or METADATA file, pull the version
        from git.

        We do not support setup.py version sanity in git archive tarballs, nor do
        we support packagers directly sucking our git repo into theirs. We expect
        that a source tarball be made from our git repo - or that if someone wants
        to make a source tarball from a fork of our repo with additional tags in it
        that they understand and desire the results of doing that.

        :param pre_version: The version field from setup.cfg - if set then this
            version will be the next release.
    
    """
