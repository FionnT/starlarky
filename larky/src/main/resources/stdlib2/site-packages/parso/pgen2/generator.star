def Grammar(object):
    """

        Once initialized, this class supplies the grammar tables for the
        parsing engine implemented by parse.py.  The parsing engine
        accesses the instance variables directly.

        The only important part in this parsers are dfas and transitions between
        dfas.
    
    """
    def __init__(self, start_nonterminal, rule_to_dfas, reserved_syntax_strings):
        """
         Dict[str, List[DFAState]]
        """
def DFAPlan(object):
    """

        Plans are used for the parser to create stack nodes and do the proper
        DFA state transitions.
    
    """
    def __init__(self, next_dfa, dfa_pushes=[]):
        """
        '%s(%s, %s)'
        """
def DFAState(object):
    """

        The DFAState object is the core class for pretty much anything. DFAState
        are the vertices of an ordered graph while arcs and transitions are the
        edges.

        Arcs are the initial edges, where most DFAStates are not connected and
        transitions are then calculated to connect the DFA state machines that have
        different nonterminals.
    
    """
    def __init__(self, from_rule, nfa_set, final):
        """
         map from terminals/nonterminals to DFAState
        """
    def add_arc(self, next_, label):
        """
         Equality test -- ignore the nfa_set instance variable

        """
    def __repr__(self):
        """
        '<%s: %s is_final=%s>'
        """
def ReservedString(object):
    """

        Most grammars will have certain keywords and operators that are mentioned
        in the grammar as strings (e.g. "if") and not token types (e.g. NUMBER).
        This class basically is the former.
    
    """
    def __init__(self, value):
        """
        '%s(%s)'
        """
def _simplify_dfas(dfas):
    """

        This is not theoretically optimal, but works well enough.
        Algorithm: repeatedly look for two states that have the same
        set of arcs (same labels pointing to the same nodes) and
        unify them, until things stop changing.

        dfas is a list of DFAState instances
    
    """
def _make_dfas(start, finish):
    """

        Uses the powerset construction algorithm to create DFA states from sets of
        NFA states.

        Also does state reduction if some states are not needed.
    
    """
    def addclosure(nfa_state, base_nfa_set):
        """
         NB states grows while we're iterating
        """
def _dump_nfa(start, finish):
    """
    Dump of NFA for
    """
def _dump_dfas(dfas):
    """
    Dump of DFA for
    """
def generate_grammar(bnf_grammar, token_namespace):
    """

        ``bnf_text`` is a grammar in extended BNF (using * for repetition, + for
        at-least-once repetition, [] for optional parts, | for alternatives and ()
        for grouping).

        It's not EBNF according to ISO/IEC 14977. It's a dialect Python uses in its
        own parser.
    
    """
def _make_transition(token_namespace, reserved_syntax_strings, label):
    """

        Creates a reserved string ("if", "for", "*", ...) or returns the token type
        (NUMBER, STRING, ...) for a given grammar terminal.
    
    """
def _calculate_tree_traversal(nonterminal_to_dfas):
    """

        By this point we know how dfas can move around within a stack node, but we
        don't know how we can add a new stack node (nonterminal transitions).
    
    """
def _calculate_first_plans(nonterminal_to_dfas, first_plans, nonterminal):
    """

        Calculates the first plan in the first_plans dictionary for every given
        nonterminal. This is going to be used to know when to create stack nodes.
    
    """
