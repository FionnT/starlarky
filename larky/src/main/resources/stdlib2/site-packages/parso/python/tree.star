def DocstringMixin(object):
    """

            Returns the string leaf of a docstring. e.g. ``r'''foo'''``.
        
    """
def PythonMixin(object):
    """

        Some Python specific utilities.
    
    """
    def get_name_of_position(self, position):
        """

                Given a (line, column) tuple, returns a :py:class:`Name` or ``None`` if
                there is no name at that position.
        
        """
def PythonLeaf(PythonMixin, Leaf):
    """

            Basically calls :py:meth:`parso.tree.NodeOrLeaf.get_start_pos_of_prefix`.
        
    """
def _LeafWithoutNewlines(PythonLeaf):
    """

        Simply here to optimize performance.
    
    """
    def end_pos(self):
        """
         Python base classes

        """
def PythonBaseNode(PythonMixin, BaseNode):
    """
    'endmarker'
    """
    def __repr__(self):
        """
        <%s: prefix=%s end_pos=%s>
        """
def Newline(PythonLeaf):
    """
    Contains NEWLINE and ENDMARKER tokens.
    """
    def __repr__(self):
        """
        <%s: %s>
        """
def Name(_LeafWithoutNewlines):
    """

        A string. Sometimes it is important to know if the string belongs to a name
        or not.
    
    """
    def __repr__(self):
        """
        <%s: %s@%s,%s>
        """
    def is_definition(self, include_setitem=False):
        """

                Returns True if the name is being defined.
        
        """
    def get_definition(self, import_name_always=False, include_setitem=False):
        """

                Returns None if there's no definition for a name.

                :param import_name_always: Specifies if an import name is always a
                    definition. Normally foo in `from foo import bar` is not a
                    definition.
        
        """
def Literal(PythonLeaf):
    """
    'number'
    """
def String(Literal):
    """
    'string'
    """
    def string_prefix(self):
        """
        r'\w*(?=[\'"])'
        """
    def _get_payload(self):
        """
        r'''('{3}|"{3}|'|")(.*)$'''
        """
def FStringString(PythonLeaf):
    """

        f-strings contain f-string expressions and normal python strings. These are
        the string parts of f-strings.
    
    """
def FStringStart(PythonLeaf):
    """

        f-strings contain f-string expressions and normal python strings. These are
        the string parts of f-strings.
    
    """
def FStringEnd(PythonLeaf):
    """

        f-strings contain f-string expressions and normal python strings. These are
        the string parts of f-strings.
    
    """
def _StringComparisonMixin(object):
    """

            Make comparisons with strings easy.
            Improves the readability of the parser.
        
    """
    def __ne__(self, other):
        """
        Python 2 compatibility.
        """
    def __hash__(self):
        """
        'operator'
        """
def Keyword(_LeafWithoutNewlines, _StringComparisonMixin):
    """
    'keyword'
    """
def Scope(PythonBaseNode, DocstringMixin):
    """

        Super class for the parser tree, which represents the state of a python
        text file.
        A Scope is either a function, class or lambda.
    
    """
    def __init__(self, children):
        """

                Returns a generator of `funcdef` nodes.
        
        """
    def iter_classdefs(self):
        """

                Returns a generator of `classdef` nodes.
        
        """
    def iter_imports(self):
        """

                Returns a generator of `import_name` and `import_from` nodes.
        
        """
    def _search_in_scope(self, *names):
        """

                Returns the part that is executed by the function.
        
        """
    def __repr__(self):
        """
        ''
        """
def Module(Scope):
    """

        The top scope, which is always a module.
        Depending on the underlying parser this may be a full module or just a part
        of a module.
    
    """
    def __init__(self, children):
        """

                :return: A list of future import names.
                :rtype: list of str
        
        """
    def _has_explicit_absolute_import(self):
        """

                Checks if imports in this module are explicitly absolute, i.e. there
                is a ``__future__`` import.
                Currently not public, might be in the future.
                :return bool:
        
        """
    def get_used_names(self):
        """

                Returns all the :class:`Name` leafs that exist in this module. This
                includes both definitions and references of names.
        
        """
            def recurse(node):
                """
                'name'
                """
def Decorator(PythonBaseNode):
    """
    'decorator'
    """
def ClassOrFunc(Scope):
    """

            Returns the `Name` leaf that defines the function or class name.
        
    """
    def get_decorators(self):
        """

                :rtype: list of :class:`Decorator`
        
        """
def Class(ClassOrFunc):
    """

        Used to store the parsed contents of a python class.
    
    """
    def __init__(self, children):
        """

                Returns the `arglist` node that defines the super classes. It returns
                None if there are no arguments.
        
        """
def _create_params(parent, argslist_list):
    """

        `argslist_list` is a list that can contain an argslist as a first item, but
        most not. It's basically the items between the parameter brackets (which is
        at most one item).
        This function modifies the parser structure. It generates `Param` objects
        from the normal ast. Those param objects do not exist in a normal ast, but
        make the evaluation of the ast tree so much easier.
        You could also say that this function replaces the argslist node with a
        list of Param objects.
    
    """
    def check_python2_nested_param(node):
        """

                Python 2 allows params to look like ``def x(a, (b, c))``, which is
                basically a way of unpacking tuples in params. Python 3 has ditched
                this behavior. Jedi currently just ignores those constructs.
        
        """
def Function(ClassOrFunc):
    """

        Used to store the parsed contents of a python function.

        Children::

            0. <Keyword: def>
            1. <Name>
            2. parameter list (including open-paren and close-paren <Operator>s)
            3. or 5. <Operator: :>
            4. or 6. Node() representing function body
            3. -> (if annotation is also present)
            4. annotation (if present)
    
    """
    def __init__(self, children):
        """
         After `def foo`
        """
    def _get_param_nodes(self):
        """

                Returns a list of `Param()`.
        
        """
    def name(self):
        """
         First token after `def`
        """
    def iter_yield_exprs(self):
        """

                Returns a generator of `yield_expr`.
        
        """
        def scan(children):
            """
            'classdef'
            """
    def iter_return_stmts(self):
        """

                Returns a generator of `return_stmt`.
        
        """
        def scan(children):
            """
            'return_stmt'
            """
    def iter_raise_stmts(self):
        """

                Returns a generator of `raise_stmt`. Includes raise statements inside try-except blocks
        
        """
        def scan(children):
            """
            'raise_stmt'
            """
    def is_generator(self):
        """

                :return bool: Checks if a function is a generator or not.
        
        """
    def annotation(self):
        """

                Returns the test node after `->` or `None` if there is no annotation.
        
        """
def Lambda(Function):
    """

        Lambdas are basically trimmed functions, so give it the same interface.

        Children::

             0. <Keyword: lambda>
             *. <Param x> for each argument x
            -2. <Operator: :>
            -1. Node() representing body
    
    """
    def __init__(self, children):
        """
         We don't want to call the Function constructor, call its parent.

        """
    def name(self):
        """

                Raises an AttributeError. Lambdas don't have a defined name.
        
        """
    def _get_param_nodes(self):
        """

                Returns `None`, lambdas don't have annotations.
        
        """
    def __repr__(self):
        """
        <%s@%s>
        """
def Flow(PythonBaseNode):
    """
    'if_stmt'
    """
    def get_test_nodes(self):
        """

                E.g. returns all the `test` nodes that are named as x, below:

                    if x:
                        pass
                    elif x:
                        pass
        
        """
    def get_corresponding_test_node(self, node):
        """

                Searches for the branch in which the node is and returns the
                corresponding test node (see function above). However if the node is in
                the test node itself and not in the suite return None.
        
        """
    def is_node_after_else(self, node):
        """

                Checks if a node is defined after `else`.
        
        """
def WhileStmt(Flow):
    """
    'while_stmt'
    """
def ForStmt(Flow):
    """
    'for_stmt'
    """
    def get_testlist(self):
        """

                Returns the input node ``y`` from: ``for x in y:``.
        
        """
    def get_defined_names(self, include_setitem=False):
        """
        'try_stmt'
        """
    def get_except_clause_tests(self):
        """

                Returns the ``test`` nodes found in ``except_clause`` nodes.
                Returns ``[None]`` for except clauses without an exception given.
        
        """
def WithStmt(Flow):
    """
    'with_stmt'
    """
    def get_defined_names(self, include_setitem=False):
        """

                Returns the a list of `Name` that the with statement defines. The
                defined names are set after `as`.
        
        """
    def get_test_node_from_name(self, name):
        """
        'with_item'
        """
def Import(PythonBaseNode):
    """

            The path is the list of names that leads to the searched name.

            :return list of Name:
        
    """
    def is_nested(self):
        """
         By default, sub classes may overwrite this behavior
        """
    def is_star_import(self):
        """
        '*'
        """
def ImportFrom(Import):
    """
    'import_from'
    """
    def get_defined_names(self, include_setitem=False):
        """

                Returns the a list of `Name` that the import defines. The
                defined names are set after `import` or in case an alias - `as` - is
                present that name is returned.
        
        """
    def _aliases(self):
        """
        Mapping from alias to its corresponding name.
        """
    def get_from_names(self):
        """
        '.'
        """
    def level(self):
        """
        The level parameter of ``__import__``.
        """
    def _as_name_tuples(self):
        """
        ')'
        """
    def get_paths(self):
        """

                The import paths defined in an import statement. Typically an array
                like this: ``[<Name: datetime>, <Name: date>]``.

                :return list of list of Name:
        
        """
def ImportName(Import):
    """
    For ``import_name`` nodes. Covers normal imports without ``from``.
    """
    def get_defined_names(self, include_setitem=False):
        """

                Returns the a list of `Name` that the import defines. The defined names
                is always the first name after `import` or in case an alias - `as` - is
                present that name is returned.
        
        """
    def level(self):
        """
        The level parameter of ``__import__``.
        """
    def get_paths(self):
        """
        Generator of (list(path), alias) where alias may be None.
        """
    def is_nested(self):
        """

                This checks for the special case of nested imports, without aliases and
                from statement::

                    import foo.bar
        
        """
    def _aliases(self):
        """

                :return list of Name: Returns all the alias
        
        """
def KeywordStatement(PythonBaseNode):
    """

        For the following statements: `assert`, `del`, `global`, `nonlocal`,
        `raise`, `return`, `yield`.

        `pass`, `continue` and `break` are not in there, because they are just
        simple keywords and the parser reduces it to a keyword.
    
    """
    def type(self):
        """

                Keyword statements start with the keyword and end with `_stmt`. You can
                crosscheck this with the Python grammar.
        
        """
    def keyword(self):
        """
        'del'
        """
def AssertStmt(KeywordStatement):
    """
    'yield_expr'
    """
def _defined_names(current, include_setitem):
    """

        A helper function to find the defined names in statements, for loops and
        list comprehensions.
    
    """
def ExprStmt(PythonBaseNode, DocstringMixin):
    """
    'expr_stmt'
    """
    def get_defined_names(self, include_setitem=False):
        """

                Returns a list of `Name` defined before the `=` sign.
        
        """
    def get_rhs(self):
        """
        Returns the right-hand-side of the equals.
        """
    def yield_operators(self):
        """

                Returns a generator of `+=`, `=`, etc. or None if there is no operation.
        
        """
def Param(PythonBaseNode):
    """

        It's a helper class that makes business logic with params much easier. The
        Python grammar defines no ``param`` node. It defines it in a different way
        that is not really suited to working with parameters.
    
    """
    def __init__(self, children, parent):
        """

                Is `0` in case of `foo`, `1` in case of `*foo` or `2` in case of
                `**foo`.
        
        """
    def default(self):
        """

                The default is the test node that appears after the `=`. Is `None` in
                case no default is present.
        
        """
    def annotation(self):
        """

                The default is the test node that appears after `:`. Is `None` in case
                no annotation is present.
        
        """
    def _tfpdef(self):
        """

                tfpdef: see e.g. grammar36.txt.
        
        """
    def name(self):
        """

                The `Name` leaf of the param.
        
        """
    def get_defined_names(self, include_setitem=False):
        """

                Property for the positional index of a paramter.
        
        """
    def get_parent_function(self):
        """

                Returns the function/lambda of a parameter.
        
        """
    def get_code(self, include_prefix=True, include_comma=True):
        """

                Like all the other get_code functions, but includes the param
                `include_comma`.

                :param include_comma bool: If enabled includes the comma in the string output.
        
        """
    def __repr__(self):
        """
        ''
        """
def SyncCompFor(PythonBaseNode):
    """
    'sync_comp_for'
    """
    def get_defined_names(self, include_setitem=False):
        """

                Returns the a list of `Name` that the comprehension defines.
        
        """
def UsedNamesMapping(Mapping):
    """

        This class exists for the sole purpose of creating an immutable dict.
    
    """
    def __init__(self, dct):
        """
         Comparing these dicts does not make sense.

        """
