def _get_rhs_name(node, version):
    """
    lambdef
    """
def _iter_stmts(scope):
    """

        Iterates over all statements and splits up  simple_stmt.
    
    """
def _get_comprehension_type(atom):
    """
    'testlist_comp'
    """
def _is_future_import(import_from):
    """
     It looks like a __future__ import that is relative is still a future
     import. That feels kind of odd, but whatever.
     if import_from.level != 0:
         return False

    """
def _remove_parens(atom):
    """

        Returns the inner part of an expression like `(foo)`. Also removes nested
        parens.
    
    """
def _iter_params(parent_node):
    """
    'param'
    """
def _is_future_import_first(import_from):
    """

        Checks if the import is the first statement of a file.
    
    """
def _iter_definition_exprs_from_lists(exprlist):
    """
    'atom'
    """
def _get_expr_stmt_definition_exprs(expr_stmt):
    """
    'testlist_star_expr'
    """
def _get_for_stmt_definition_exprs(for_stmt):
    """
    error_node
    """
def _Context(object):
    """
     Stupidly enough async funcdefs can have two different forms,
     depending if a decorator is used or not.

    """
    def is_function(self):
        """
        'funcdef'
        """
    def add_name(self, name):
        """
        'trailer'
        """
    def finalize(self):
        """

                Returns a list of nonlocal names that need to be part of that scope.
        
        """
    def _analyze_names(self, globals_or_nonlocals, type_):
        """
        'funcdef'
        """
    def add_block(self, node):
        """

            Searches for errors in the syntax tree.
    
        """
    def __init__(self, *args, **kwargs):
        """
        'classdef'
        """
    def visit(self, node):
        """
        'error_node'
        """
    def visit_node(self, node):
        """
        too many statically nested blocks
        """
    def visit_leaf(self, leaf):
        """
        'error_leaf'
        """
    def _add_indentation_error(self, spacing, message):
        """
        IndentationError: 
        """
    def _add_syntax_error(self, node, message):
        """
        SyntaxError: 
        """
    def add_issue(self, node, code, message):
        """
         Overwrite the default behavior.
         Check if the issues are on the same line.

        """
    def finalize(self):
        """
        IndentationError: 
        """
def _ExpectIndentedBlock(IndentationRule):
    """
    'expected an indented block'
    """
    def get_node(self, node):
        """
         This is the beginning of a suite that is not indented.

        """
def ErrorFinderConfig(NormalizerConfig):
    """
    f-string
    """
def _InvalidSyntaxRule(SyntaxRule):
    """
    invalid syntax
    """
    def get_node(self, node):
        """
        'error_leaf'
        """
def _AwaitOutsideAsync(SyntaxRule):
    """
    'await' outside async function
    """
    def is_issue(self, leaf):
        """
         Return the whole await statement.

        """
def _BreakOutsideLoop(SyntaxRule):
    """
    'break' outside loop
    """
    def is_issue(self, leaf):
        """
        'for_stmt'
        """
def _ContinueChecks(SyntaxRule):
    """
    'continue' not properly in loop
    """
    def is_issue(self, leaf):
        """
        'for_stmt'
        """
def _YieldFromCheck(SyntaxRule):
    """
    'yield from' inside async function
    """
    def get_node(self, leaf):
        """
         This is the actual yield statement.
        """
    def is_issue(self, leaf):
        """
        'yield_arg'
        """
def _NameChecks(SyntaxRule):
    """
    'cannot assign to __debug__'
    """
    def is_issue(self, leaf):
        """
        '__debug__'
        """
def _StringChecks(SyntaxRule):
    """
    bytes can only contain ASCII literal characters.
    """
    def is_issue(self, leaf):
        """
        'b'
        """
def _StarCheck(SyntaxRule):
    """
    named arguments must follow bare *
    """
    def is_issue(self, leaf):
        """
        'parameters'
        """
def _StarStarCheck(SyntaxRule):
    """
     e.g. {**{} for a in [1]}
     TODO this should probably get a better end_pos including
          the next sibling of leaf.

    """
    def is_issue(self, leaf):
        """
        'dictorsetmaker'
        """
def _ReturnAndYieldChecks(SyntaxRule):
    """
    'return' with value in async generator
    """
    def get_node(self, leaf):
        """
        'funcdef'
        """
def _BytesAndStringMix(SyntaxRule):
    """
     e.g. 's' b''

    """
    def _is_bytes_literal(self, string):
        """
        'fstring'
        """
    def is_issue(self, node):
        """
         In Python 2 it's allowed to mix bytes and unicode.

        """
def _TrailingImportComma(SyntaxRule):
    """
     e.g. from foo import a,

    """
    def is_issue(self, node):
        """
        ','
        """
def _ImportStarInFunction(SyntaxRule):
    """
    import * only allowed at module level
    """
    def is_issue(self, node):
        """
        'import_from'
        """
def _FutureImportRule(SyntaxRule):
    """
    from __future__ imports must occur at the beginning of the file
    """
    def is_issue(self, node):
        """
        'generator_stop'
        """
def _StarExprRule(SyntaxRule):
    """
    iterable unpacking cannot be used in comprehension
    """
    def is_issue(self, node):
        """
        'testlist_comp'
        """
def _StarExprParentRule(SyntaxRule):
    """
    'del_stmt'
    """
            def is_definition(node, ancestor):
                """
                'trailer'
                """
def _AnnotatorRule(SyntaxRule):
    """
     True: int
     {}: float

    """
    def get_node(self, node):
        """
        ','
        """
def _ArgumentRule(SyntaxRule):
    """
     a((b)=c) is valid in <3.8

    """
def _NonlocalModuleLevelRule(SyntaxRule):
    """
    nonlocal declaration not allowed at module level
    """
    def is_issue(self, node):
        """
        'arglist'
        """
def _ArglistRule(SyntaxRule):
    """
    Generator expression must be parenthesized if not sole argument
    """
    def is_issue(self, node):
        """
         In python 3 this would be a bit easier (stars are part of
         argument), but we have to understand both.

        """
def _ParameterRule(SyntaxRule):
    """
     def f(x=3, y): pass

    """
    def is_issue(self, node):
        """
        duplicate argument '%s' in function definition
        """
def _TryStmtRule(SyntaxRule):
    """
    default 'except:' must be last
    """
    def is_issue(self, try_stmt):
        """
        'else'
        """
def _FStringRule(SyntaxRule):
    """
    f-string expression part cannot include a backslash
    """
    def _check_format_spec(self, format_spec, depth):
        """
        '\\'
        """
    def is_issue(self, fstring):
        """
        'fstring_expr'
        """
def _CheckAssignmentRule(SyntaxRule):
    """
    'lambdef'
    """
def _CompForRule(_CheckAssignmentRule):
    """
    asynchronous comprehension outside of an asynchronous function
    """
    def is_issue(self, node):
        """
        'expr_list'
        """
def _ExprStmtRule(_CheckAssignmentRule):
    """
    illegal expression for augmented assignment
    """
    def is_issue(self, node):
        """
        '='
        """
def _WithItemRule(_CheckAssignmentRule):
    """
    'del_stmt'
    """
def _DelStmtRule(_CheckAssignmentRule):
    """
    'expr_list'
    """
def _ExprListRule(_CheckAssignmentRule):
    """
    'for_stmt'
    """
def _ForStmtRule(_CheckAssignmentRule):
    """
     Some of the nodes here are already used, so no else if

    """
def _NamedExprRule(_CheckAssignmentRule):
    """
     namedexpr_test: test [':=' test]


    """
    def is_issue(self, namedexpr_test):
        """
         assigned name

        """
        def search_namedexpr_in_comp_for(node):
            """
            'sync_comp_for'
            """
        def process_comp_for(comp_for):
            """
            'sync_comp_for'
            """
        def search_all_comp_ancestors(node):
            """
            'testlist_comp'
            """
