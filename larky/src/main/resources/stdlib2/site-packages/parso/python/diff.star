def _is_indentation_error_leaf(node):
    """
    'error_leaf'
    """
def _get_previous_leaf_if_indentation(leaf):
    """

        Checks if the parent/children relationship is correct.

        This is a check that only runs during debugging/testing.
    
    """
def _assert_nodes_are_equal(node1, node2):
    """
    'children'
    """
def _get_debug_error_message(module, old_lines, new_lines):
    """
    There's an issue with the diff parser. Please 
    report (parso v%s) - Old/New:\n%s\nActual Diff (May be empty):\n%s

    """
def _get_last_line(node_or_leaf):
    """
    'endmarker'
    """
def _skip_dedent_error_leaves(leaf):
    """
    'error_leaf'
    """
def _ends_with_newline(leaf, suffix=''):
    """
    'error_leaf'
    """
def _flows_finished(pgen_grammar, stack):
    """

        if, while, for and try might not be finished, because another part might
        still be parsed.
    
    """
def _func_or_class_has_suite(node):
    """
    'decorated'
    """
def _suite_or_file_input_is_valid(pgen_grammar, stack):
    """
    'decorator'
    """
def _is_flow_node(node):
    """
    'async_stmt'
    """
def _PositionUpdatingFinished(Exception):
    """
     Is a leaf

    """
def DiffParser(object):
    """

        An advanced form of parsing a file faster. Unfortunately comes with huge
        side effects. It changes the given module.
    
    """
    def __init__(self, pgen_grammar, tokenizer, module):
        """
        '''
                The algorithm works as follows:

                Equal:
                    - Assure that the start is a newline, otherwise parse until we get
                      one.
                    - Copy from parsed_until_line + 1 to max(i2 + 1)
                    - Make sure that the indentation is correct (e.g. add DEDENT)
                    - Add old and change positions
                Insert:
                    - Parse from parsed_until_line + 1 to min(j2 + 1), hopefully not
                      much more.

                Returns the new module node.
                '''
        """
    def _enabled_debugging(self, old_lines, lines_new):
        """
        ''
        """
    def _copy_from_old_parser(self, line_offset, start_line_old, until_line_old, until_line_new):
        """
         Parse 1 line at least. We don't need more, because we just
         want to get into a state where the old parser has statements
         again that can be copied (e.g. not lines within parentheses).

        """
    def _get_old_line_stmt(self, old_line):
        """
        'file_input'
        """
    def _parse(self, until_line):
        """

                Parses at least until the given line, but might just parse more until a
                valid state is reached.
        
        """
    def _try_parse_part(self, until_line):
        """

                Sets up a normal parser that uses a spezialized tokenizer to only parse
                until a certain position (or a bit longer if the statement hasn't
                ended.
        
        """
    def _diff_tokenize(self, lines, until_line, line_offset=0):
        """
         print('start', line_offset + 1, indents)

        """
def _NodesTreeNode(object):
    """
    '_ChildrenGroup'
    """
    def __init__(self, tree_node, parent=None, indentation=0):
        """
         Reset the parents

        """
    def add_child_node(self, child_node):
        """
         Newlines end on the next line, which means that they would cover
         the next line. That line is not fully parsed at this point.

        """
    def __repr__(self):
        """
        '<%s: %s>'
        """
def _NodesTree(object):
    """
    ''
    """
    def parsed_until_line(self):
        """
        'newline'
        """
    def _update_parsed_node_tos(self, tree_node, keyword_token_indents):
        """
        'suite'
        """
    def _remove_endmarker(self, tree_nodes):
        """

                Helps cleaning up the tree nodes that get inserted.
        
        """
    def _get_matching_indent_nodes(self, tree_nodes, is_new_suite):
        """
         There might be a random dedent where we have to stop copying.
         Invalid indents are ok, because the parser handled that
         properly before. An invalid dedent can happen, because a few
         lines above there was an invalid indent.

        """
    def copy_nodes(self, tree_nodes, until_line, line_offset):
        """

                Copies tree nodes from the old parser tree.

                Returns the number of tree nodes that were copied.
        
        """
2021-03-02 20:52:41,632 : INFO : tokenize_signature : --> do i ever get here?
    def _copy_nodes(self, working_stack, nodes, until_line, line_offset,
                    prefix='', is_nested=False):
        """
        ''
        """
    def close(self):
        """
         Add an endmarker.

        """
