def Trace(object):
    """
    A tracing class
    """
  def debug(cls, message):
    """
    Show a debug message
    """
  def message(cls, message):
    """
    Show a trace message
    """
  def error(cls, message):
    """
    Show an error message
    """
  def fatal(cls, message):
    """
    Show an error message and terminate
    """
  def show(cls, message, channel):
    """
    Show a message out of a channel
    """
def BibStylesConfig(object):
    """
    Configuration class from elyxer.config file
    """
def BibTeXConfig(object):
    """
    Configuration class from elyxer.config file
    """
def ContainerConfig(object):
    """
    Configuration class from elyxer.config file
    """
def EscapeConfig(object):
    """
    Configuration class from elyxer.config file
    """
def FormulaConfig(object):
    """
    Configuration class from elyxer.config file
    """
def GeneralConfig(object):
    """
    Configuration class from elyxer.config file
    """
def HeaderConfig(object):
    """
    Configuration class from elyxer.config file
    """
def ImageConfig(object):
    """
    Configuration class from elyxer.config file
    """
def LayoutConfig(object):
    """
    Configuration class from elyxer.config file
    """
def NewfangleConfig(object):
    """
    Configuration class from elyxer.config file
    """
def NumberingConfig(object):
    """
    Configuration class from elyxer.config file
    """
def StyleConfig(object):
    """
    Configuration class from elyxer.config file
    """
def TOCConfig(object):
    """
    Configuration class from elyxer.config file
    """
def TagConfig(object):
    """
    Configuration class from elyxer.config file
    """
def TranslationConfig(object):
    """
    Configuration class from elyxer.config file
    """
def CommandLineParser(object):
    """
    A parser for runtime options
    """
  def __init__(self, options):
    """
    Parse command line options
    """
  def readoption(self, args):
    """
    Read the key and value for an option
    """
  def readquoted(self, args, initial):
    """
    Read a value between quotes
    """
  def readequalskey(self, arg, args):
    """
    Read a key using equals
    """
def Options(object):
    """
    A set of runtime options
    """
  def parseoptions(self, args):
    """
    Parse command line options
    """
  def processoptions(self):
    """
    Process all options parsed.
    """
  def usage(self):
    """
    Show correct usage
    """
  def parsefootnotes(self):
    """
    Parse footnotes options.
    """
  def showoptions(self):
    """
    Show all possible options
    """
  def showversion(self):
    """
    Return the current eLyXer version string
    """
  def showhardversion(self):
    """
    Return just the version string
    """
  def showversiondate(self):
    """
    Return just the version dte
    """
  def showlyxformat(self):
    """
    Return just the lyxformat parameter
    """
def BranchOptions(object):
    """
    A set of options for a branch
    """
  def __init__(self, name):
    """
    'color'
    """
  def set(self, key, value):
    """
    Set a branch option
    """
  def isselected(self):
    """
    Return if the branch is selected
    """
  def __unicode__(self):
    """
    String representation
    """
def Cloner(object):
    """
    An object used to clone other objects.
    """
  def clone(cls, original):
    """
    Return an exact copy of an object.
    """
  def create(cls, type):
    """
    Create an object of a given class.
    """
def ContainerExtractor(object):
    """
    A class to extract certain containers.
    """
  def __init__(self, config):
    """
    The config parameter is a map containing three lists: allowed, copied and extracted.
    """
  def extract(self, container):
    """
    Extract a group of selected containers from elyxer.a container.
    """
  def process(self, container, list):
    """
    Add allowed containers, clone cloned containers and add the clone.
    """
  def safeclone(self, container):
    """
    Return a new container with contents only in a safe list, recursively.
    """
def Parser(object):
    """
    A generic parser
    """
  def __init__(self):
    """
    Parse the header
    """
  def parseparameter(self, reader):
    """
    Parse a parameter
    """
  def parsexml(self, reader):
    """
    Parse a parameter in xml form: <param attr1=value...>
    """
  def parseending(self, reader, process):
    """
    Parse until the current ending is found
    """
  def parsecontainer(self, reader, contents):
    """
    Return a description
    """
def LoneCommand(Parser):
    """
    A parser for just one command line
    """
  def parse(self, reader):
    """
    Read nothing
    """
def TextParser(Parser):
    """
    A parser for a command and a bit of text
    """
  def __init__(self, container):
    """
    Parse lines as long as they are text
    """
  def isending(self, reader):
    """
    Check if text is ending
    """
def ExcludingParser(Parser):
    """
    A parser that excludes the final line
    """
  def parse(self, reader):
    """
    Parse everything up to (and excluding) the final line
    """
def BoundedParser(ExcludingParser):
    """
    A parser bound by a final line
    """
  def parse(self, reader):
    """
    Parse everything, including the final line
    """
def BoundedDummy(Parser):
    """
    A bound parser that ignores everything
    """
  def parse(self, reader):
    """
    Parse the contents of the container
    """
def StringParser(Parser):
    """
    Parses just a string
    """
  def parseheader(self, reader):
    """
    Do nothing, just take note
    """
  def parse(self, reader):
    """
    Parse a single line
    """
def InsetParser(BoundedParser):
    """
    Parses a LyX inset
    """
  def parse(self, reader):
    """
    Parse inset parameters into a dictionary
    """
def ContainerOutput(object):
    """
    The generic HTML output for a container.
    """
  def gethtml(self, container):
    """
    Show an error.
    """
  def isempty(self):
    """
    Decide if the output is empty: by default, not empty.
    """
def EmptyOutput(ContainerOutput):
    """
    Return empty HTML code.
    """
  def isempty(self):
    """
    This output is particularly empty.
    """
def FixedOutput(ContainerOutput):
    """
    Fixed output
    """
  def gethtml(self, container):
    """
    Return constant HTML code
    """
def ContentsOutput(ContainerOutput):
    """
    Outputs the contents converted to HTML
    """
  def gethtml(self, container):
    """
    Return the HTML code
    """
def TaggedOutput(ContentsOutput):
    """
    Outputs an HTML tag surrounding the contents.
    """
  def settag(self, tag, breaklines=False, empty=False):
    """
    Set the value for the tag and other attributes.
    """
  def setbreaklines(self, breaklines):
    """
    Set the value for breaklines.
    """
  def gethtml(self, container):
    """
    Return the HTML code.
    """
  def open(self, container):
    """
    Get opening line.
    """
  def close(self, container):
    """
    Get closing line.
    """
  def selfclosing(self, container):
    """
    Get self-closing line.
    """
  def checktag(self, container):
    """
    Check that the tag is valid.
    """
def FilteredOutput(ContentsOutput):
    """
    Returns the output in the contents, but filtered:
    """
  def __init__(self):
    """
    Initialize the filters.
    """
  def addfilter(self, original, replacement):
    """
    Add a new filter: replace the original by the replacement.
    """
  def gethtml(self, container):
    """
    Return the HTML code
    """
  def filter(self, line):
    """
    Filter a single line with all available filters.
    """
def StringOutput(ContainerOutput):
    """
    Returns a bare string as output
    """
  def gethtml(self, container):
    """
    Return a bare string
    """
def LineReader(object):
    """
    Reads a file line by line
    """
  def __init__(self, filename):
    """
    'rU'
    """
  def setstart(self, firstline):
    """
    Set the first line to read.
    """
  def setend(self, lastline):
    """
    Set the last line to read.
    """
  def currentline(self):
    """
    Get the current line
    """
  def nextline(self):
    """
    Go to next line
    """
  def readline(self):
    """
    Read a line from elyxer.file
    """
  def finished(self):
    """
    Find out if the file is finished
    """
  def close(self):
    """
    Writes a file as a series of lists
    """
  def __init__(self, filename):
    """
    Write a list of strings
    """
  def writestring(self, string):
    """
    Write a string
    """
  def writeline(self, line):
    """
    Write a line to file
    """
  def close(self):
    """
    A bit of text which can be globbed (lumped together in bits).
      Methods current(), skipcurrent(), checkfor() and isout() have to be
      implemented by subclasses.
    """
  def __init__(self):
    """
    Check for a Unicode byte mark and skip it.
    """
  def isout(self):
    """
    Find out if we are out of the position yet.
    """
  def current(self):
    """
    Return the current character.
    """
  def checkfor(self, string):
    """
    Check for the given string in the current position.
    """
  def finished(self):
    """
    Find out if the current text has finished.
    """
  def skipcurrent(self):
    """
    Return the current character and skip it.
    """
  def glob(self, currentcheck):
    """
    Glob a bit of text that satisfies a check on the current char.
    """
  def globalpha(self):
    """
    Glob a bit of alpha text
    """
  def globnumber(self):
    """
    Glob a row of digits.
    """
  def isidentifier(self):
    """
    Return if the current character is alphanumeric or _.
    """
  def globidentifier(self):
    """
    Glob alphanumeric and _ symbols.
    """
  def isvalue(self):
    """
    Return if the current character is a value character:
    """
  def globvalue(self):
    """
    Glob a value: any symbols but brackets.
    """
  def skipspace(self):
    """
    Skip all whitespace at current position.
    """
  def globincluding(self, magicchar):
    """
    Glob a bit of text up to (including) the magic char.
    """
  def globexcluding(self, excluded):
    """
    Glob a bit of text up until (excluding) any excluded character.
    """
  def pushending(self, ending, optional = False):
    """
    Push a new ending to the bottom
    """
  def popending(self, expected = None):
    """
    Pop the ending found at the current position
    """
  def nextending(self):
    """
    Return the next ending in the queue.
    """
def EndingList(object):
    """
    A list of position endings
    """
  def __init__(self):
    """
    Add a new ending to the list
    """
  def pickpending(self, pos):
    """
    Pick any pending endings from a parse position.
    """
  def checkin(self, pos):
    """
    Search for an ending
    """
  def pop(self, pos):
    """
    Remove the ending at the current position
    """
  def findending(self, pos):
    """
    Find the ending at the current position
    """
  def checkpending(self):
    """
    Check if there are any pending endings
    """
  def __unicode__(self):
    """
    Printable representation
    """
def PositionEnding(object):
    """
    An ending for a parsing position
    """
  def __init__(self, ending, optional):
    """
    Check for the ending
    """
  def __unicode__(self):
    """
    Printable representation
    """
def Position(Globable):
    """
    A position in a text to parse.
      Including those in Globable, functions to implement by subclasses are:
      skip(), identifier(), extract(), isout() and current().
    """
  def __init__(self):
    """
    Skip a string
    """
  def identifier(self):
    """
    Return an identifier for the current position.
    """
  def extract(self, length):
    """
    Extract the next string of the given length, or None if not enough text,
    """
  def checkfor(self, string):
    """
    Check for a string at the given position.
    """
  def checkforlower(self, string):
    """
    Check for a string in lower case.
    """
  def skipcurrent(self):
    """
    Return the current character and skip it.
    """
  def __next__(self):
    """
    Advance the position and return the next character.
    """
  def checkskip(self, string):
    """
    Check for a string at the given position; if there, skip it
    """
  def error(self, message):
    """
    Show an error message and the position identifier.
    """
def TextPosition(Position):
    """
    A parse position based on a raw text.
    """
  def __init__(self, text):
    """
    Create the position from elyxer.some text.
    """
  def skip(self, string):
    """
    Skip a string of characters.
    """
  def identifier(self):
    """
    Return a sample of the remaining text.
    """
  def isout(self):
    """
    Find out if we are out of the text yet.
    """
  def current(self):
    """
    Return the current character, assuming we are not out.
    """
  def extract(self, length):
    """
    Extract the next string of the given length, or None if not enough text.
    """
def FilePosition(Position):
    """
    A parse position based on an underlying file.
    """
  def __init__(self, filename):
    """
    Create the position from a file.
    """
  def skip(self, string):
    """
    Skip a string of characters.
    """
  def currentline(self):
    """
    Get the current line of the underlying file.
    """
  def nextline(self):
    """
    Go to the next line.
    """
  def linenumber(self):
    """
    Return the line number of the file.
    """
  def identifier(self):
    """
    Return the current line and line number in the file.
    """
  def isout(self):
    """
    Find out if we are out of the text yet.
    """
  def current(self):
    """
    Return the current character, assuming we are not out.
    """
  def extract(self, length):
    """
    Extract the next string of the given length, or None if not enough text.
    """
def Container(object):
    """
    A container for text and objects in a lyx file
    """
  def __init__(self):
    """
    Process contents
    """
  def gethtml(self):
    """
    Get the resulting HTML
    """
  def escapeall(self, lines):
    """
    Escape all lines in an array according to the output options.
    """
  def escape(self, line, replacements = EscapeConfig.entities):
    """
    Escape a line with replacements from elyxer.a map
    """
  def escapeentities(self, line):
    """
    Escape all Unicode characters to HTML entities.
    """
  def searchall(self, type):
    """
    Search for all embedded containers of a given type
    """
  def searchremove(self, type):
    """
    Search for all containers of a type and remove them
    """
  def searchprocess(self, type, process):
    """
    Search for elements of a given type and process them
    """
  def locateprocess(self, locate, process):
    """
    Search for all embedded containers and process them
    """
  def recursivesearch(self, locate, recursive, process):
    """
    Perform a recursive search in the container.
    """
  def extracttext(self):
    """
    Extract all text from elyxer.allowed containers.
    """
  def group(self, index, group, isingroup):
    """
    Group some adjoining elements into a group
    """
  def remove(self, index):
    """
    Remove a container but leave its contents
    """
  def tree(self, level = 0):
    """
    Show in a tree
    """
  def getparameter(self, name):
    """
    Get the value of a parameter, if present.
    """
  def getparameterlist(self, name):
    """
    Get the value of a comma-separated parameter as a list.
    """
  def hasemptyoutput(self):
    """
    Check if the parent's output is empty.
    """
  def __unicode__(self):
    """
    Get a description
    """
def BlackBox(Container):
    """
    A container that does not output anything
    """
  def __init__(self):
    """
    Read the lyxformat command
    """
  def process(self):
    """
    Show warning if version < 276
    """
def StringContainer(Container):
    """
    A container for a single string
    """
  def __init__(self):
    """
    ''
    """
  def process(self):
    """
    Replace special chars from elyxer.the contents.
    """
  def replacespecial(self, line):
    """
    Replace all special chars from elyxer.a line
    """
  def changeline(self, line):
    """
    'startcommand'
    """
  def extracttext(self):
    """
    Return all text.
    """
  def __unicode__(self):
    """
    Return a printable representation.
    """
def Constant(StringContainer):
    """
    A constant string
    """
  def __init__(self, text):
    """
    'Constant: '
    """
def TaggedText(Container):
    """
    Text inside a tag
    """
  def __init__(self):
    """
    Complete the tagged text and return it
    """
  def constant(self, text, tag, breaklines=False):
    """
    Complete the tagged text with a constant
    """
  def __unicode__(self):
    """
    Return a printable representation.
    """
def DocumentParameters(object):
    """
    Global parameters for the document.
    """
def FormulaParser(Parser):
    """
    Parses a formula
    """
  def parseheader(self, reader):
    """
    See if the formula is inlined
    """
  def parsetype(self, reader):
    """
    Get the formula type from the first line.
    """
  def parse(self, reader):
    """
    Parse the formula until the end
    """
  def parseformula(self, reader):
    """
    Parse the formula contents
    """
  def parsesingleliner(self, reader, start, ending):
    """
    Parse a formula in one line
    """
  def parsemultiliner(self, reader, start, ending):
    """
    Parse a formula in multiple lines
    """
def MacroParser(FormulaParser):
    """
    A parser for a formula macro.
    """
  def parseheader(self, reader):
    """
    See if the formula is inlined
    """
  def parse(self, reader):
    """
    Parse the formula until the end
    """
def FormulaBit(Container):
    """
    A bit of a formula
    """
  def __init__(self):
    """
    The formula bit type can be 'alpha', 'number', 'font'.
    """
  def setfactory(self, factory):
    """
    Set the internal formula factory.
    """
  def add(self, bit):
    """
    Add any kind of formula bit already processed
    """
  def skiporiginal(self, string, pos):
    """
    Skip a string and add it to the original formula
    """
  def computesize(self):
    """
    Compute the size of the bit as the max of the sizes of all contents.
    """
  def clone(self):
    """
    Return a copy of itself.
    """
  def __unicode__(self):
    """
    Get a string representation
    """
def TaggedBit(FormulaBit):
    """
    A tagged string in a formula
    """
  def constant(self, constant, tag):
    """
    Set the constant and the tag
    """
  def complete(self, contents, tag, breaklines = False):
    """
    Set the constant and the tag
    """
  def selfcomplete(self, tag):
    """
    Set the self-closing tag, no contents (as in <hr/>).
    """
def FormulaConstant(Constant):
    """
    A constant string in a formula
    """
  def __init__(self, string):
    """
    Set the constant string
    """
  def computesize(self):
    """
    Compute the size of the constant: always 1.
    """
  def clone(self):
    """
    Return a copy of itself.
    """
  def __unicode__(self):
    """
    Return a printable representation.
    """
def RawText(FormulaBit):
    """
    A bit of text inside a formula
    """
  def detect(self, pos):
    """
    Detect a bit of raw text
    """
  def parsebit(self, pos):
    """
    Parse alphabetic text
    """
def FormulaSymbol(FormulaBit):
    """
    A symbol inside a formula
    """
  def detect(self, pos):
    """
    Detect a symbol
    """
  def parsebit(self, pos):
    """
    Parse the symbol
    """
  def addsymbol(self, symbol, pos):
    """
    Add a symbol
    """
def FormulaNumber(FormulaBit):
    """
    A string of digits in a formula
    """
  def detect(self, pos):
    """
    Detect a digit
    """
  def parsebit(self, pos):
    """
    Parse a bunch of digits
    """
def Comment(FormulaBit):
    """
    A LaTeX comment: % to the end of the line.
    """
  def detect(self, pos):
    """
    Detect the %.
    """
  def parsebit(self, pos):
    """
    Parse to the end of the line.
    """
def WhiteSpace(FormulaBit):
    """
    Some white space inside a formula.
    """
  def detect(self, pos):
    """
    Detect the white space.
    """
  def parsebit(self, pos):
    """
    Parse all whitespace.
    """
  def __unicode__(self):
    """
    Return a printable representation.
    """
def Bracket(FormulaBit):
    """
    A {} bracket inside a formula
    """
  def __init__(self):
    """
    Create a (possibly literal) new bracket
    """
  def detect(self, pos):
    """
    Detect the start of a bracket
    """
  def parsebit(self, pos):
    """
    Parse the bracket
    """
  def parsetext(self, pos):
    """
    Parse a text bracket
    """
  def parseliteral(self, pos):
    """
    Parse a literal bracket
    """
  def parsecomplete(self, pos, innerparser):
    """
    Parse the start and end marks
    """
  def innerformula(self, pos):
    """
    Parse a whole formula inside the bracket
    """
  def innertext(self, pos):
    """
    Parse some text inside the bracket, following textual rules.
    """
  def innerliteral(self, pos):
    """
    Parse a literal inside the bracket, which does not generate HTML.
    """
def SquareBracket(Bracket):
    """
    A [] bracket inside a formula
    """
  def clone(self):
    """
    Return a new square bracket with the same contents.
    """
def MathsProcessor(object):
    """
    A processor for a maths construction inside the FormulaProcessor.
    """
  def process(self, contents, index):
    """
    Process an element inside a formula.
    """
  def __unicode__(self):
    """
    Return a printable description.
    """
def FormulaProcessor(object):
    """
    A processor specifically for formulas.
    """
  def process(self, bit):
    """
    Process the contents of every formula bit, recursively.
    """
  def processcontents(self, bit):
    """
    Process the contents of a formula bit.
    """
  def processinsides(self, bit):
    """
    Process the insides (limits, brackets) in a formula bit.
    """
  def traversewhole(self, formula):
    """
    Traverse over the contents to alter variables and space units.
    """
  def traverse(self, bit):
    """
    Traverse a formula and yield a flattened structure of (bit, list) pairs.
    """
  def italicize(self, bit, contents):
    """
    Italicize the given bit of text.
    """
def Formula(Container):
    """
    A LaTeX formula
    """
  def __init__(self):
    """
    'span class="formula"'
    """
  def process(self):
    """
    Convert the formula to tags
    """
  def jsmath(self):
    """
    Make the contents for jsMath.
    """
  def mathjax(self):
    """
    Make the contents for MathJax.
    """
  def googlecharts(self):
    """
    Make the contents using Google Charts http://code.google.com/apis/chart/.
    """
  def classic(self):
    """
    Make the contents using classic output generation with XHTML and CSS.
    """
  def parse(self, pos):
    """
    Parse using a parse position instead of self.parser.
    """
  def parsedollarinline(self, pos):
    """
    Parse a $...$ formula.
    """
  def parsedollarblock(self, pos):
    """
    Parse a $$...$$ formula.
    """
  def parsedollar(self, pos):
    """
    Parse to the next $.
    """
  def parseinlineto(self, pos, limit):
    """
    Parse a \\(...\\) formula.
    """
  def parseblockto(self, pos, limit):
    """
    Parse a \\[...\\] formula.
    """
  def parseupto(self, pos, limit):
    """
    Parse a formula that ends with the given command.
    """
  def __unicode__(self):
    """
    Return a printable representation.
    """
def WholeFormula(FormulaBit):
    """
    Parse a whole formula
    """
  def detect(self, pos):
    """
    Not outside the formula is enough.
    """
  def parsebit(self, pos):
    """
    Parse with any formula bit
    """
def FormulaFactory(object):
    """
    Construct bits of formula
    """
  def __init__(self):
    """
    Initialize the map of instances.
    """
  def detecttype(self, type, pos):
    """
    Detect a bit of a given type.
    """
  def instance(self, type):
    """
    Get an instance of the given type.
    """
  def create(self, type):
    """
    Create a new formula bit of the given type.
    """
  def clearskipped(self, pos):
    """
    Clear any skipped types.
    """
  def skipany(self, pos):
    """
    Skip any skipped types.
    """
  def parseany(self, pos):
    """
    Parse any formula bit at the current location.
    """
  def parsetype(self, type, pos):
    """
    Parse the given type and return it.
    """
  def parseformula(self, formula):
    """
    Parse a string of text that contains a whole formula.
    """
def Translator(object):
    """
    Reads the configuration file and tries to find a translation.
    """
  def translate(cls, key):
    """
    Get the translated message for a key.
    """
  def __init__(self):
    """
    Find the translation for the document language.
    """
  def getmessage(self, key):
    """
    Get the translated message for the given key.
    """
  def getuntranslated(self, key):
    """
    Get the untranslated message.
    """
def NumberCounter(object):
    """
    A counter for numbers (by default).
    """
  def __init__(self, name):
    """
    Give a name to the counter.
    """
  def setmode(self, mode):
    """
    Set the counter mode. Can be changed at runtime.
    """
  def init(self, value):
    """
    Set an initial value.
    """
  def gettext(self):
    """
    Get the next value as a text string.
    """
  def getletter(self):
    """
    Get the next value as a letter.
    """
  def getsymbol(self):
    """
    Get the next value as a symbol.
    """
  def getsequence(self, sequence):
    """
    Get the next value from elyxer.a sequence.
    """
  def getroman(self):
    """
    Get the next value as a roman number.
    """
  def getvalue(self):
    """
    Get the current value as configured in the current mode.
    """
  def getnext(self):
    """
    Increase the current value and get the next value as configured.
    """
  def reset(self):
    """
    Reset the counter.
    """
  def __unicode__(self):
    """
    Return a printable representation.
    """
def DependentCounter(NumberCounter):
    """
    A counter which depends on another one (the master).
    """
  def setmaster(self, master):
    """
    Set the master counter.
    """
  def getnext(self):
    """
    Increase or, if the master counter has changed, restart.
    """
  def getvalue(self):
    """
    Get the value of the combined counter: master.dependent.
    """
def NumberGenerator(object):
    """
    A number generator for unique sequences and hierarchical structures. Used in:
    """
  def deasterisk(self, type):
    """
    Remove the possible asterisk in a layout type.
    """
  def isunique(self, type):
    """
    Find out if the layout type corresponds to a unique part.
    """
  def isroman(self, type):
    """
    Find out if the layout type should have roman numeration.
    """
  def isinordered(self, type):
    """
    Find out if the layout type corresponds to an (un)ordered part.
    """
  def isnumbered(self, type):
    """
    Find out if the type for a layout corresponds to a numbered layout.
    """
  def isunordered(self, type):
    """
    Find out if the type contains an asterisk, basically.
    """
  def getlevel(self, type):
    """
    Get the level that corresponds to a layout type.
    """
  def getparttype(self, type):
    """
    Obtain the type for the part: without the asterisk, 
    """
  def generate(self, type):
    """
    Generate a number for a layout type.
    """
  def getcounter(self, type):
    """
    Get the counter for the given type.
    """
  def create(self, type):
    """
    Create a counter for the given type.
    """
  def getdependentcounter(self, type, master):
    """
    Get (or create) a counter of the given type that depends on another.
    """
  def createdependent(self, type, master):
    """
    Create a dependent counter given the master.
    """
  def startappendix(self):
    """
    Start appendices here.
    """
def ChapteredGenerator(NumberGenerator):
    """
    Generate chaptered numbers, as in Chapter.Number.
    """
  def generate(self, type):
    """
    Generate a number which goes with first-level numbers (chapters). 
    """
def ContainerSize(object):
    """
    The size of a container.
    """
  def set(self, width = None, height = None):
    """
    Set the proper size with width and height.
    """
  def setmax(self, maxwidth = None, maxheight = None):
    """
    Set max width and/or height.
    """
  def readparameters(self, container):
    """
    Read some size parameters off a container.
    """
  def setparameter(self, container, name):
    """
    Read a size parameter off a container, and set it if present.
    """
  def setvalue(self, name, value):
    """
    Set the value of a parameter name, only if it's valid.
    """
  def checkvalidheight(self, container):
    """
    Check if the height parameter is valid; otherwise erase it.
    """
  def processparameter(self, value):
    """
    Do the full processing on a parameter.
    """
  def extractnumber(self, text):
    """
    Extract the first number in the given text.
    """
  def checkimage(self, width, height):
    """
    Check image dimensions, set them if possible.
    """
  def scalevalue(self, value):
    """
    Scale the value according to the image scale and return it as unicode.
    """
  def removepercentwidth(self):
    """
    Remove percent width if present, to set it at the figure level.
    """
  def addstyle(self, container):
    """
    Add the proper style attribute to the output tag.
    """
  def styleparameter(self, name):
    """
    Get the style for a single parameter.
    """
def QuoteContainer(Container):
    """
    A container for a pretty quote
    """
  def __init__(self):
    """
    Process contents
    """
def LyXLine(Container):
    """
    A Lyx line
    """
  def __init__(self):
    """
    '<hr class="line" />'
    """
def EmphaticText(TaggedText):
    """
    Text with emphatic mode
    """
  def process(self):
    """
    'i'
    """
def ShapedText(TaggedText):
    """
    Text shaped (italic, slanted)
    """
  def process(self):
    """
    'Unrecognized shape '
    """
def VersalitasText(TaggedText):
    """
    Text in versalitas
    """
  def process(self):
    """
    'span class="versalitas"'
    """
def ColorText(TaggedText):
    """
    Colored text
    """
  def process(self):
    """
    'span class="'
    """
def SizeText(TaggedText):
    """
    Sized text
    """
  def process(self):
    """
    'span class="'
    """
def BoldText(TaggedText):
    """
    Bold text
    """
  def process(self):
    """
    'b'
    """
def TextFamily(TaggedText):
    """
    A bit of text from elyxer.a different family
    """
  def process(self):
    """
    Parse the type of family
    """
def Hfill(TaggedText):
    """
    Horizontall fill
    """
  def process(self):
    """
    'span class="hfill"'
    """
def BarredText(TaggedText):
    """
    Text with a bar somewhere
    """
  def process(self):
    """
    Parse the type of bar
    """
def LangLine(TaggedText):
    """
    A line with language information
    """
  def process(self):
    """
    Only generate a span with lang info when the language is recognized.
    """
def InsetLength(BlackBox):
    """
    A length measure inside an inset.
    """
  def process(self):
    """
    A space of several types
    """
  def __init__(self):
    """
    'Unknown space type '
    """
  def getlength(self):
    """
    Get the space length from elyxer.the contents or parameters.
    """
def VerticalSpace(Container):
    """
    An inset that contains a vertical space.
    """
  def __init__(self):
    """
    Set the correct tag
    """
def Align(Container):
    """
    Bit of aligned text
    """
  def __init__(self):
    """
    'div class="'
    """
def Newline(Container):
    """
    A newline
    """
  def __init__(self):
    """
    Process contents
    """
def NewPage(Newline):
    """
    A new page
    """
  def process(self):
    """
    Process contents
    """
def Separator(Container):
    """
    A separator string which is not extracted by extracttext().
    """
  def __init__(self, constant):
    """
    Striken out text.
    """
  def process(self):
    """
    Set the output tag to strike.
    """
def StartAppendix(BlackBox):
    """
    Mark to start an appendix here.
    """
  def process(self):
    """
    Activate the special numbering scheme for appendices, using letters.
    """
def Link(Container):
    """
    A link to another part of the document
    """
  def __init__(self):
    """
    Initialize the link, add target if configured.
    """
  def complete(self, text, anchor = None, url = None, type = None, title = None):
    """
    Complete the link.
    """
  def computedestination(self):
    """
    Use the destination link to fill in the destination URL.
    """
  def setmutualdestination(self, destination):
    """
    Set another link as destination, and set its destination to this one.
    """
  def __unicode__(self):
    """
    Return a printable representation.
    """
def URL(Link):
    """
    A clickable URL
    """
  def process(self):
    """
    Read URL from elyxer.parameters
    """
def FlexURL(URL):
    """
    A flexible URL
    """
  def process(self):
    """
    Read URL from elyxer.contents
    """
def LinkOutput(ContainerOutput):
    """
    A link pointing to some destination
    """
  def gethtml(self, link):
    """
    Get the HTML code for the link
    """
def Postprocessor(object):
    """
    Postprocess a container keeping some context
    """
  def __init__(self):
    """
    Postprocess a container and its contents.
    """
  def postrecursive(self, container):
    """
    Postprocess the container contents recursively
    """
  def postcurrent(self, next):
    """
    Postprocess the current element taking into account next and last.
    """
def StageDict(object):
    """
    A dictionary of stages corresponding to classes
    """
  def __init__(self, classes, postprocessor):
    """
    Instantiate an element from elyxer.each class and store as a dictionary
    """
  def instantiate(self, classes, postprocessor):
    """
    Instantiate an element from elyxer.each class
    """
  def getstage(self, element):
    """
    Get the stage for a given element, if the type is in the dict
    """
def Label(Link):
    """
    A label to be referenced
    """
  def __init__(self):
    """
    Process a label container.
    """
  def create(self, text, key, type = 'Label'):
    """
    Create the label for a given key.
    """
  def findpartkey(self):
    """
    Get the part key for the latest numbered container seen.
    """
  def numbered(self, container):
    """
    Get the numbered container for the label.
    """
  def __unicode__(self):
    """
    Return a printable representation.
    """
def Reference(Link):
    """
    A reference to a label.
    """
  def process(self):
    """
    Read the reference and set the arrow.
    """
  def formatcontents(self):
    """
    Format the reference contents.
    """
  def replace(self, key, value):
    """
    Replace a key in the format template with a value.
    """
  def __unicode__(self):
    """
    Return a printable representation.
    """
def FormulaCommand(FormulaBit):
    """
    A LaTeX command inside a formula
    """
  def detect(self, pos):
    """
    Find the current command.
    """
  def parsebit(self, pos):
    """
    Parse the command.
    """
  def parsewithcommand(self, command, pos):
    """
    Parse the command type once we have the command.
    """
  def parsecommandtype(self, command, type, pos):
    """
    Parse a given command type.
    """
  def extractcommand(self, pos):
    """
    Extract the command from elyxer.the current position.
    """
  def emptycommand(self, pos):
    """
    Check for an empty command: look for command disguised as ending.
        Special case against '{ \\{ \\} }' situation.
    """
  def parseupgreek(self, command, pos):
    """
    Parse the Greek \\up command..
    """
def CommandBit(FormulaCommand):
    """
    A formula bit that includes a command
    """
  def setcommand(self, command):
    """
    Set the command in the bit
    """
  def parseparameter(self, pos):
    """
    Parse a parameter at the current position
    """
  def parsesquare(self, pos):
    """
    Parse a square bracket
    """
  def parseliteral(self, pos):
    """
    Parse a literal bracket.
    """
  def parsesquareliteral(self, pos):
    """
    Parse a square bracket literally.
    """
  def parsetext(self, pos):
    """
    Parse a text parameter.
    """
def EmptyCommand(CommandBit):
    """
    An empty command (without parameters)
    """
  def parsebit(self, pos):
    """
    Parse a command without parameters
    """
def SpacedCommand(CommandBit):
    """
    An empty command which should have math spacing in formulas.
    """
  def parsebit(self, pos):
    """
    Place as contents the command translated and spaced.
    """
def AlphaCommand(EmptyCommand):
    """
    A command without paramters whose result is alphabetical
    """
  def parsebit(self, pos):
    """
    Parse the command and set type to alpha
    """
def OneParamFunction(CommandBit):
    """
    A function of one parameter
    """
  def parsebit(self, pos):
    """
    Parse a function with one parameter
    """
  def simplifyifpossible(self):
    """
    Try to simplify to a single character.
    """
def SymbolFunction(CommandBit):
    """
    Find a function which is represented by a symbol (like _ or ^)
    """
  def detect(self, pos):
    """
    Find the symbol
    """
  def parsebit(self, pos):
    """
    Parse the symbol
    """
def TextFunction(CommandBit):
    """
    A function where parameters are read as text.
    """
  def parsebit(self, pos):
    """
    Parse a text parameter
    """
  def process(self):
    """
    Set the type to font
    """
def LabelFunction(CommandBit):
    """
    A function that acts as a label
    """
  def parsebit(self, pos):
    """
    Parse a literal parameter
    """
  def process(self):
    """
    Add an anchor with the label contents.
    """
def FontFunction(OneParamFunction):
    """
    A function of one parameter that changes the font
    """
  def process(self):
    """
    Simplify if possible using a single character.
    """
def BigSymbol(object):
    """
    A big symbol generator.
    """
  def __init__(self, symbol):
    """
    Create the big symbol.
    """
  def getpieces(self):
    """
    Get an array with all pieces.
    """
  def smalllimit(self):
    """
    Decide if the limit should be a small, one-line symbol.
    """
def BigBracket(BigSymbol):
    """
    A big bracket generator.
    """
  def __init__(self, size, bracket, alignment='l'):
    """
    Set the size and symbol for the bracket.
    """
  def getpiece(self, index):
    """
    Return the nth piece for the bracket.
    """
  def getpiece1(self, index):
    """
    Return the only piece for a single-piece bracket.
    """
  def getpiece3(self, index):
    """
    Get the nth piece for a 3-piece bracket: parenthesis or square bracket.
    """
  def getpiece4(self, index):
    """
    Get the nth piece for a 4-piece bracket: curly bracket.
    """
  def getcell(self, index):
    """
    Get the bracket piece as an array cell.
    """
  def getcontents(self):
    """
    Get the bracket as an array or as a single bracket.
    """
  def getsinglebracket(self):
    """
    Return the bracket as a single sign.
    """
def FormulaEquation(CommandBit):
    """
    A simple numbered equation.
    """
  def parsebit(self, pos):
    """
    Parse the array
    """
def FormulaCell(FormulaCommand):
    """
    An array cell inside a row
    """
  def setalignment(self, alignment):
    """
    'span class="arraycell align-'
    """
  def parsebit(self, pos):
    """
    An array row inside an array
    """
  def setalignments(self, alignments):
    """
    'span class="arrayrow"'
    """
  def parsebit(self, pos):
    """
    Parse a whole row
    """
  def createcell(self, index):
    """
    Create the cell that corresponds to the given index.
    """
def MultiRowFormula(CommandBit):
    """
    A formula with multiple rows.
    """
  def parserows(self, pos):
    """
    Parse all rows, finish when no more row ends
    """
  def iteraterows(self, pos):
    """
    Iterate over all rows, end when no more row ends
    """
  def addempty(self):
    """
    Add an empty row.
    """
  def addrow(self, row):
    """
    Add a row to the contents and to the list of rows.
    """
def FormulaArray(MultiRowFormula):
    """
    An array within a formula
    """
  def parsebit(self, pos):
    """
    Parse the array
    """
  def parsealignments(self, pos):
    """
    Parse the different alignments
    """
def FormulaMatrix(MultiRowFormula):
    """
    A matrix (array with center alignment).
    """
  def parsebit(self, pos):
    """
    Parse the matrix, set alignments to 'c'.
    """
def FormulaCases(MultiRowFormula):
    """
    A cases statement
    """
  def parsebit(self, pos):
    """
    Parse the cases
    """
def EquationEnvironment(MultiRowFormula):
    """
    A \\begin{}...\\end equation environment with rows and cells.
    """
  def parsebit(self, pos):
    """
    Parse the whole environment.
    """
def BeginCommand(CommandBit):
    """
    A \\begin{}...\\end command and what it entails (array, cases, aligned)
    """
  def parsebit(self, pos):
    """
    Parse the begin command
    """
  def findbit(self, piece):
    """
    Find the command bit corresponding to the \\begin{piece}
    """
def CombiningFunction(OneParamFunction):
    """
    Parse a combining function.
    """
  def parsesingleparameter(self, pos):
    """
    Parse a parameter, or a single letter.
    """
def DecoratingFunction(OneParamFunction):
    """
    A function that decorates some bit of text
    """
  def parsebit(self, pos):
    """
    Parse a decorating function
    """
def LimitCommand(EmptyCommand):
    """
    A command which accepts limits above and below, in display mode.
    """
  def parsebit(self, pos):
    """
    Parse a limit command.
    """
def LimitPreviousCommand(LimitCommand):
    """
    A command to limit the previous command.
    """
  def parsebit(self, pos):
    """
    Do nothing.
    """
  def __unicode__(self):
    """
    Return a printable representation.
    """
def LimitsProcessor(MathsProcessor):
    """
    A processor for limits inside an element.
    """
  def process(self, contents, index):
    """
    Process the limits for an element.
    """
  def checklimits(self, contents, index):
    """
    Check if the current position has a limits command.
    """
  def limitsahead(self, contents, index):
    """
    Limit the current element based on the next.
    """
  def modifylimits(self, contents, index):
    """
    Modify a limits commands so that the limits appear above and below.
    """
  def getlimit(self, contents, index):
    """
    Get the limit for a limits command.
    """
  def modifyscripts(self, contents, index):
    """
    Modify the super- and subscript to appear vertically aligned.
    """
  def checkscript(self, contents, index):
    """
    Check if the current element is a sub- or superscript.
    """
  def checkcommand(self, contents, index, type):
    """
    Check for the given type as the current element.
    """
  def getscript(self, contents, index):
    """
    Get the sub- or superscript.
    """
def BracketCommand(OneParamFunction):
    """
    A command which defines a bracket.
    """
  def parsebit(self, pos):
    """
    Parse the bracket.
    """
  def create(self, direction, character):
    """
    Create the bracket for the given character.
    """
def BracketProcessor(MathsProcessor):
    """
    A processor for bracket commands.
    """
  def process(self, contents, index):
    """
    Convert the bracket using Unicode pieces, if possible.
    """
  def processleft(self, contents, index):
    """
    Process a left bracket.
    """
  def checkleft(self, contents, index):
    """
    Check if the command at the given index is left.
    """
  def checkright(self, contents, index):
    """
    Check if the command at the given index is right.
    """
  def checkdirection(self, bit, command):
    """
    Check if the given bit is the desired bracket command.
    """
  def findright(self, contents, index):
    """
    Find the right bracket starting at the given index, or 0.
    """
  def findmax(self, contents, leftindex, rightindex):
    """
    Find the max size of the contents between the two given indices.
    """
  def resize(self, command, size):
    """
    Resize a bracket command to the given size.
    """
def TodayCommand(EmptyCommand):
    """
    Shows today's date.
    """
  def parsebit(self, pos):
    """
    Parse a command without parameters
    """
def ParameterDefinition(object):
    """
    The definition of a parameter in a hybrid function.
    """
  def __init__(self):
    """
    Parse a parameter definition: [$0], {$x}, {$1!}...
    """
  def read(self, pos, function):
    """
    Read the parameter itself using the definition.
    """
  def __unicode__(self):
    """
    Return a printable representation.
    """
def ParameterFunction(CommandBit):
    """
    A function with a variable number of parameters defined in a template.
    """
  def readparams(self, readtemplate, pos):
    """
    Read the params according to the template.
    """
  def paramdefs(self, readtemplate):
    """
    Read each param definition in the template
    """
  def getparam(self, name):
    """
    Get a parameter as parsed.
    """
  def getvalue(self, name):
    """
    Get the value of a parameter.
    """
  def getliteralvalue(self, name):
    """
    Get the literal value of a parameter.
    """
def HybridFunction(ParameterFunction):
    """

      A parameter function where the output is also defined using a template.
      The template can use a number of functions; each function has an associated
      tag.
      Example: [f0{$1},span class="fbox"] defines a function f0 which corresponds
      to a span of class fbox, yielding <span class="fbox">$1</span>.
      Literal parameters can be used in tags definitions:
        [f0{$1},span style="color: $p;"]
      yields <span style="color: $p;">$1</span>, where $p is a literal parameter.
      Sizes can be specified in hybridsizes, e.g. adding parameter sizes. By
      default the resulting size is the max of all arguments. Sizes are used
      to generate the right parameters.
      A function followed by a single / is output as a self-closing XHTML tag:
        [f0/,hr]
      will generate <hr/>.
  
    """
  def parsebit(self, pos):
    """
    Parse a function with [] and {} parameters
    """
  def writeparams(self, writetemplate):
    """
    Write all params according to the template
    """
  def writepos(self, pos):
    """
    Write all params as read in the parse position.
    """
  def writeparam(self, pos):
    """
    Write a single param of the form $0, $x...
    """
  def writefunction(self, pos):
    """
    Write a single function f0,...,fn.
    """
  def readtag(self, pos):
    """
    Get the tag corresponding to the given index. Does parameter substitution.
    """
  def writebracket(self, direction, character):
    """
    Return a new bracket looking at the given direction.
    """
  def computehybridsize(self):
    """
    Compute the size of the hybrid function.
    """
def HybridSize(object):
    """
    The size associated with a hybrid function.
    """
  def getsize(self, function):
    """
    Read the size for a function and parse it.
    """
def HeaderParser(Parser):
    """
    Parses the LyX header
    """
  def parse(self, reader):
    """
    Parse header parameters into a dictionary, return the preamble.
    """
  def parseline(self, reader, contents):
    """
    Parse a single line as a parameter or as a start
    """
  def parsebranch(self, reader):
    """
    Parse all branch definitions.
    """
  def complete(self, ending):
    """
    Complete the parser with the given ending.
    """
def PreambleParser(Parser):
    """
    A parser for the LyX preamble.
    """
  def parse(self, reader):
    """
    Parse the full preamble with all statements.
    """
  def parsepreambleline(self, reader):
    """
    Parse a single preamble line.
    """
def LstParser(object):
    """
    Parse global and local lstparams.
    """
  def parselstset(self, reader):
    """
    Parse a declaration of lstparams in lstset.
    """
  def extractlstset(self, reader):
    """
    Extract the global lstset parameters.
    """
  def parsecontainer(self, container):
    """
    Parse some lstparams from elyxer.a container.
    """
  def parselstparams(self, paramlist):
    """
    Process a number of lstparams from elyxer.a list.
    """
def MacroDefinition(CommandBit):
    """
    A function that defines a new command (a macro).
    """
  def parsebit(self, pos):
    """
    Parse the function that defines the macro.
    """
  def parseparameters(self, pos):
    """
    Parse all optional parameters (number of parameters, default values)
    """
  def parsenewcommand(self, pos):
    """
    Parse the name of the new command.
    """
  def instantiate(self):
    """
    Return an instance of the macro.
    """
def MacroParameter(FormulaBit):
    """
    A parameter from elyxer.a macro.
    """
  def detect(self, pos):
    """
    Find a macro parameter: #n.
    """
  def parsebit(self, pos):
    """
    Parse the parameter: #n.
    """
def MacroFunction(CommandBit):
    """
    A function that was defined using a macro.
    """
  def parsebit(self, pos):
    """
    Parse a number of input parameters.
    """
  def parseparameters(self, pos, macro):
    """
    Parse as many parameters as are needed.
    """
  def parseoptional(self, pos, defaults):
    """
    Parse optional parameters.
    """
  def parsemandatory(self, pos, number):
    """
    Parse a number of mandatory parameters.
    """
  def parsemacroparameter(self, pos, remaining):
    """
    Parse a macro parameter. Could be a bracket or a single letter.
    """
  def parsenumbers(self, pos, remaining):
    """
    Parse the remaining parameters as a running number.
    """
  def completemacro(self, macro):
    """
    Complete the macro with the parameters read.
    """
  def addfilter(self, index, value):
    """
    Add a filter for the given parameter number and parameter value.
    """
def FormulaMacro(Formula):
    """
    A math macro defined in an inset.
    """
  def __init__(self):
    """
    Return a printable representation.
    """
def math2html(formula):
    """
    Convert some TeX math to HTML.
    """
def main():
    """
    Main function, called if invoked from elyxer.the command line
    """
