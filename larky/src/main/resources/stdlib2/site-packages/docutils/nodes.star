def _traversal_list(list):
    """
     auxiliary class to report a FutureWarning

    """
    def _warning_decorator(fun):
        """
        \n   The iterable returned by Node.traverse()
        \n   will become an iterator instead of a list in 
        Docutils > 0.16.
        """
        def wrapper(self, *args, **kwargs):
            """
             ==============================
              Functional Node Base Classes
             ==============================


            """
def Node(object):
    """
    Abstract base class of nodes in a document tree.
    """
    def __bool__(self):
        """

                Node instances are always true, even if they're empty.  A node is more
                than a simple container.  Its boolean "truth" does not depend on
                having one or more subnodes in the doctree.

                Use `len()` to check node length.  Use `None` to represent a boolean
                false value.
        
        """
        def __str__(self):
            """
            'raw_unicode_escape'
            """
    def asdom(self, dom=None):
        """
        Return a DOM **fragment** representation of this Node.
        """
    def pformat(self, indent='    ', level=0):
        """

                Return an indented pseudo-XML representation, for test purposes.

                Override in subclasses.
        
        """
    def copy(self):
        """
        Return a copy of self.
        """
    def deepcopy(self):
        """
        Return a deep copy of self (also copying children).
        """
    def astext(self):
        """
        Return a string representation of this Node.
        """
    def setup_child(self, child):
        """

                Traverse a tree of `Node` objects, calling the
                `dispatch_visit()` method of `visitor` when entering each
                node.  (The `walkabout()` method is similar, except it also
                calls the `dispatch_departure()` method before exiting each
                node.)

                This tree traversal supports limited in-place tree
                modifications.  Replacing one node with one or more nodes is
                OK, as is removing an element.  However, if the node removed
                or replaced occurs after the current node, the old node will
                still be traversed, and any new nodes will not.

                Within ``visit`` methods (and ``depart`` methods for
                `walkabout()`), `TreePruningException` subclasses may be raised
                (`SkipChildren`, `SkipSiblings`, `SkipNode`, `SkipDeparture`).

                Parameter `visitor`: A `NodeVisitor` object, containing a
                ``visit`` implementation for each `Node` subclass encountered.

                Return true if we should stop the traversal.
        
        """
    def walkabout(self, visitor):
        """

                Perform a tree traversal similarly to `Node.walk()` (which
                see), except also call the `dispatch_departure()` method
                before exiting each node.

                Parameter `visitor`: A `NodeVisitor` object, containing a
                ``visit`` and ``depart`` implementation for each `Node`
                subclass encountered.

                Return true if we should stop the traversal.
        
        """
    def _fast_traverse(self, cls):
        """
        Return iterator that only supports instance checks.
        """
    def _all_traverse(self):
        """
        Return iterator that doesn't check for a condition.
        """
2021-03-02 20:49:09,464 : INFO : tokenize_signature : --> do i ever get here?
    def traverse(self, condition=None, include_self=True, descend=True,
                 siblings=False, ascend=False):
        """

                Return an iterable containing

                * self (if include_self is true)
                * all descendants in tree traversal order (if descend is true)
                * all siblings (if siblings is true) and their descendants (if
                  also descend is true)
                * the siblings of the parent (if ascend is true) and their
                  descendants (if also descend is true), and so on

                If `condition` is not None, the iterable contains only nodes
                for which ``condition(node)`` is true.  If `condition` is a
                node class ``cls``, it is equivalent to a function consisting
                of ``return isinstance(node, cls)``.

                If ascend is true, assume siblings to be true as well.

                For example, given the following tree::

                    <paragraph>
                        <emphasis>      <--- emphasis.traverse() and
                            <strong>    <--- strong.traverse() are called.
                                Foo
                            Bar
                        <reference name="Baz" refid="baz">
                            Baz

                Then list(emphasis.traverse()) equals ::

                    [<emphasis>, <strong>, <#text: Foo>, <#text: Bar>]

                and list(strong.traverse(ascend=True)) equals ::

                    [<strong>, <#text: Foo>, <#text: Bar>, <reference>, <#text: Baz>]
        
        """
2021-03-02 20:49:09,465 : INFO : tokenize_signature : --> do i ever get here?
    def _traverse(self, condition=None, include_self=True, descend=True,
                  siblings=False, ascend=False):
        """
        Return iterator over nodes following `self`. See `traverse()`.
        """
            def condition(node, node_class=node_class):
                """

                        Return the first node in the iterable returned by traverse(),
                        or None if the iterable is empty.

                        Parameter list is the same as of traverse.  Note that
                        include_self defaults to False, though.
        
                """
    def reprunicode(unicode):
    """

            A unicode sub-class that removes the initial u from unicode's repr.
        
    """
        def __repr__(self):
            """

                Failsave conversion of `unicode` to `str`.
    
            """
def unescape(text, restore_backslashes=False, respect_whitespace=False):
    """

        Return a string with nulls removed or restored to backslashes.
        Backslash-escaped spaces are also removed.
    
    """
def Text(Node, reprunicode):
    """

        Instances are terminal nodes (leaves) containing text only; no child
        nodes or attributes.  Initialize by passing a string to the constructor.
        Access the text itself with the `astext` method.
    
    """
        def __new__(cls, data, rawsource=None):
            """
            Prevent the rawsource argument from propagating to str.
            """
        def __new__(cls, data, rawsource=None):
            """
            Prevent the rawsource argument from propagating to str.
            """
    def __init__(self, data, rawsource=''):
        """
        The raw text from which this element was constructed.
        """
    def shortrepr(self, maxlen=18):
        """
        ' ...'
        """
    def __repr__(self):
        """
         Note about __unicode__: The implementation of __unicode__ here,
         and the one raising NotImplemented in the superclass Node had
         to be removed when changing Text to a subclass of unicode instead
         of UserString, since there is no way to delegate the __unicode__
         call to the superclass unicode:
         unicode itself does not have __unicode__ method to delegate to
         and calling unicode(self) or unicode.__new__ directly creates
         an infinite loop


        """
    def copy(self):
        """
        '    '
        """
    def rstrip(self, chars=None):
        """

            `Element` is the superclass to all specific elements.

            Elements contain attributes and child nodes.  Elements emulate
            dictionaries for attributes, indexing by attribute name (a string).  To
            set the attribute 'att' to 'value', do::

                element['att'] = 'value'

            There are two special attributes: 'ids' and 'names'.  Both are
            lists of unique identifiers, and names serve as human interfaces
            to IDs.  Names are case- and whitespace-normalized (see the
            fully_normalize_name() function), and IDs conform to the regular
            expression ``[a-z](-?[a-z0-9]+)*`` (see the make_id() function).

            Elements also emulate lists for child nodes (element nodes and/or text
            nodes), indexing by integer.  To get the first child node, use::

                element[0]

            Elements may be constructed using the ``+=`` operator.  To add one new
            child node to element, do::

                element += node

            This is equivalent to ``element.append(node)``.

            To add a list of multiple child nodes at once, use the same ``+=``
            operator::

                element += [node1, node2]

            This is equivalent to ``element.extend([node1, node2])``.
    
        """
    def __init__(self, rawsource='', *children, **attributes):
        """
        The raw text from which this element was constructed.

                NOTE: some elements do not set this value (default '').
        
        """
    def _dom_node(self, domroot):
        """
        ' '
        """
    def __repr__(self):
        """
        ''
        """
    def shortrepr(self):
        """
        'names'
        """
    def __unicode__(self):
        """
        u'%s%s%s'
        """
    def starttag(self, quoteattr=None):
        """
         the optional arg is used by the docutils_xml writer

        """
    def endtag(self):
        """
        '</%s>'
        """
    def emptytag(self):
        """
        u'<%s/>'
        """
    def __len__(self):
        """
        'cannot handle slice with stride'
        """
    def __setitem__(self, key, item):
        """
        'cannot handle slice with stride'
        """
    def __delitem__(self, key):
        """
        'cannot handle slice with stride'
        """
    def __add__(self, other):
        """
        Append a node or a list of nodes to `self.children`.
        """
    def astext(self):
        """
         support operator ``in``

        """
    def get_language_code(self, fallback=''):
        """
        Return node's language tag.

                Look iteratively in self and parents for a class argument
                starting with ``language-`` and return the remainder of it
                (which should be a `BCP49` language tag) or the `fallback`.
        
        """
    def append(self, item):
        """

                Update basic attributes ('ids', 'names', 'classes',
                'dupnames', but not 'source') from node or dictionary `dict_`.
        
        """
    def append_attr_list(self, attr, values):
        """

                For each element in values, if it does not exist in self[attr], append
                it.

                NOTE: Requires self[attr] and values to be sequence type and the
                former should specifically be a list.
        
        """
    def coerce_append_attr_list(self, attr, value):
        """

                First, convert both self[attr] and value to a non-string sequence
                type; if either is not already a sequence, convert it to a list of one
                element.  Then call append_attr_list.

                NOTE: self[attr] and value both must not be None.
        
        """
    def replace_attr(self, attr, value, force = True):
        """

                If self[attr] does not exist or force is True or omitted, set
                self[attr] to value, otherwise do nothing.
        
        """
    def copy_attr_convert(self, attr, value, replace = True):
        """

                If attr is an attribute of self, set self[attr] to
                [self[attr], value], otherwise set self[attr] to value.

                NOTE: replace is not used by this function and is kept only for
                      compatibility with the other copy functions.
        
        """
    def copy_attr_coerce(self, attr, value, replace):
        """

                If attr is an attribute of self and either self[attr] or value is a
                list, convert all non-sequence values to a sequence of 1 element and
                then concatenate the two sequence, setting the result to self[attr].
                If both self[attr] and value are non-sequences and replace is True or
                self[attr] is None, replace self[attr] with value. Otherwise, do
                nothing.
        
        """
    def copy_attr_concatenate(self, attr, value, replace):
        """

                If attr is an attribute of self and both self[attr] and value are
                lists, concatenate the two sequences, setting the result to
                self[attr].  If either self[attr] or value are non-sequences and
                replace is True or self[attr] is None, replace self[attr] with value.
                Otherwise, do nothing.
        
        """
    def copy_attr_consistent(self, attr, value, replace):
        """

                If replace is True or self[attr] is None, replace self[attr] with
                value.  Otherwise, do nothing.
        
        """
2021-03-02 20:49:09,479 : INFO : tokenize_signature : --> do i ever get here?
    def update_all_atts(self, dict_, update_fun = copy_attr_consistent,
                        replace = True, and_source = False):
        """

                Updates all attributes from node or dictionary `dict_`.

                Appends the basic attributes ('ids', 'names', 'classes',
                'dupnames', but not 'source') and then, for all other attributes in
                dict_, updates the same attribute in self.  When attributes with the
                same identifier appear in both self and dict_, the two values are
                merged based on the value of update_fun.  Generally, when replace is
                True, the values in self are replaced or merged with the values in
                dict_; otherwise, the values in self may be preserved or merged.  When
                and_source is True, the 'source' attribute is included in the copy.

                NOTE: When replace is False, and self contains a 'source' attribute,
                      'source' is not replaced even when dict_ has a 'source'
                      attribute, though it may still be merged into a list depending
                      on the value of update_fun.
                NOTE: It is easier to call the update-specific methods then to pass
                      the update_fun method to this function.
        
        """
2021-03-02 20:49:09,480 : INFO : tokenize_signature : --> do i ever get here?
    def update_all_atts_consistantly(self, dict_, replace = True,
                                     and_source = False):
        """

                Updates all attributes from node or dictionary `dict_`.

                Appends the basic attributes ('ids', 'names', 'classes',
                'dupnames', but not 'source') and then, for all other attributes in
                dict_, updates the same attribute in self.  When attributes with the
                same identifier appear in both self and dict_ and replace is True, the
                values in self are replaced with the values in dict_; otherwise, the
                values in self are preserved.  When and_source is True, the 'source'
                attribute is included in the copy.

                NOTE: When replace is False, and self contains a 'source' attribute,
                      'source' is not replaced even when dict_ has a 'source'
                      attribute, though it may still be merged into a list depending
                      on the value of update_fun.
        
        """
2021-03-02 20:49:09,480 : INFO : tokenize_signature : --> do i ever get here?
    def update_all_atts_concatenating(self, dict_, replace = True,
                                      and_source = False):
        """

                Updates all attributes from node or dictionary `dict_`.

                Appends the basic attributes ('ids', 'names', 'classes',
                'dupnames', but not 'source') and then, for all other attributes in
                dict_, updates the same attribute in self.  When attributes with the
                same identifier appear in both self and dict_ whose values aren't each
                lists and replace is True, the values in self are replaced with the
                values in dict_; if the values from self and dict_ for the given
                identifier are both of list type, then the two lists are concatenated
                and the result stored in self; otherwise, the values in self are
                preserved.  When and_source is True, the 'source' attribute is
                included in the copy.

                NOTE: When replace is False, and self contains a 'source' attribute,
                      'source' is not replaced even when dict_ has a 'source'
                      attribute, though it may still be merged into a list depending
                      on the value of update_fun.
        
        """
2021-03-02 20:49:09,481 : INFO : tokenize_signature : --> do i ever get here?
    def update_all_atts_coercion(self, dict_, replace = True,
                                 and_source = False):
        """

                Updates all attributes from node or dictionary `dict_`.

                Appends the basic attributes ('ids', 'names', 'classes',
                'dupnames', but not 'source') and then, for all other attributes in
                dict_, updates the same attribute in self.  When attributes with the
                same identifier appear in both self and dict_ whose values are both
                not lists and replace is True, the values in self are replaced with
                the values in dict_; if either of the values from self and dict_ for
                the given identifier are of list type, then first any non-lists are
                converted to 1-element lists and then the two lists are concatenated
                and the result stored in self; otherwise, the values in self are
                preserved.  When and_source is True, the 'source' attribute is
                included in the copy.

                NOTE: When replace is False, and self contains a 'source' attribute,
                      'source' is not replaced even when dict_ has a 'source'
                      attribute, though it may still be merged into a list depending
                      on the value of update_fun.
        
        """
    def update_all_atts_convert(self, dict_, and_source = False):
        """

                Updates all attributes from node or dictionary `dict_`.

                Appends the basic attributes ('ids', 'names', 'classes',
                'dupnames', but not 'source') and then, for all other attributes in
                dict_, updates the same attribute in self.  When attributes with the
                same identifier appear in both self and dict_ then first any non-lists
                are converted to 1-element lists and then the two lists are
                concatenated and the result stored in self; otherwise, the values in
                self are preserved.  When and_source is True, the 'source' attribute
                is included in the copy.

                NOTE: When replace is False, and self contains a 'source' attribute,
                      'source' is not replaced even when dict_ has a 'source'
                      attribute, though it may still be merged into a list depending
                      on the value of update_fun.
        
        """
    def clear(self):
        """
        Replace one child `Node` with another child or children.
        """
    def replace_self(self, new):
        """

                Replace `self` node with `new`, where `new` is a node or a
                list of nodes.
        
        """
    def first_child_matching_class(self, childclass, start=0, end=sys.maxsize):
        """

                Return the index of the first child whose class exactly matches.

                Parameters:

                - `childclass`: A `Node` subclass to search for, or a tuple of `Node`
                  classes. If a tuple, any of the classes may match.
                - `start`: Initial index to check.
                - `end`: Initial index to *not* check.
        
        """
2021-03-02 20:49:09,482 : INFO : tokenize_signature : --> do i ever get here?
    def first_child_not_matching_class(self, childclass, start=0,
                                       end=sys.maxsize):
        """

                Return the index of the first child whose class does *not* match.

                Parameters:

                - `childclass`: A `Node` subclass to skip, or a tuple of `Node`
                  classes. If a tuple, none of the classes may match.
                - `start`: Initial index to check.
                - `end`: Initial index to *not* check.
        
        """
    def pformat(self, indent='    ', level=0):
        """
        ''
        """
    def copy(self):
        """
        Add a new class to the "classes" attribute.
        """
    def note_referenced_by(self, name=None, id=None):
        """
        Note that this Element has been referenced by its name
                `name` or id `id`.
        """
    def is_not_list_attribute(cls, attr):
        """

                Returns True if and only if the given attribute is NOT one of the
                basic list attributes defined for all Elements.
        
        """
    def is_not_known_attribute(cls, attr):
        """

                Returns True if and only if the given attribute is NOT recognized by
                this class.
        
        """
def TextElement(Element):
    """

        An element which directly contains text.

        Its children are all `Text` or `Inline` subclass nodes.  You can
        check whether an element's context is inline simply by checking whether
        its immediate parent is a `TextElement` instance (including subclasses).
        This is handy for nodes like `image` that can appear both inline and as
        standalone body elements.

        If passing children to `__init__()`, make sure to set `text` to
        ``''`` or some other suitable value.
    
    """
    def __init__(self, rawsource='', text='', *children, **attributes):
        """
        ''
        """
def FixedTextElement(TextElement):
    """
    An element which directly contains preformatted text.
    """
    def __init__(self, rawsource='', text='', *children, **attributes):
        """
        'xml:space'
        """
def Resolvable(object):
    """
    'backrefs'
    """
def Root(object):
    """
    Category of Node which may occur before Bibliographic Nodes.
    """
def Bibliographic(object):
    """
    List-like elements.
    """
def Admonition(Body): pass
    """
    Special internal body elements.
    """
def Invisible(PreBibliographic):
    """
    Internal elements that don't appear in output.
    """
def Part(object):
    """
    Holds the whitespace_normalized_name (contains mixed case) of a target.
        Required for MoinMoin/reST compatibility.
    """
def Labeled(object):
    """
    Contains a `label` as its first element.
    """
def document(Root, Structural, Element):
    """

        The document root element.

        Do not instantiate this class directly; use
        `docutils.utils.new_document()` instead.
    
    """
    def __init__(self, settings, reporter, *args, **kwargs):
        """
        Path to or description of the input source being processed.
        """
    def __getstate__(self):
        """

                Return dict with unpicklable references removed.
        
        """
    def asdom(self, dom=None):
        """
        Return a DOM representation of this document.
        """
    def set_id(self, node, msgnode=None, suggested_prefix=''):
        """
        'ids'
        """
    def set_name_id_map(self, node, id, msgnode=None, explicit=None):
        """

                `self.nameids` maps names to IDs, while `self.nametypes` maps names to
                booleans representing hyperlink type (True==explicit,
                False==implicit).  This method updates the mappings.

                The following state transition table shows how `self.nameids` ("ids")
                and `self.nametypes` ("types") change with new input (a call to this
                method), and what actions are performed ("implicit"-type system
                messages are INFO/1, and "explicit"-type system messages are ERROR/3):

                ====  =====  ========  ========  =======  ====  =====  =====
                 Old State    Input          Action        New State   Notes
                -----------  --------  -----------------  -----------  -----
                ids   types  new type  sys.msg.  dupname  ids   types
                ====  =====  ========  ========  =======  ====  =====  =====
                -     -      explicit  -         -        new   True
                -     -      implicit  -         -        new   False
                None  False  explicit  -         -        new   True
                old   False  explicit  implicit  old      new   True
                None  True   explicit  explicit  new      None  True
                old   True   explicit  explicit  new,old  None  True   [#]_
                None  False  implicit  implicit  new      None  False
                old   False  implicit  implicit  new,old  None  False
                None  True   implicit  implicit  new      None  True
                old   True   implicit  implicit  new      old   True
                ====  =====  ========  ========  =======  ====  =====  =====

                .. [#] Do not clear the name-to-id map or invalidate the old target if
                   both old and new targets are external and refer to identical URIs.
                   The new target is invalidated regardless.
        
        """
    def set_duplicate_name_id(self, node, id, name, msgnode, explicit):
        """
        'refuri'
        """
    def has_name(self, name):
        """
         "note" here is an imperative verb: "take note of".

        """
    def note_implicit_target(self, target, msgnode=None):
        """
        'refname'
        """
    def note_refid(self, node):
        """
        'refid'
        """
    def note_indirect_target(self, target):
        """
        'names'
        """
    def note_anonymous_target(self, target):
        """
        'refname'
        """
    def note_citation(self, citation):
        """
        'refname'
        """
    def note_substitution_def(self, subdef, def_name, msgnode=None):
        """
        'Duplicate substitution definition name: "%s".'
        """
    def note_substitution_ref(self, subref, refname):
        """
        'refname'
        """
    def note_pending(self, pending, priority=None):
        """
         ================
          Title Elements
         ================


        """
def title(Titular, PreBibliographic, TextElement): pass
    """
     ========================
      Bibliographic Elements
     ========================


    """
def author(Bibliographic, TextElement): pass
    """
     =====================
      Decorative Elements
     =====================


    """
    def get_header(self):
        """
         =====================
          Structural Elements
         =====================


        """
def topic(Structural, Element):
    """

        Topics are terminal, "leaf" mini-sections, like block quotes with titles,
        or textual figures.  A topic is just like a section, except that it has no
        subsections, and it doesn't have to conform to section placement rules.

        Topics are allowed wherever body elements (list, table, etc.) are allowed,
        but only at the top level of a section or document.  Topics cannot nest
        inside topics, sidebars, or body elements; you can't have a topic inside a
        table, list, block quote, etc.
    
    """
def sidebar(Structural, Element):
    """

        Sidebars are like miniature, parallel documents that occur inside other
        documents, providing related or reference material.  A sidebar is
        typically offset by a border and "floats" to the side of the page; the
        document's main text may flow around it.  Sidebars can also be likened to
        super-footnotes; their content is outside of the flow of the document's
        main text.

        Sidebars are allowed wherever body elements (list, table, etc.) are
        allowed, but only at the top level of a section or document.  Sidebars
        cannot nest inside sidebars, topics, or body elements; you can't have a
        sidebar inside a table, list, block quote, etc.
    
    """
def transition(Structural, Element): pass
    """
     ===============
      Body Elements
     ===============


    """
def compound(General, Element): pass
    """
    ''
    """
def option_argument(Part, TextElement):
    """
    'delimiter'
    """
def option_group(Part, Element):
    """
    ', '
    """
def option_list(Sequential, Element): pass
    """
    '  '
    """
def option_string(Part, TextElement): pass
    """

        System message element.

        Do not instantiate this class directly; use
        ``document.reporter.info/warning/error/severe()`` instead.
    
    """
    def __init__(self, message=None, *children, **attributes):
        """
        'rawsource'
        """
    def astext(self):
        """
        'line'
        """
def pending(Special, Invisible, Element):
    """

        The "pending" element is used to encapsulate a pending operation: the
        operation (transform), the point at which to apply it, and any data it
        requires.  Only the pending operation's location within the document is
        stored in the public document tree (by the "pending" object itself); the
        operation and its data are stored in the "pending" object's internal
        instance attributes.

        For example, say you want a table of contents in your reStructuredText
        document.  The easiest way to specify where to put it is from within the
        document, with a directive::

            .. contents::

        But the "contents" directive can't do its work until the entire document
        has been parsed and possibly transformed to some extent.  So the directive
        code leaves a placeholder behind that will trigger the second phase of its
        processing, something like this::

            <pending ...public attributes...> + internal attributes

        Use `document.note_pending()` so that the
        `docutils.transforms.Transformer` stage of processing can run all pending
        transforms.
    
    """
2021-03-02 20:49:09,499 : INFO : tokenize_signature : --> do i ever get here?
    def __init__(self, transform, details=None,
                 rawsource='', *children, **attributes):
        """
        The `docutils.transforms.Transform` class implementing the pending
                operation.
        """
    def pformat(self, indent='    ', level=0):
        """
        '.. internal attributes:'
        """
    def copy(self):
        """

            Raw data that is to be passed untouched to the Writer.
    
        """
def emphasis(Inline, TextElement): pass
    """
    'alt'
    """
def inline(Inline, TextElement): pass
    """
     ========================================
      Auxiliary Classes, Functions, and Data
     ========================================


    """
def NodeVisitor(object):
    """

        "Visitor" pattern [GoF95]_ abstract superclass implementation for
        document tree traversals.

        Each node class has corresponding methods, doing nothing by
        default; override individual methods for specific and useful
        behaviour.  The `dispatch_visit()` method is called by
        `Node.walk()` upon entering a node.  `Node.walkabout()` also calls
        the `dispatch_departure()` method before exiting a node.

        The dispatch methods call "``visit_`` + node class name" or
        "``depart_`` + node class name", resp.

        This is a base class for visitors whose ``visit_...`` & ``depart_...``
        methods should be implemented for *all* node types encountered (such as
        for `docutils.writers.Writer` subclasses).  Unimplemented methods will
        raise exceptions.

        For sparse traversals, where only certain node types are of interest,
        subclass `SparseNodeVisitor` instead.  When (mostly or entirely) uniform
        processing is desired, subclass `GenericNodeVisitor`.

        .. [GoF95] Gamma, Helm, Johnson, Vlissides. *Design Patterns: Elements of
           Reusable Object-Oriented Software*. Addison-Wesley, Reading, MA, USA,
           1995.
    
    """
    def __init__(self, document):
        """

                Call self."``visit_`` + node class name" with `node` as
                parameter.  If the ``visit_...`` method does not exist, call
                self.unknown_visit.
        
        """
    def dispatch_departure(self, node):
        """

                Call self."``depart_`` + node class name" with `node` as
                parameter.  If the ``depart_...`` method does not exist, call
                self.unknown_departure.
        
        """
    def unknown_visit(self, node):
        """

                Called when entering unknown `Node` types.

                Raise an exception unless overridden.
        
        """
    def unknown_departure(self, node):
        """

                Called before exiting unknown `Node` types.

                Raise exception unless overridden.
        
        """
def SparseNodeVisitor(NodeVisitor):
    """

        Base class for sparse traversals, where only certain node types are of
        interest.  When ``visit_...`` & ``depart_...`` methods should be
        implemented for *all* node types (such as for `docutils.writers.Writer`
        subclasses), subclass `NodeVisitor` instead.
    
    """
def GenericNodeVisitor(NodeVisitor):
    """

        Generic "Visitor" abstract superclass, for simple traversals.

        Unless overridden, each ``visit_...`` method calls `default_visit()`, and
        each ``depart_...`` method (when using `Node.walkabout()`) calls
        `default_departure()`. `default_visit()` (and `default_departure()`) must
        be overridden in subclasses.

        Define fully generic visitors by overriding `default_visit()` (and
        `default_departure()`) only. Define semi-generic visitors by overriding
        individual ``visit_...()`` (and ``depart_...()``) methods also.

        `NodeVisitor.unknown_visit()` (`NodeVisitor.unknown_departure()`) should
        be overridden for default behavior.
    
    """
    def default_visit(self, node):
        """
        Override for generic, uniform traversals.
        """
    def default_departure(self, node):
        """
        Override for generic, uniform traversals.
        """
def _call_default_visit(self, node):
    """
    Save typing with dynamic assignments:
    """
def TreeCopyVisitor(GenericNodeVisitor):
    """

        Make a complete copy of a tree or branch, including element attributes.
    
    """
    def __init__(self, document):
        """
        Copy the current node, and make it the new acting parent.
        """
    def default_departure(self, node):
        """
        Restore the previous acting parent.
        """
def TreePruningException(Exception):
    """

        Base class for `NodeVisitor`-related tree pruning exceptions.

        Raise subclasses from within ``visit_...`` or ``depart_...`` methods
        called from `Node.walk()` and `Node.walkabout()` tree traversals to prune
        the tree traversed.
    
    """
def SkipChildren(TreePruningException):
    """

        Do not visit any children of the current node.  The current node's
        siblings and ``depart_...`` method are not affected.
    
    """
def SkipSiblings(TreePruningException):
    """

        Do not visit any more siblings (to the right) of the current node.  The
        current node's children and its ``depart_...`` method are not affected.
    
    """
def SkipNode(TreePruningException):
    """

        Do not visit the current node's children, and do not call the current
        node's ``depart_...`` method.
    
    """
def SkipDeparture(TreePruningException):
    """

        Do not call the current node's ``depart_...`` method.  The current node's
        children and siblings are not affected.
    
    """
def NodeFound(TreePruningException):
    """

        Raise to indicate that the target of a search has been found.  This
        exception must be caught by the client; it is not caught by the traversal
        code.
    
    """
def StopTraversal(TreePruningException):
    """

        Stop the traversal alltogether.  The current node's ``depart_...`` method
        is not affected.  The parent nodes ``depart_...`` methods are also called
        as usual.  No other nodes are visited.  This is an alternative to
        NodeFound that does not cause exception handling to trickle up to the
        caller.
    
    """
def make_id(string):
    """

        Convert `string` into an identifier and return it.

        Docutils identifiers will conform to the regular expression
        ``[a-z](-?[a-z0-9]+)*``.  For CSS compatibility, identifiers (the "class"
        and "id" attributes) should have no underscores, colons, or periods.
        Hyphens may be used.

        - The `HTML 4.01 spec`_ defines identifiers based on SGML tokens:

              ID and NAME tokens must begin with a letter ([A-Za-z]) and may be
              followed by any number of letters, digits ([0-9]), hyphens ("-"),
              underscores ("_"), colons (":"), and periods (".").

        - However the `CSS1 spec`_ defines identifiers based on the "name" token,
          a tighter interpretation ("flex" tokenizer notation; "latin1" and
          "escape" 8-bit characters have been replaced with entities)::

              unicode     \\[0-9a-f]{1,4}
              latin1      [&iexcl;-&yuml;]
              escape      {unicode}|\\[ -~&iexcl;-&yuml;]
              nmchar      [-a-z0-9]|{latin1}|{escape}
              name        {nmchar}+

        The CSS1 "nmchar" rule does not include underscores ("_"), colons (":"),
        or periods ("."), therefore "class" and "id" attributes should not contain
        these characters. They should be replaced with hyphens ("-"). Combined
        with HTML's requirements (the first character must be a letter; no
        "unicode", "latin1", or "escape" characters), this results in the
        ``[a-z](-?[a-z0-9]+)*`` pattern.

        .. _HTML 4.01 spec: http://www.w3.org/TR/html401
        .. _CSS1 spec: http://www.w3.org/TR/REC-CSS1
    
    """
def dupname(node, name):
    """
    'dupnames'
    """
def fully_normalize_name(name):
    """
    Return a case- and whitespace-normalized name.
    """
def whitespace_normalize_name(name):
    """
    Return a whitespace-normalized name.
    """
def serial_escape(value):
    """
    Escape string values that are elements of a list, for serialization.
    """
def pseudo_quoteattr(value):
    """
    Quote attributes for pseudo-xml
    """
