def StateMachine(object):
    """

        A finite state machine for text filters using regular expressions.

        The input is provided in the form of a list of one-line strings (no
        newlines). States are subclasses of the `State` class. Transitions consist
        of regular expression patterns and transition methods, and are defined in
        each state.

        The state machine is started with the `run()` method, which returns the
        results of processing in a list.
    
    """
    def __init__(self, state_classes, initial_state, debug=False):
        """

                Initialize a `StateMachine` object; add state objects.

                Parameters:

                - `state_classes`: a list of `State` (sub)classes.
                - `initial_state`: a string, the class name of the initial state.
                - `debug`: a boolean; produce verbose output if true (nonzero).
        
        """
    def unlink(self):
        """
        Remove circular references to objects no longer required.
        """
2021-03-02 20:49:09,678 : INFO : tokenize_signature : --> do i ever get here?
    def run(self, input_lines, input_offset=0, context=None,
            input_source=None, initial_state=None):
        """

                Run the state machine on `input_lines`. Return results (a list).

                Reset `self.line_offset` and `self.current_state`. Run the
                beginning-of-file transition. Input one line at a time and check for a
                matching transition. If a match is found, call the transition method
                and possibly change the state. Store the context returned by the
                transition method to be passed on to the next transition matched.
                Accumulate the results returned by the transition methods in a list.
                Run the end-of-file transition. Finally, return the accumulated
                results.

                Parameters:

                - `input_lines`: a list of strings without newlines, or `StringList`.
                - `input_offset`: the line offset of `input_lines` from the beginning
                  of the file.
                - `context`: application-specific storage.
                - `input_source`: name or path of source of `input_lines`.
                - `initial_state`: name of initial state.
        
        """
    def get_state(self, next_state=None):
        """

                Return current state object; set it first if `next_state` given.

                Parameter `next_state`: a string, the name of the next state.

                Exception: `UnknownStateError` raised if `next_state` unknown.
        
        """
    def next_line(self, n=1):
        """
        Load `self.line` with the `n`'th next line and return it.
        """
    def is_next_line_blank(self):
        """
        Return 1 if the next line is blank or non-existant.
        """
    def at_eof(self):
        """
        Return 1 if the input is at or past end-of-file.
        """
    def at_bof(self):
        """
        Return 1 if the input is at or before beginning-of-file.
        """
    def previous_line(self, n=1):
        """
        Load `self.line` with the `n`'th previous line and return it.
        """
    def goto_line(self, line_offset):
        """
        Jump to absolute line offset `line_offset`, load and return it.
        """
    def get_source(self, line_offset):
        """
        Return source of line at absolute line offset `line_offset`.
        """
    def abs_line_offset(self):
        """
        Return line offset of current line, from beginning of file.
        """
    def abs_line_number(self):
        """
        Return line number of current line (counting from 1).
        """
    def get_source_and_line(self, lineno=None):
        """
        Return (source, line) tuple for current or given line number.

                Looks up the source and line number in the `self.input_lines`
                StringList instance to count for included source files.

                If the optional argument `lineno` is given, convert it from an
                absolute line number to the corresponding (source, line) pair.
        
        """
    def insert_input(self, input_lines, source):
        """
        ''
        """
    def get_text_block(self, flush_left=False):
        """

                Return a contiguous block of text.

                If `flush_left` is true, raise `UnexpectedIndentationError` if an
                indented line is encountered before the text block ends (with a blank
                line).
        
        """
    def check_line(self, context, state, transitions=None):
        """

                Examine one line of input for a transition match & execute its method.

                Parameters:

                - `context`: application-dependent storage.
                - `state`: a `State` object, the current state.
                - `transitions`: an optional ordered list of transition names to try,
                  instead of ``state.transition_order``.

                Return the values returned by the transition method:

                - context: possibly modified from the parameter `context`;
                - next state name (`State` subclass name);
                - the result output of the transition, a list.

                When there is no match, ``state.no_match()`` is called and its return
                value is returned.
        
        """
    def add_state(self, state_class):
        """

                Initialize & add a `state_class` (`State` subclass) object.

                Exception: `DuplicateStateError` raised if `state_class` was already
                added.
        
        """
    def add_states(self, state_classes):
        """

                Add `state_classes` (a list of `State` subclasses).
        
        """
    def runtime_init(self):
        """

                Initialize `self.states`.
        
        """
    def error(self):
        """
        Report error details.
        """
    def attach_observer(self, observer):
        """

                The `observer` parameter is a function or bound method which takes two
                arguments, the source and offset of the current line.
        
        """
    def detach_observer(self, observer):
        """

            State superclass. Contains a list of transitions, and transition methods.

            Transition methods all have the same signature. They take 3 parameters:

            - An `re` match object. ``match.string`` contains the matched input line,
              ``match.start()`` gives the start index of the match, and
              ``match.end()`` gives the end index.
            - A context object, whose meaning is application-defined (initial value
              ``None``). It can be used to store any information required by the state
              machine, and the retured context is passed on to the next transition
              method unchanged.
            - The name of the next state, a string, taken from the transitions list;
              normally it is returned unchanged, but it may be altered by the
              transition method if necessary.

            Transition methods all return a 3-tuple:

            - A context object, as (potentially) modified by the transition method.
            - The next state name (a return value of ``None`` means no state change).
            - The processing result, a list, which is accumulated by the state
              machine.

            Transition methods may raise an `EOFError` to cut processing short.

            There are two implicit transitions, and corresponding transition methods
            are defined: `bof()` handles the beginning-of-file, and `eof()` handles
            the end-of-file. These methods have non-standard signatures and return
            values. `bof()` returns the initial context and results, and may be used
            to return a header string, or do any other processing needed. `eof()`
            should handle any remaining context and wrap things up; it returns the
            final processing result.

            Typical applications need only subclass `State` (or a subclass), set the
            `patterns` and `initial_transitions` class attributes, and provide
            corresponding transition methods. The default object initialization will
            take care of constructing the list of transitions.
    
        """
    def __init__(self, state_machine, debug=False):
        """

                Initialize a `State` object; make & add initial transitions.

                Parameters:

                - `statemachine`: the controlling `StateMachine` object.
                - `debug`: a boolean; produce verbose output if true.
        
        """
    def runtime_init(self):
        """

                Initialize this `State` before running the state machine; called from
                `self.state_machine.run()`.
        
        """
    def unlink(self):
        """
        Remove circular references to objects no longer required.
        """
    def add_initial_transitions(self):
        """
        Make and add transitions listed in `self.initial_transitions`.
        """
    def add_transitions(self, names, transitions):
        """

                Add a list of transitions to the start of the transition list.

                Parameters:

                - `names`: a list of transition names.
                - `transitions`: a mapping of names to transition tuples.

                Exceptions: `DuplicateTransitionError`, `UnknownTransitionError`.
        
        """
    def add_transition(self, name, transition):
        """

                Add a transition to the start of the transition list.

                Parameter `transition`: a ready-made transition 3-tuple.

                Exception: `DuplicateTransitionError`.
        
        """
    def remove_transition(self, name):
        """

                Remove a transition by `name`.

                Exception: `UnknownTransitionError`.
        
        """
    def make_transition(self, name, next_state=None):
        """

                Make & return a transition tuple based on `name`.

                This is a convenience function to simplify transition creation.

                Parameters:

                - `name`: a string, the name of the transition pattern & method. This
                  `State` object must have a method called '`name`', and a dictionary
                  `self.patterns` containing a key '`name`'.
                - `next_state`: a string, the name of the next `State` object for this
                  transition. A value of ``None`` (or absent) implies no state change
                  (i.e., continue with the same state).

                Exceptions: `TransitionPatternNotFound`, `TransitionMethodNotFound`.
        
        """
    def make_transitions(self, name_list):
        """

                Return a list of transition names and a transition mapping.

                Parameter `name_list`: a list, where each entry is either a transition
                name string, or a 1- or 2-tuple (transition name, optional next state
                name).
        
        """
    def no_match(self, context, transitions):
        """

                Called when there is no match from `StateMachine.check_line()`.

                Return the same values returned by transition methods:

                - context: unchanged;
                - next state name: ``None``;
                - empty result list.

                Override in subclasses to catch this event.
        
        """
    def bof(self, context):
        """

                Handle beginning-of-file. Return unchanged `context`, empty result.

                Override in subclasses.

                Parameter `context`: application-defined storage.
        
        """
    def eof(self, context):
        """

                Handle end-of-file. Return empty result.

                Override in subclasses.

                Parameter `context`: application-defined storage.
        
        """
    def nop(self, match, context, next_state):
        """

                A "do nothing" transition method.

                Return unchanged `context` & `next_state`, empty result. Useful for
                simple state changes (actionless transitions).
        
        """
def StateMachineWS(StateMachine):
    """

        `StateMachine` subclass specialized for whitespace recognition.

        There are three methods provided for extracting indented text blocks:

        - `get_indented()`: use when the indent is unknown.
        - `get_known_indented()`: use when the indent is known for all lines.
        - `get_first_known_indented()`: use when only the first line's indent is
          known.
    
    """
    def get_indented(self, until_blank=False, strip_indent=True):
        """

                Return a block of indented lines of text, and info.

                Extract an indented block where the indent is unknown for all lines.

                :Parameters:
                    - `until_blank`: Stop collecting at the first blank line if true.
                    - `strip_indent`: Strip common leading indent if true (default).

                :Return:
                    - the indented block (a list of lines of text),
                    - its indent,
                    - its first line offset from BOF, and
                    - whether or not it finished with a blank line.
        
        """
    def get_known_indented(self, indent, until_blank=False, strip_indent=True):
        """

                Return an indented block and info.

                Extract an indented block where the indent is known for all lines.
                Starting with the current line, extract the entire text block with at
                least `indent` indentation (which must be whitespace, except for the
                first line).

                :Parameters:
                    - `indent`: The number of indent columns/characters.
                    - `until_blank`: Stop collecting at the first blank line if true.
                    - `strip_indent`: Strip `indent` characters of indentation if true
                      (default).

                :Return:
                    - the indented block,
                    - its first line offset from BOF, and
                    - whether or not it finished with a blank line.
        
        """
2021-03-02 20:49:09,690 : INFO : tokenize_signature : --> do i ever get here?
    def get_first_known_indented(self, indent, until_blank=False,
                                 strip_indent=True, strip_top=True):
        """

                Return an indented block and info.

                Extract an indented block where the indent is known for the first line
                and unknown for all other lines.

                :Parameters:
                    - `indent`: The first line's indent (# of columns/characters).
                    - `until_blank`: Stop collecting at the first blank line if true
                      (1).
                    - `strip_indent`: Strip `indent` characters of indentation if true
                      (1, default).
                    - `strip_top`: Strip blank lines from the beginning of the block.

                :Return:
                    - the indented block,
                    - its indent,
                    - its first line offset from BOF, and
                    - whether or not it finished with a blank line.
        
        """
def StateWS(State):
    """

        State superclass specialized for whitespace (blank lines & indents).

        Use this class with `StateMachineWS`.  The transitions 'blank' (for blank
        lines) and 'indent' (for indented text blocks) are added automatically,
        before any other transitions.  The transition method `blank()` handles
        blank lines and `indent()` handles nested indented blocks.  Indented
        blocks trigger a new state machine to be created by `indent()` and run.
        The class of the state machine to be created is in `indent_sm`, and the
        constructor keyword arguments are in the dictionary `indent_sm_kwargs`.

        The methods `known_indent()` and `firstknown_indent()` are provided for
        indented blocks where the indent (all lines' and first line's only,
        respectively) is known to the transition method, along with the attributes
        `known_indent_sm` and `known_indent_sm_kwargs`.  Neither transition method
        is triggered automatically.
    
    """
    def __init__(self, state_machine, debug=False):
        """

                Initialize a `StateSM` object; extends `State.__init__()`.

                Check for indent state machine attributes, set defaults if not set.
        
        """
    def add_initial_transitions(self):
        """

                Add whitespace-specific transitions before those defined in subclass.

                Extends `State.add_initial_transitions()`.
        
        """
    def blank(self, match, context, next_state):
        """
        Handle blank lines. Does nothing. Override in subclasses.
        """
    def indent(self, match, context, next_state):
        """

                Handle an indented text block. Extend or override in subclasses.

                Recursively run the registered state machine for indented blocks
                (`self.indent_sm`).
        
        """
    def known_indent(self, match, context, next_state):
        """

                Handle a known-indent text block. Extend or override in subclasses.

                Recursively run the registered state machine for known-indent indented
                blocks (`self.known_indent_sm`). The indent is the length of the
                match, ``match.end()``.
        
        """
    def first_known_indent(self, match, context, next_state):
        """

                Handle an indented text block (first line's indent known).

                Extend or override in subclasses.

                Recursively run the registered state machine for known-indent indented
                blocks (`self.known_indent_sm`). The indent is the length of the
                match, ``match.end()``.
        
        """
def _SearchOverride(object):
    """

        Mix-in class to override `StateMachine` regular expression behavior.

        Changes regular expression matching, from the default `re.match()`
        (succeeds only if the pattern matches at the start of `self.line`) to
        `re.search()` (succeeds if the pattern matches anywhere in `self.line`).
        When subclassing a `StateMachine`, list this class **first** in the
        inheritance list of the class definition.
    
    """
    def match(self, pattern):
        """

                Return the result of a regular expression search.

                Overrides `StateMachine.match()`.

                Parameter `pattern`: `re` compiled regular expression.
        
        """
def SearchStateMachine(_SearchOverride, StateMachine):
    """
    `StateMachine` which uses `re.search()` instead of `re.match()`.
    """
def SearchStateMachineWS(_SearchOverride, StateMachineWS):
    """
    `StateMachineWS` which uses `re.search()` instead of `re.match()`.
    """
def ViewList(object):
    """

        List with extended functionality: slices of ViewList objects are child
        lists, linked to their parents. Changes made to a child list also affect
        the parent list.  A child list is effectively a "view" (in the SQL sense)
        of the parent list.  Changes to parent lists, however, do *not* affect
        active child lists.  If a parent list is changed, any active child lists
        should be recreated.

        The start and end of the slice can be trimmed using the `trim_start()` and
        `trim_end()` methods, without affecting the parent list.  The link between
        child and parent lists can be broken by calling `disconnect()` on the
        child list.

        Also, ViewList objects keep track of the source & offset of each item.
        This information is accessible via the `source()`, `offset()`, and
        `info()` methods.
    
    """
2021-03-02 20:49:09,694 : INFO : tokenize_signature : --> do i ever get here?
    def __init__(self, initlist=None, source=None, items=None,
                 parent=None, parent_offset=None):
        """
        The actual list of data, flattened from various sources.
        """
    def __str__(self):
        """
        '%s(%s, items=%s)'
        """
    def __lt__(self, other): return self.data <  self.__cast(other)
        """
         from https://docs.python.org/3.0/whatsnew/3.0.html

        """
    def __cast(self, other):
        """
         The __getitem__()/__setitem__() methods check whether the index
         is a slice first, since indexing a native list with a slice object
         just works.


        """
    def __setitem__(self, i, item):
        """
        'cannot handle slice with stride'
        """
    def __delitem__(self, i):
        """
        'cannot handle slice with stride'
        """
    def __add__(self, other):
        """
        'adding non-ViewList to a ViewList'
        """
    def __radd__(self, other):
        """
        'adding ViewList to a non-ViewList'
        """
    def __iadd__(self, other):
        """
        'argument to += must be a ViewList'
        """
    def __mul__(self, n):
        """
        'extending a ViewList with a non-ViewList'
        """
    def append(self, item, source=None, offset=0):
        """
        'inserting non-ViewList with no source given'
        """
    def pop(self, i=-1):
        """

                Remove items from the start of the list, without touching the parent.
        
        """
    def trim_end(self, n=1):
        """

                Remove items from the end of the list, without touching the parent.
        
        """
    def remove(self, item):
        """
        Return source & offset for index `i`.
        """
    def source(self, i):
        """
        Return source for index `i`.
        """
    def offset(self, i):
        """
        Return offset for index `i`.
        """
    def disconnect(self):
        """
        Break link between this list and parent list.
        """
    def xitems(self):
        """
        Return iterator yielding (source, offset, value) tuples.
        """
    def pprint(self):
        """
        Print the list in `grep` format (`source:offset:value` lines)
        """
def StringList(ViewList):
    """
    A `ViewList` with string-specific methods.
    """
    def trim_left(self, length, start=0, end=sys.maxsize):
        """

                Trim `length` characters off the beginning of each item, in-place,
                from index `start` to `end`.  No whitespace-checking is done on the
                trimmed text.  Does not affect slice parent.
        
        """
    def get_text_block(self, start, flush_left=False):
        """

                Return a contiguous block of text.

                If `flush_left` is true, raise `UnexpectedIndentationError` if an
                indented line is encountered before the text block ends (with a blank
                line).
        
        """
2021-03-02 20:49:09,704 : INFO : tokenize_signature : --> do i ever get here?
    def get_indented(self, start=0, until_blank=False, strip_indent=True,
                     block_indent=None, first_indent=None):
        """

                Extract and return a StringList of indented lines of text.

                Collect all lines with indentation, determine the minimum indentation,
                remove the minimum indentation from all indented lines (unless
                `strip_indent` is false), and return them. All lines up to but not
                including the first unindented line will be returned.

                :Parameters:
                  - `start`: The index of the first line to examine.
                  - `until_blank`: Stop collecting at the first blank line if true.
                  - `strip_indent`: Strip common leading indent if true (default).
                  - `block_indent`: The indent of the entire block, if known.
                  - `first_indent`: The indent of the first line, if known.

                :Return:
                  - a StringList of indented lines with mininum indent removed;
                  - the amount of the indent;
                  - a boolean: did the indented block finish with a blank line or EOF?
        
        """
    def get_2D_block(self, top, left, bottom, right, strip_indent=True):
        """
         get slice from line, care for combining characters

        """
    def pad_double_width(self, pad_char):
        """

                Pad all double-width characters in self by appending `pad_char` to each.
                For East Asian language support.
        
        """
    def replace(self, old, new):
        """
        Replace all occurrences of substring `old` with `new`.
        """
def StateMachineError(Exception): pass
    """

        Raise from within a transition method to switch to another transition.

        Raise with one argument, the new transition name.
    
    """
def StateCorrection(Exception):
    """

        Raise from within a transition method to switch to another state.

        Raise with one or two arguments: new state name, and an optional new
        transition name.
    
    """
2021-03-02 20:49:09,707 : INFO : tokenize_signature : --> do i ever get here?
def string2lines(astring, tab_width=8, convert_whitespace=False,
                 whitespace=re.compile('[\v\f]')):
    """

        Return a list of one-line strings with tabs expanded, no newlines, and
        trailing whitespace stripped.

        Each tab is expanded with between 1 and `tab_width` spaces, so that the
        next character's index becomes a multiple of `tab_width` (8 by default).

        Parameters:

        - `astring`: a multi-line string.
        - `tab_width`: the number of columns between tab stops.
        - `convert_whitespace`: convert form feeds and vertical tabs to spaces?
    
    """
def _exception_data():
    """

        Return exception information:

        - the exception's class name;
        - the exception object;
        - the name of the file containing the offending code;
        - the line number of the offending code;
        - the function name of the offending code.
    
    """
