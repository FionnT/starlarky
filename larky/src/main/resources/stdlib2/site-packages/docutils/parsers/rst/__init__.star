def Parser(docutils.parsers.Parser):
    """
    The reStructuredText parser.
    """
    def __init__(self, rfc2822=False, inliner=None):
        """
        'RFC2822Body'
        """
    def get_transforms(self):
        """
        Parse `inputstring` and populate `document`, a document tree.
        """
def DirectiveError(Exception):
    """

        Store a message and a system message level.

        To be thrown from inside directive code.

        Do not instantiate directly -- use `Directive.directive_error()`
        instead!
    
    """
    def __init__(self, level, message):
        """
        Set error `message` and `level`
        """
def Directive(object):
    """

        Base class for reStructuredText directives.

        The following attributes may be set by subclasses.  They are
        interpreted by the directive parser (which runs the directive
        class):

        - `required_arguments`: The number of required arguments (default:
          0).

        - `optional_arguments`: The number of optional arguments (default:
          0).

        - `final_argument_whitespace`: A boolean, indicating if the final
          argument may contain whitespace (default: False).

        - `option_spec`: A dictionary, mapping known option names to
          conversion functions such as `int` or `float` (default: {}, no
          options).  Several conversion functions are defined in the
          directives/__init__.py module.

          Option conversion functions take a single parameter, the option
          argument (a string or ``None``), validate it and/or convert it
          to the appropriate form.  Conversion functions may raise
          `ValueError` and `TypeError` exceptions.

        - `has_content`: A boolean; True if content is allowed.  Client
          code must handle the case where content is required but not
          supplied (an empty content list will be supplied).

        Arguments are normally single whitespace-separated words.  The
        final argument may contain whitespace and/or newlines if
        `final_argument_whitespace` is True.

        If the form of the arguments is more complex, specify only one
        argument (either required or optional) and set
        `final_argument_whitespace` to True; the client code must do any
        context-sensitive parsing.

        When a directive implementation is being run, the directive class
        is instantiated, and the `run()` method is executed.  During
        instantiation, the following instance variables are set:

        - ``name`` is the directive type or name (string).

        - ``arguments`` is the list of positional arguments (strings).

        - ``options`` is a dictionary mapping option names (strings) to
          values (type depends on option conversion functions; see
          `option_spec` above).

        - ``content`` is a list of strings, the directive content line by line.

        - ``lineno`` is the absolute line number of the first line
          of the directive.

        - ``content_offset`` is the line offset of the first line of the content from
          the beginning of the current input.  Used when initiating a nested parse.

        - ``block_text`` is a string containing the entire directive.

        - ``state`` is the state which called the directive function.

        - ``state_machine`` is the state machine which controls the state which called
          the directive function.

        Directive functions return a list of nodes which will be inserted
        into the document tree at the point where the directive was
        encountered.  This can be an empty list if there is nothing to
        insert.

        For ordinary directives, the list must contain body elements or
        structural elements.  Some directives are intended specifically
        for substitution definitions, and must return a list of `Text`
        nodes and/or inline elements (suitable for inline insertion, in
        place of the substitution reference).  Such directives must verify
        substitution definition context, typically using code like this::

            if not isinstance(state, states.SubstitutionDef):
                error = state_machine.reporter.error(
                    'Invalid context: the "%s" directive can only be used '
                    'within a substitution definition.' % (name),
                    nodes.literal_block(block_text, block_text), line=lineno)
                return [error]
    
    """
2021-03-02 20:48:50,955 : INFO : tokenize_signature : --> do i ever get here?
    def __init__(self, name, arguments, options, content, lineno,
                 content_offset, block_text, state, state_machine):
        """
        'Must override run() is subclass.'
        """
    def directive_error(self, level, message):
        """

                Return a DirectiveError suitable for being thrown as an exception.

                Call "raise self.directive_error(level, message)" from within
                a directive implementation to return one single system message
                at level `level`, which automatically gets the directive block
                and the line number added.

                Preferably use the `debug`, `info`, `warning`, `error`, or `severe`
                wrapper methods, e.g. ``self.error(message)`` to generate an
                ERROR-level directive error.
        
        """
    def debug(self, message):
        """
         Convenience methods:


        """
    def assert_has_content(self):
        """

                Throw an ERROR-level DirectiveError if the directive doesn't
                have contents.
        
        """
    def add_name(self, node):
        """
        Append self.options['name'] to node['names'] if it exists.

                Also normalize the name string and register it as explicit target.
        
        """
def convert_directive_function(directive_fn):
    """

        Define & return a directive class generated from `directive_fn`.

        `directive_fn` uses the old-style, functional interface.
    
    """
    def FunctionalDirective(Directive):
    """
    'options'
    """
        def run(self):
            """
             Return new-style directive.

            """
