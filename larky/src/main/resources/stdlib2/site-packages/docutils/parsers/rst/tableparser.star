def TableMarkupError(DataError):
    """

        Raise if there is any problem with table markup.

        The keyword argument `offset` denotes the offset of the problem
        from the table's start line.
    
    """
    def __init__(self, *args, **kwargs):
        """
        'offset'
        """
def TableParser(object):
    """

        Abstract superclass for the common parts of the syntax-specific parsers.
    
    """
    def parse(self, block):
        """

                Analyze the text `block` and return a table data structure.

                Given a plaintext-graphic table in `block` (list of lines of text; no
                whitespace padding), parse the table, construct and return the data
                necessary to construct a CALS table or equivalent.

                Raise `TableMarkupError` if there is any problem with the markup.
        
        """
    def find_head_body_sep(self):
        """
        Look for a head/body row separator line; store the line index.
        """
def GridTableParser(TableParser):
    """

        Parse a grid table using `parse()`.

        Here's an example of a grid table::

            +------------------------+------------+----------+----------+
            | Header row, column 1   | Header 2   | Header 3 | Header 4 |
            +========================+============+==========+==========+
            | body row 1, column 1   | column 2   | column 3 | column 4 |
            +------------------------+------------+----------+----------+
            | body row 2             | Cells may span columns.          |
            +------------------------+------------+---------------------+
            | body row 3             | Cells may  | - Table cells       |
            +------------------------+ span rows. | - contain           |
            | body row 4             |            | - body elements.    |
            +------------------------+------------+---------------------+

        Intersections use '+', row separators use '-' (except for one optional
        head/body row separator, which uses '='), and column separators use '|'.

        Passing the above table to the `parse()` method will result in the
        following data structure::

            ([24, 12, 10, 10],
             [[(0, 0, 1, ['Header row, column 1']),
               (0, 0, 1, ['Header 2']),
               (0, 0, 1, ['Header 3']),
               (0, 0, 1, ['Header 4'])]],
             [[(0, 0, 3, ['body row 1, column 1']),
               (0, 0, 3, ['column 2']),
               (0, 0, 3, ['column 3']),
               (0, 0, 3, ['column 4'])],
              [(0, 0, 5, ['body row 2']),
               (0, 2, 5, ['Cells may span columns.']),
               None,
               None],
              [(0, 0, 7, ['body row 3']),
               (1, 0, 7, ['Cells may', 'span rows.', '']),
               (1, 1, 7, ['- Table cells', '- contain', '- body elements.']),
               None],
              [(0, 0, 9, ['body row 4']), None, None, None]])

        The first item is a list containing column widths (colspecs). The second
        item is a list of head rows, and the third is a list of body rows. Each
        row contains a list of cells. Each cell is either None (for a cell unused
        because of another cell's span), or a tuple. A cell tuple contains four
        items: the number of extra rows used by the cell in a vertical span
        (morerows); the number of extra columns used by the cell in a horizontal
        span (morecols); the line offset of the first line of the cell contents;
        and the cell contents, a list of lines of text.
    
    """
    def setup(self, block):
        """
         make a copy; it may be modified
        """
    def parse_table(self):
        """

                Start with a queue of upper-left corners, containing the upper-left
                corner of the table itself. Trace out one rectangular cell, remember
                it, and add its upper-right and lower-left corners to the queue of
                potential upper-left corners of further cells. Process the queue in
                top-to-bottom order, keeping track of how much of each text column has
                been seen.

                We'll end up knowing all the row and column boundaries, cell positions
                and their dimensions.
        
        """
    def mark_done(self, top, left, bottom, right):
        """
        For keeping track of how much of each text column has been seen.
        """
    def check_parse_complete(self):
        """
        Each text column should have been completely seen.
        """
    def scan_cell(self, top, left):
        """
        Starting at the top-left corner, start tracing out a cell.
        """
    def scan_right(self, top, left):
        """

                Look for the top-right corner of the cell, and make note of all column
                boundaries ('+').
        
        """
    def scan_down(self, top, left, right):
        """

                Look for the bottom-right corner of the cell, making note of all row
                boundaries.
        
        """
    def scan_left(self, top, left, bottom, right):
        """

                Noting column boundaries, look for the bottom-left corner of the cell.
                It must line up with the starting point.
        
        """
    def scan_up(self, top, left, bottom, right):
        """

                Noting row boundaries, see if we can return to the starting point.
        
        """
    def structure_from_cells(self):
        """

                From the data collected by `scan_cell()`, convert to the final data
                structure.
        
        """
def SimpleTableParser(TableParser):
    """

        Parse a simple table using `parse()`.

        Here's an example of a simple table::

            =====  =====
            col 1  col 2
            =====  =====
            1      Second column of row 1.
            2      Second column of row 2.
                   Second line of paragraph.
            3      - Second column of row 3.

                   - Second item in bullet
                     list (row 3, column 2).
            4 is a span
            ------------
            5
            =====  =====

        Top and bottom borders use '=', column span underlines use '-', column
        separation is indicated with spaces.

        Passing the above table to the `parse()` method will result in the
        following data structure, whose interpretation is the same as for
        `GridTableParser`::

            ([5, 25],
             [[(0, 0, 1, ['col 1']),
               (0, 0, 1, ['col 2'])]],
             [[(0, 0, 3, ['1']),
               (0, 0, 3, ['Second column of row 1.'])],
              [(0, 0, 4, ['2']),
               (0, 0, 4, ['Second column of row 2.',
                          'Second line of paragraph.'])],
              [(0, 0, 6, ['3']),
               (0, 0, 6, ['- Second column of row 3.',
                          '',
                          '- Second item in bullet',
                          '  list (row 3, column 2).'])],
              [(0, 1, 10, ['4 is a span'])],
              [(0, 0, 12, ['5']),
               (0, 0, 12, [''])]])
    
    """
    def setup(self, block):
        """
         make a copy; it will be modified
        """
    def parse_table(self):
        """

                First determine the column boundaries from the top border, then
                process rows.  Each row may consist of multiple lines; accumulate
                lines until a row is complete.  Call `self.parse_row` to finish the
                job.
        
        """
    def parse_columns(self, line, offset):
        """

                Given a column span underline, return a list of (begin, end) pairs.
        
        """
    def init_row(self, colspec, offset):
        """
        'Column span alignment problem '
        'in table line %s.'
        """
    def parse_row(self, lines, start, spanline=None):
        """

                Given the text `lines` of a row, parse it and append to `self.table`.

                The row is parsed according to the current column spec (either
                `spanline` if provided or `self.columns`).  For each column, extract
                text from each line, and check for text in column margins.  Finally,
                adjust for insignificant whitespace.
        
        """
    def check_columns(self, lines, first_line, columns):
        """

                Check for text in column margins and text overflow in the last column.
                Raise TableMarkupError if anything but whitespace is in column margins.
                Adjust the end value for the last column if there is text overflow.
        
        """
    def structure_from_cells(self):
        """

            Extend the list values of `master` with those from `newdata`.

            Both parameters must be dictionaries containing list values.
    
        """
