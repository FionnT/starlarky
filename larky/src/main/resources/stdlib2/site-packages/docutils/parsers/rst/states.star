def MarkupError(DataError): pass
    """
    Stores data attributes for dotted-attribute access.
    """
    def __init__(self, **keywordargs):
        """

            reStructuredText's master StateMachine.

            The entry point to reStructuredText parsing is the `run()` method.
    
        """
2021-03-02 20:48:55,845 : INFO : tokenize_signature : --> do i ever get here?
    def run(self, input_lines, document, input_offset=0, match_titles=True,
            inliner=None):
        """

                Parse `input_lines` and modify the `document` node in place.

                Extend `StateMachineWS.run()`: set up parse-global data and
                run the StateMachine.
        
        """
def NestedStateMachine(StateMachineWS):
    """

        StateMachine run from within other StateMachine runs, to parse nested
        document structures.
    
    """
    def run(self, input_lines, input_offset, memo, node, match_titles=True):
        """

                Parse `input_lines` and populate a `docutils.nodes.document` instance.

                Extend `StateMachineWS.run()`: set up document-wide data.
        
        """
def RSTState(StateWS):
    """

        reStructuredText State superclass.

        Contains methods used by all State subclasses.
    
    """
    def __init__(self, state_machine, debug=False):
        """
        'state_classes'
        """
    def runtime_init(self):
        """
         enable the reporter to determine source and source-line

        """
    def goto_line(self, abs_line_offset):
        """

                Jump to input line `abs_line_offset`, ignoring jumps past the end.
        
        """
    def no_match(self, context, transitions):
        """

                Override `StateWS.no_match` to generate a system message.

                This code should never be run.
        
        """
    def bof(self, context):
        """
        Called at beginning of file.
        """
2021-03-02 20:48:55,847 : INFO : tokenize_signature : --> do i ever get here?
    def nested_parse(self, block, input_offset, node, match_titles=False,
                     state_machine_class=None, state_machine_kwargs=None):
        """

                Create a new StateMachine rooted at `node` and run it over the input
                `block`.
        
        """
2021-03-02 20:48:55,848 : INFO : tokenize_signature : --> do i ever get here?
2021-03-02 20:48:55,848 : INFO : tokenize_signature : --> do i ever get here?
2021-03-02 20:48:55,848 : INFO : tokenize_signature : --> do i ever get here?
2021-03-02 20:48:55,848 : INFO : tokenize_signature : --> do i ever get here?
2021-03-02 20:48:55,849 : INFO : tokenize_signature : --> do i ever get here?
2021-03-02 20:48:55,849 : INFO : tokenize_signature : --> do i ever get here?
    def nested_list_parse(self, block, input_offset, node, initial_state,
                          blank_finish,
                          blank_finish_state=None,
                          extra_settings={},
                          match_titles=False,
                          state_machine_class=None,
                          state_machine_kwargs=None):
        """

                Create a new StateMachine rooted at `node` and run it over the input
                `block`. Also keep track of optional intermediate blank lines and the
                required final one.
        
        """
    def section(self, title, source, style, lineno, messages):
        """
        Check for a valid subsection and create one if it checks out.
        """
    def check_subsection(self, source, style, lineno):
        """

                Check for a valid subsection header.  Return 1 (true) or None (false).

                When a new section is reached that isn't a subsection of the current
                section, back up the line count (use ``previous_line(-x)``), then
                ``raise EOFError``.  The current StateMachine will finish, then the
                calling StateMachine can re-examine the title.  This will work its way
                back up the calling chain until the correct section level isreached.

                @@@ Alternative: Evaluate the title, store the title info & level, and
                back up the chain until that level is reached.  Store in memo? Or
                return in results?

                :Exception: `EOFError` when a sibling or supersection encountered.
        
        """
    def title_inconsistent(self, sourcetext, lineno):
        """
        'Title level inconsistent:'
        """
    def new_subsection(self, title, lineno, messages):
        """
        Append new subsection to document tree. On return, check level.
        """
    def paragraph(self, lines, lineno):
        """

                Return a list (paragraph & messages) & a boolean: literal_block next?
        
        """
    def inline_text(self, text, lineno):
        """

                Return 2 lists: nodes (text and inline elements), and system_messages.
        
        """
    def unindent_warning(self, node_name):
        """
         the actual problem is one line below the current line

        """
def build_regexp(definition, compile=True):
    """

        Build, compile and return a regular expression based on `definition`.

        :Parameter: `definition`: a 4-tuple (group name, prefix, suffix, parts),
            where "parts" is a list of regular expressions and/or regular
            expression definitions to be joined into an or-group.
    
    """
def Inliner(object):
    """

        Parse inline markup; call the `parse()` method.
    
    """
    def __init__(self):
        """
        List of (pattern, bound method) tuples, used by
                `self.implicit_inline`.
        """
    def init_customizations(self, settings):
        """
         lookahead and look-behind expressions for inline markup rules

        """
    def parse(self, text, lineno, memo, parent):
        """
         Needs to be refactored for nested inline markup.
         Add nested_parse() method?

        """
    def quoted_start(self, match):
        """
        Test if inline markup start-string is 'quoted'.

                'Quoted' in this context means the start-string is enclosed in a pair
                of matching opening/closing delimiters (not necessarily quotes)
                or at the end of the match.
        
        """
2021-03-02 20:48:55,857 : INFO : tokenize_signature : --> do i ever get here?
    def inline_obj(self, match, lineno, end_pattern, nodeclass,
                   restore_backslashes=False):
        """
        'start'
        """
    def problematic(self, text, rawsource, message):
        """
        'backquote'
        """
    def phrase_ref(self, before, after, rawsource, escaped, text=None):
        """
         `text` is ignored (since 0.16)

        """
    def adjust_uri(self, uri):
        """
        'mailto:'
        """
    def interpreted(self, rawsource, text, role, lineno):
        """
        'Unknown interpreted text role "%s".'
        """
    def literal(self, match, lineno):
        """
        'names'
        """
    def substitution_reference(self, match, lineno):
        """
        '_'
        """
    def footnote_reference(self, match, lineno):
        """

                Handles `nodes.footnote_reference` and `nodes.citation_reference`
                elements.
        
        """
    def reference(self, match, lineno, anonymous=False):
        """
        'refname'
        """
    def anonymous_reference(self, match, lineno):
        """
        'scheme'
        """
    def pep_reference(self, match, lineno):
        """
        'pep-'
        """
    def rfc_reference(self, match, lineno):
        """
        'RFC'
        """
    def implicit_inline(self, text, lineno):
        """

                Check each of the patterns in `self.implicit_dispatch` for a match,
                and dispatch to the stored method for the pattern.  Recursively check
                the text before and after the match.  Return a list of `nodes.Text`
                and inline element nodes.
        
        """
def _loweralpha_to_int(s, _zero=(ord('a')-1)):
    """
    'A'
    """
def _lowerroman_to_int(s):
    """

        Generic classifier of the first line of a block.
    
    """
    def indent(self, match, context, next_state):
        """
        Block quote.
        """
    def block_quote(self, indented, line_offset):
        """
         U+2014 is an em-dash:

        """
    def split_attribution(self, indented, line_offset):
        """

                Check for a block quote attribution and split it off:

                * First line after a blank line must begin with a dash ("--", "---",
                  em-dash; matches `self.attribution_pattern`).
                * Every line after that must have consistent indentation.
                * Attributions must be preceded by block quote content.

                Return a tuple of: (block quote content lines, content offset,
                attribution lines, attribution offset, remaining indented lines).
        
        """
    def check_attribution(self, indented, attribution_start):
        """

                Check attribution shape.
                Return the index past the end of the attribution, and the indent.
        
        """
    def parse_attribution(self, indented, line_offset):
        """
        '\n'
        """
    def bullet(self, match, context, next_state):
        """
        Bullet list item.
        """
    def list_item(self, indent):
        """
        '\n'
        """
    def enumerator(self, match, context, next_state):
        """
        Enumerated List Item
        """
    def parse_enumerator(self, match, expected_sequence=None):
        """

                Analyze an enumerator and return the results.

                :Return:
                    - the enumerator format ('period', 'parens', or 'rparen'),
                    - the sequence used ('arabic', 'loweralpha', 'upperroman', etc.),
                    - the text of the enumerator, stripped of formatting, and
                    - the ordinal value of the enumerator ('a' -> 1, 'ii' -> 2, etc.;
                      ``None`` is returned for invalid enumerator text).

                The enumerator format has already been determined by the regular
                expression match. If `expected_sequence` is given, that sequence is
                tried first. If not, we check for Roman numeral 1. This way,
                single-character Roman numerals (which are also alphabetical) can be
                matched. If no sequence has been matched, all sequences are checked in
                order.
        
        """
    def is_enumerated_list_item(self, ordinal, sequence, format):
        """

                Check validity based on the ordinal value and the second line.

                Return true if the ordinal is valid and the second line is blank,
                indented, or starts with the next enumerator or an auto-enumerator.
        
        """
    def make_enumerator(self, ordinal, sequence, format):
        """

                Construct and return the next enumerated list item marker, and an
                auto-enumerator ("#" instead of the regular enumerator).

                Return ``None`` for invalid (out of range) ordinals.
        
        """
    def field_marker(self, match, context, next_state):
        """
        Field list item.
        """
    def field(self, match):
        """
        ''
        """
    def parse_field_marker(self, match):
        """
        Extract & return field name from a field marker match.
        """
    def parse_field_body(self, indented, offset, node):
        """
        Option list item.
        """
    def option_list_item(self, match):
        """
         not an option list item
        """
    def parse_option_marker(self, match):
        """

                Return a list of `node.option` and `node.option_argument` objects,
                parsed from an option marker match.

                :Exception: `MarkupError` for invalid option markers.
        
        """
    def doctest(self, match, context, next_state):
        """
        '\n'
        """
    def line_block(self, match, context, next_state):
        """
        First line of a line block.
        """
    def line_block_line(self, match, lineno):
        """
        Return one line element of a line_block.
        """
    def nest_line_block_lines(self, block):
        """
        'indent'
        """
    def nest_line_block_segment(self, block):
        """
        Top border of a full table.
        """
    def simple_table_top(self, match, context, next_state):
        """
        Top border of a simple table.
        """
2021-03-02 20:48:55,886 : INFO : tokenize_signature : --> do i ever get here?
    def table_top(self, match, context, next_state,
                  isolate_function, parser_class):
        """
        Top border of a generic table.
        """
    def table(self, isolate_function, parser_class):
        """
        Parse a table.
        """
    def isolate_grid_table(self):
        """
        'Unexpected indentation.'
        """
    def isolate_simple_table(self):
        """
        'Bottom/header table border does '
        'not match top border.'
        """
    def malformed_table(self, block, detail='', offset=0):
        """
        ''
        """
    def build_table(self, tabledata, tableline, stub_columns=0, widths=None):
        """
        'auto'
        """
    def build_table_row(self, rowdata, tableline):
        """
        'morerows'
        """
    def footnote(self, match):
        """
        '\n'
        """
    def citation(self, match):
        """
        '\n'
        """
    def hyperlink_target(self, match):
        """
        '\n'
        """
    def make_target(self, block, block_text, lineno, target_name):
        """
        'refname'
        """
    def parse_target(self, block, block_text, lineno):
        """

                Determine the type of reference of a target.

                :Return: A 2-tuple, one of:

                    - 'refname' and the indirect reference name
                    - 'refuri' and the URI
                    - 'malformed' and a system_message node
        
        """
    def is_reference(self, reference):
        """
        'simple'
        """
    def add_target(self, targetname, refuri, target, lineno):
        """
        'names'
        """
    def substitution_def(self, match):
        """
        '\n'
        """
    def disallowed_inside_substitution_definitions(self, node):
        """
        'ids'
        """
    def directive(self, match, **option_presets):
        """
        Returns a 2-tuple: list of nodes, and a "blank finish" boolean.
        """
    def run_directive(self, directive, match, type_name, option_presets):
        """

                Parse a directive then run its directive function.

                Parameters:

                - `directive`: The class implementing the directive.  Must be
                  a subclass of `rst.Directive`.

                - `match`: A regular expression match object which matched the first
                  line of the directive.

                - `type_name`: The directive name, as used in the source text.

                - `option_presets`: A dictionary of preset options, defaults for the
                  directive options.  Currently, only an "alt" option is passed by
                  substitution definitions (value: the substitution name), which may
                  be used by an embedded image directive.

                Returns a 2-tuple: list of nodes, and a "blank finish" boolean.
        
        """
2021-03-02 20:48:55,901 : INFO : tokenize_signature : --> do i ever get here?
    def parse_directive_block(self, indented, line_offset, directive,
                              option_presets):
        """
        'no content permitted'
        """
    def parse_directive_options(self, option_presets, option_spec, arg_block):
        """
        'field_marker'
        """
    def parse_directive_arguments(self, directive, arg_block):
        """
        '\n'
        """
    def parse_extension_options(self, option_spec, datalines):
        """

                Parse `datalines` for a field list containing extension options
                matching `option_spec`.

                :Parameters:
                    - `option_spec`: a mapping of option name to conversion
                      function, which should raise an exception on bad input.
                    - `datalines`: a list of input strings.

                :Return:
                    - Success value, 1 or 0.
                    - An option dictionary on success, an error string on failure.
        
        """
    def unknown_directive(self, type_name):
        """
        '\n'
        """
    def comment(self, match):
        """
         an empty comment?
        """
    def explicit_markup(self, match, context, next_state):
        """
        Footnotes, hyperlink targets, directives, comments.
        """
    def explicit_construct(self, match):
        """
        Determine which explicit construct this is, parse & return it.
        """
    def explicit_list(self, blank_finish):
        """

                Create a nested state machine for a series of explicit markup
                constructs (including anonymous hyperlink targets).
        
        """
    def anonymous(self, match, context, next_state):
        """
        Anonymous hyperlink targets.
        """
    def anonymous_target(self, match):
        """
        '\n'
        """
    def line(self, match, context, next_state):
        """
        Section title overline or transition marker.
        """
    def text(self, match, context, next_state):
        """
        Titles, definition lists, paragraphs.
        """
def RFC2822Body(Body):
    """

        RFC2822 headers are only valid as the first constructs in documents.  As
        soon as anything else appears, the `Body` state should take over.
    
    """
    def rfc2822(self, match, context, next_state):
        """
        RFC2822-style field list item.
        """
    def rfc2822_field(self, match):
        """
        ':'
        """
def SpecializedBody(Body):
    """

        Superclass for second and subsequent compound element members.  Compound
        elements are lists and list-like constructs.

        All transition methods are disabled (redefined as `invalid_input`).
        Override individual methods in subclasses to re-enable.

        For example, once an initial bullet list item, say, is recognized, the
        `BulletList` subclass takes over, with a "bullet_list" node as its
        container.  Upon encountering the initial bullet list item, `Body.bullet`
        calls its ``self.nested_list_parse`` (`RSTState.nested_list_parse`), which
        starts up a nested parsing session with `BulletList` as the initial state.
        Only the ``bullet`` transition method is enabled in `BulletList`; as long
        as only bullet list items are encountered, they are parsed and inserted
        into the container.  The first construct which is *not* a bullet list item
        triggers the `invalid_input` method, which ends the nested parse and
        closes the container.  `BulletList` needs to recognize input that is
        invalid in the context of a bullet list, which means everything *other
        than* bullet list items, so it inherits the transition list created in
        `Body`.
    
    """
    def invalid_input(self, match=None, context=None, next_state=None):
        """
        Not a compound element member. Abort this state machine.
        """
def BulletList(SpecializedBody):
    """
    Second and subsequent bullet_list list_items.
    """
    def bullet(self, match, context, next_state):
        """
        Bullet list item.
        """
def DefinitionList(SpecializedBody):
    """
    Second and subsequent definition_list_items.
    """
    def text(self, match, context, next_state):
        """
        Definition lists.
        """
def EnumeratedList(SpecializedBody):
    """
    Second and subsequent enumerated_list list_items.
    """
    def enumerator(self, match, context, next_state):
        """
        Enumerated list item.
        """
def FieldList(SpecializedBody):
    """
    Second and subsequent field_list fields.
    """
    def field_marker(self, match, context, next_state):
        """
        Field list field.
        """
def OptionList(SpecializedBody):
    """
    Second and subsequent option_list option_list_items.
    """
    def option_marker(self, match, context, next_state):
        """
        Option list item.
        """
def RFC2822List(SpecializedBody, RFC2822Body):
    """
    Second and subsequent RFC2822-style field_list fields.
    """
    def rfc2822(self, match, context, next_state):
        """
        RFC2822-style field list item.
        """
def ExtensionOptions(FieldList):
    """

        Parse field_list fields for extension options.

        No nested parsing is done (including inline markup parsing).
    
    """
    def parse_field_body(self, indented, offset, node):
        """
        Override `Body.parse_field_body` for simpler parsing.
        """
def LineBlock(SpecializedBody):
    """
    Second and subsequent lines of a line_block.
    """
    def line_block(self, match, context, next_state):
        """
        New line of line block.
        """
def Explicit(SpecializedBody):
    """
    Second and subsequent explicit markup construct.
    """
    def explicit_markup(self, match, context, next_state):
        """
        Footnotes, hyperlink targets, directives, comments.
        """
    def anonymous(self, match, context, next_state):
        """
        Anonymous hyperlink targets.
        """
def SubstitutionDef(Body):
    """

        Parser for the contents of a substitution_definition element.
    
    """
    def embedded_directive(self, match, context, next_state):
        """
        'names'
        """
    def text(self, match, context, next_state):
        """

            Classifier of second line of a text block.

            Could be a paragraph, a definition list item, or a title.
    
        """
    def blank(self, match, context, next_state):
        """
        End of paragraph.
        """
    def eof(self, context):
        """
        Definition list item.
        """
    def underline(self, match, context, next_state):
        """
        Section title.
        """
    def text(self, match, context, next_state):
        """
        Paragraph.
        """
    def literal_block(self):
        """
        Return a list of nodes.
        """
    def quoted_literal_block(self):
        """
        'state_classes'
        """
    def definition_list_item(self, termline):
        """
        '\n'
        """
    def term(self, lines, lineno):
        """
        Return a definition_list's term and optional classifiers.
        """
def SpecializedText(Text):
    """

        Superclass for second and subsequent lines of Text-variants.

        All transition methods are disabled. Override individual methods in
        subclasses to re-enable.
    
    """
    def eof(self, context):
        """
        Incomplete construct.
        """
    def invalid_input(self, match=None, context=None, next_state=None):
        """
        Not a compound element member. Abort this state machine.
        """
def Definition(SpecializedText):
    """
    Second line of potential definition_list_item.
    """
    def eof(self, context):
        """
        Not a definition.
        """
    def indent(self, match, context, next_state):
        """
        Definition list item.
        """
def Line(SpecializedText):
    """

        Second line of over- & underlined section title or transition marker.
    
    """
    def eof(self, context):
        """
        Transition marker at end of section or document.
        """
    def blank(self, match, context, next_state):
        """
        Transition marker.
        """
    def text(self, match, context, next_state):
        """
        Potential over- & underlined title.
        """
    def underline(self, match, context, next_state):
        """
        '\n'
        """
    def short_overline(self, context, blocktext, lineno, lines=1):
        """
        'Possible incomplete section title.\nTreating the overline as '
        ordinary text because it's so short.
        """
    def state_correction(self, context, lines=1):
        """
        'Body'
        """
def QuotedLiteralBlock(RSTState):
    """

        Nested parse handler for quoted (unindented) literal blocks.

        Special-purpose.  Not for inclusion in `state_classes`.
    
    """
    def __init__(self, state_machine, debug=False):
        """
        '\n'
        """
    def indent(self, match, context, next_state):
        """
        'QuotedLiteralBlock.indent: context should not '
        'be empty!'
        """
    def initial_quoted(self, match, context, next_state):
        """
        Match arbitrary quote character on the first line only.
        """
    def quoted(self, match, context, next_state):
        """
        Match consistent quotes on subsequent lines.
        """
    def text(self, match, context, next_state):
        """
        'Inconsistent literal block quoting.'
        """
