def logger():
    """
    Returns the logger instance used in this module.
    """
def Timeout(TimeoutError):
    """

        Raised when the lock could not be acquired in *timeout*
        seconds.
    
    """
    def __init__(self, lock_file):
        """

        
        """
    def __str__(self):
        """
        The file lock '{}' could not be acquired.
        """
def _Acquire_ReturnProxy(object):
    """

        Implements the base class of a file lock.
    
    """
    def __init__(self, lock_file, timeout = -1):
        """

        
        """
    def lock_file(self):
        """

                The path to the lock file.
        
        """
    def timeout(self):
        """

                You can set a default timeout for the filelock. It will be used as
                fallback value in the acquire method, if no timeout value (*None*) is
                given.

                If you want to disable the timeout, set it to a negative value.

                A timeout of 0 means, that there is exactly one attempt to acquire the
                file lock.

                .. versionadded:: 2.0.0
        
        """
    def timeout(self, value):
        """

        
        """
    def _acquire(self):
        """

                Platform dependent. If the file lock could be
                acquired, self._lock_file_fd holds the file descriptor
                of the lock file.
        
        """
    def _release(self):
        """

                Releases the lock and sets self._lock_file_fd to None.
        
        """
    def is_locked(self):
        """

                True, if the object holds the file lock.

                .. versionchanged:: 2.0.0

                    This was previously a method and is now a property.
        
        """
    def acquire(self, timeout=None, poll_intervall=0.05):
        """

                Acquires the file lock or fails with a :exc:`Timeout` error.

                .. code-block:: python

                    # You can use this method in the context manager (recommended)
                    with lock.acquire():
                        pass

                    # Or use an equivalent try-finally construct:
                    lock.acquire()
                    try:
                        pass
                    finally:
                        lock.release()

                :arg float timeout:
                    The maximum time waited for the file lock.
                    If ``timeout < 0``, there is no timeout and this method will
                    block until the lock could be acquired.
                    If ``timeout`` is None, the default :attr:`~timeout` is used.

                :arg float poll_intervall:
                    We check once in *poll_intervall* seconds if we can acquire the
                    file lock.

                :raises Timeout:
                    if the lock could not be acquired in *timeout* seconds.

                .. versionchanged:: 2.0.0

                    This method returns now a *proxy* object instead of *self*,
                    so that it can be used in a with statement without side effects.
        
        """
    def release(self, force = False):
        """

                Releases the file lock.

                Please note, that the lock is only completly released, if the lock
                counter is 0.

                Also note, that the lock file itself is not automatically deleted.

                :arg bool force:
                    If true, the lock counter is ignored and the lock is released in
                    every case.
        
        """
    def __enter__(self):
        """
         Windows locking mechanism
         ~~~~~~~~~~~~~~~~~~~~~~~~~


        """
def WindowsFileLock(BaseFileLock):
    """

        Uses the :func:`msvcrt.locking` function to hard lock the lock file on
        windows systems.
    
    """
    def _acquire(self):
        """
         Probably another instance of the application
         that acquired the file lock.

        """
def UnixFileLock(BaseFileLock):
    """

        Uses the :func:`fcntl.flock` to hard lock the lock file on unix systems.
    
    """
    def _acquire(self):
        """
         Do not remove the lockfile:

           https://github.com/benediktschmitt/py-filelock/issues/31
           https://stackoverflow.com/questions/17708885/flock-removing-locked-file-without-race-condition

        """
def SoftFileLock(BaseFileLock):
    """

        Simply watches the existence of the lock file.
    
    """
    def _acquire(self):
        """
         The file is already deleted and that's what we want.

        """
