def TraitError(Exception):
    """
    -----------------------------------------------------------------------------
     Utilities
    -----------------------------------------------------------------------------


    """
def isidentifier(s):
    """
    Add our own checks for too many deprecation warnings.

        Limit to once per package.
    
    """
def _deprecated_method(method, cls, method_name, msg):
    """
    Show deprecation warning about a magic method definition.

        Uses warn_explicit to bind warning to method definition instead of triggering code,
        which isn't relevant.
    
    """
def _safe_literal_eval(s):
    """
    Safely evaluate an expression

        Returns original string if eval fails.

        Use only where types are ambiguous.
    
    """
def is_trait(t):
    """
     Returns whether the given value is an instance or subclass of TraitType.
    
    """
def parse_notifier_name(names):
    """
    Convert the name argument to a list of names.

        Examples
        --------
        >>> parse_notifier_name([])
        [All]
        >>> parse_notifier_name("a")
        ['a']
        >>> parse_notifier_name(["a", "b"])
        ['a', 'b']
        >>> parse_notifier_name(All)
        [All]
    
    """
def _SimpleTest:
    """
    <SimpleTest(%r)
    """
    def __str__(self):
        """
        A safe version of inspect.getmembers that handles missing attributes.

            This is useful when there are descriptor based attributes that for
            some reason raise AttributeError even though they exist.  This happens
            in zope.inteface with the __provides__ attribute.
    
        """
def _validate_link(*tuples):
    """
    Validate arguments for traitlet link functions
    """
def link(object):
    """
    Link traits from different objects together so they remain in sync.

        Parameters
        ----------
        source : (object / attribute name) pair
        target : (object / attribute name) pair
        transform: iterable with two callables (optional)
            Data transformation between source and target and target and source.

        Examples
        --------
        >>> c = link((src, "value"), (tgt, "value"))
        >>> src.value = 5  # updates other objects as well
    
    """
    def __init__(self, source, target, transform=None):
        """
        Broken link {}: the source value changed while updating 
        the target.
        """
    def _update_source(self, change):
        """
        Broken link {}: the target value changed while updating 
        the source.
        """
    def unlink(self):
        """
        Link the trait of a source object with traits of target objects.

            Parameters
            ----------
            source : (object, attribute name) pair
            target : (object, attribute name) pair
            transform: callable (optional)
                Data transformation between source and target.

            Examples
            --------
            >>> c = directional_link((src, "value"), (tgt, "value"))
            >>> src.value = 5  # updates target objects
            >>> tgt.value = 6  # does not update source object
    
        """
    def __init__(self, source, target, transform=None):
        """
        -----------------------------------------------------------------------------
         Base Descriptor Class
        -----------------------------------------------------------------------------



        """
    def class_init(self, cls, name):
        """
        Part of the initialization which may depend on the underlying
                HasDescriptors class.

                It is typically overloaded for specific types.

                This method is called by :meth:`MetaHasDescriptors.__init__`
                passing the class (`cls`) and `name` under which the descriptor
                has been assigned.
        
        """
    def subclass_init(self, cls):
        """
        Part of the initialization which may depend on the underlying
                HasDescriptors instance.

                It is typically overloaded for specific types.

                This method is called by :meth:`HasTraits.__new__` and in the
                :meth:`BaseDescriptor.instance_init` method of descriptors holding
                other descriptors.
        
        """
def TraitType(BaseDescriptor):
    """
    A base class for all trait types.
    
    """
2021-03-02 20:53:22,268 : INFO : tokenize_signature : --> do i ever get here?
    def __init__(self, default_value=Undefined, allow_none=False, read_only=None, help=None,
        config=None, **kwargs):
        """
        Declare a traitlet.

                If *allow_none* is True, None is a valid value in addition to any
                values that are normally valid. The default is up to the subclass.
                For most trait types, the default value for ``allow_none`` is False.

                Extra metadata can be associated with the traitlet using the .tag() convenience method
                or by using the traitlet instance's .metadata dictionary.
        
        """
    def from_string(self, s):
        """
        Get a value from a config string

                such as an environment variable or CLI arguments.

                Traits can override this method to define their own
                parsing of config strings.

                .. seealso:: item_from_string

                .. versionadded:: 5.0
        
        """
    def default(self, obj=None):
        """
        The default generator for this trait

                Notes
                -----
                This method is registered to HasTraits classes during ``class_init``
                in the same way that dynamic defaults defined by ``@default`` are.
        
        """
    def get_default_value(self):
        """
        DEPRECATED: Retrieve the static default value for this trait.
                Use self.default_value instead
        
        """
    def init_default_value(self, obj):
        """
        DEPRECATED: Set the static default value for the trait type.
        
        """
    def get(self, obj, cls=None):
        """
         Check for a dynamic initializer.

        """
    def __get__(self, obj, cls=None):
        """
        Get the value of the trait by self.name for the instance.

                Default values are instantiated when :meth:`HasTraits.__new__`
                is called.  Thus by the time this method gets called either the
                default value or a user defined value (they called :meth:`__set__`)
                is in the :class:`HasTraits` instance.
        
        """
    def set(self, obj, value):
        """
         if there is an error in comparing, default to notify

        """
    def __set__(self, obj, value):
        """
        Set the value of the trait by self.name for the instance.

                Values pass through a validation stage where errors are raised when
                impropper types, or types that cannot be coerced, are encountered.
        
        """
    def _validate(self, obj, value):
        """
        'validate'
        """
    def _cross_validate(self, obj, value):
        """
        'trait'
        """
    def __or__(self, other):
        """
        Raise a TraitError

                Parameters
                ----------
                obj : HasTraits or None
                    The instance which owns the trait. If not
                    object is given, then an object agnostic
                    error will be raised.
                value : any
                    The value that caused the error.
                error : Exception (default: None)
                    An error that was raised by a child trait.
                    The arguments of this exception should be
                    of the form ``(value, info, *traits)``.
                    Where the ``value`` and ``info`` are the
                    problem value, and string describing the
                    expected value. The ``traits`` are a series
                    of :class:`TraitType` instances that are
                    "children" of this one (the first being
                    the deepest).
                info : str (default: None)
                    A description of the expected value. By
                    default this is infered from this trait's
                    ``info`` method.
        
        """
    def get_metadata(self, key, default=None):
        """
        DEPRECATED: Get a metadata value.

                Use .metadata[key] or .metadata.get(key, default) instead.
        
        """
    def set_metadata(self, key, value):
        """
        DEPRECATED: Set a metadata key/value.

                Use .metadata[key] = value instead.
        
        """
    def tag(self, **metadata):
        """
        Sets metadata and returns self.

                This allows convenient metadata tagging when initializing the trait, such as:

                >>> Int(0).tag(config=True, sync=True)
        
        """
    def default_value_repr(self):
        """
        -----------------------------------------------------------------------------
         The HasTraits implementation
        -----------------------------------------------------------------------------


        """
def _CallbackWrapper(object):
    """
    An object adapting a on_trait_change callback into an observe callback.

        The comparison operator __eq__ is implemented to enable removal of wrapped
        callbacks.
    
    """
    def __init__(self, cb):
        """
         Bound methods have an additional 'self' argument.

        """
    def __eq__(self, other):
        """
         The wrapper is equal to the wrapped element

        """
    def __call__(self, change):
        """
         The wrapper is callable

        """
def _callback_wrapper(cb):
    """
    A metaclass for HasDescriptors.

        This metaclass makes sure that any TraitType class attributes are
        instantiated and sets their name attribute.
    
    """
    def __new__(mcls, name, bases, classdict):
        """
        Create the HasDescriptors class.
        """
    def __init__(cls, name, bases, classdict):
        """
        Finish initializing the HasDescriptors class.
        """
    def setup_class(cls, classdict):
        """
        Setup descriptor instance on the class

                This sets the :attr:`this_class` and :attr:`name` attributes of each
                BaseDescriptor in the class dict of the newly created ``cls`` before
                calling their :attr:`class_init` method.
        
        """
def MetaHasTraits(MetaHasDescriptors):
    """
    A metaclass for HasTraits.
    """
    def setup_class(cls, classdict):
        """
        A decorator which can be used to observe Traits on a class.

            The handler passed to the decorator will be called with one ``change``
            dict argument. The change dictionary at least holds a 'type' key and a
            'name' key, corresponding respectively to the type of notification and the
            name of the attribute that triggered the notification.

            Other keys may be passed depending on the value of 'type'. In the case
            where type is 'change', we also have the following keys:
            * ``owner`` : the HasTraits instance
            * ``old`` : the old value of the modified trait attribute
            * ``new`` : the new value of the modified trait attribute
            * ``name`` : the name of the modified trait attribute.

            Parameters
            ----------
            *names
                The str names of the Traits to observe on the object.
            type : str, kwarg-only
                The type of event to observe (e.g. 'change')
    
        """
def observe_compat(func):
    """
    Backward-compatibility shim decorator for observers

        Use with:

        @observe('name')
        @observe_compat
        def _foo_changed(self, change):
            ...

        With this, `super()._foo_changed(self, name, old, new)` in subclasses will still work.
        Allows adoption of new observer API without breaking subclasses that override and super.
    
    """
    def compatible_observer(self, change_or_name, old=Undefined, new=Undefined):
        """
        A parent of %s._%s_changed has adopted the new (traitlets 4.1) @observe(change) API
        """
def validate(*names):
    """
    A decorator to register cross validator of HasTraits object's state
        when a Trait is set.

        The handler passed to the decorator must have one ``proposal`` dict argument.
        The proposal dictionary must hold the following keys:

        * ``owner`` : the HasTraits instance
        * ``value`` : the proposed value for the modified trait attribute
        * ``trait`` : the TraitType instance associated with the attribute

        Parameters
        ----------
        names
            The str names of the Traits to validate.

        Notes
        -----
        Since the owner has access to the ``HasTraits`` instance via the 'owner' key,
        the registered cross validator could potentially make changes to attributes
        of the ``HasTraits`` instance. However, we recommend not to do so. The reason
        is that the cross-validation of attributes may run in arbitrary order when
        exiting the ``hold_trait_notifications`` context, and such changes may not
        commute.
    
    """
def default(name):
    """
     A decorator which assigns a dynamic default for a Trait on a HasTraits object.

        Parameters
        ----------
        name
            The str name of the Trait on the object whose default should be generated.

        Notes
        -----
        Unlike observers and validators which are properties of the HasTraits
        instance, default value generators are class-level properties.

        Besides, default generators are only invoked if they are registered in
        subclasses of `this_type`.

        ::

            class A(HasTraits):
                bar = Int()

                @default('bar')
                def get_bar_default(self):
                    return 11

            class B(A):
                bar = Float()  # This trait ignores the default generator defined in
                               # the base class A

            class C(B):

                @default('bar')
                def some_other_default(self):  # This default generator should not be
                    return 3.0                 # ignored since it is defined in a
                                               # class derived from B.a.this_class.
    
    """
def EventHandler(BaseDescriptor):
    """
    Pass `*args` and `**kwargs` to the handler's function if it exists.
    """
    def __get__(self, inst, cls=None):
        """
        The base class for all classes that have descriptors.
    
        """
    def __new__(*args, **kwargs):
        """
         Pass cls as args[0] to allow "cls" as keyword argument

        """
    def setup_instance(*args, **kwargs):
        """

                This is called **before** self.__init__ is called.
        
        """
def HasTraits(HasDescriptors, metadef=MetaHasTraits):
    """
     Pass self as args[0] to allow "self" as keyword argument

    """
    def __init__(self, *args, **kwargs):
        """
         Allow trait values to be set using keyword arguments.
         We need to use setattr for this to trigger validation and
         notifications.

        """
    def __getstate__(self):
        """
         event handlers stored on an instance are
         expected to be reinstantiated during a
         recall of instance_init during __setstate__

        """
    def __setstate__(self, state):
        """
         event handlers are reassigned to self

        """
    def cross_validation_lock(self):
        """

                A contextmanager for running a block with our cross validation lock set
                to True.

                At the end of the block, the lock's value is restored to its value
                prior to entering the block.
        
        """
    def hold_trait_notifications(self):
        """
        Context manager for bundling trait change notifications and cross
                validation.

                Use this when doing multiple trait assignments (init, config), to avoid
                race conditions in trait notifiers requesting other trait values.
                All trait notifications will fire after all values have been assigned.
        
        """
            def compress(past_changes, change):
                """
                Merges the provided change with the last if possible.
                """
            def hold(change):
                """
                 Replace notify_change with `hold`, caching and compressing
                 notifications, disable cross validation and yield.

                """
    def _notify_trait(self, name, old_value, new_value):
        """
        'change'
        """
    def notify_change(self, change):
        """
        Notify observers of a change event
        """
    def _notify_observers(self, event):
        """
        Notify observers of any event
        """
    def _add_notifiers(self, handler, name, type):
        """
        DEPRECATED: Setup a handler to be called when a trait changes.

                This is used to setup dynamic notifications of trait changes.

                Static handlers can be created by creating methods on a HasTraits
                subclass with the naming convention '_[traitname]_changed'.  Thus,
                to create static handler for the trait 'a', create the method
                _a_changed(self, name, old, new) (fewer arguments can be used, see
                below).

                If `remove` is True and `handler` is not specified, all change
                handlers for the specified name are uninstalled.

                Parameters
                ----------
                handler : callable, None
                    A callable that is called when a trait changes.  Its
                    signature can be handler(), handler(name), handler(name, new),
                    handler(name, old, new), or handler(name, old, new, self).
                name : list, str, None
                    If None, the handler will apply to all traits.  If a list
                    of str, handler will apply to all names in the list.  If a
                    str, the handler will apply just to that name.
                remove : bool
                    If False (the default), then install the handler.  If True
                    then unintall it.
        
        """
    def observe(self, handler, names=All, type='change'):
        """
        Setup a handler to be called when a trait changes.

                This is used to setup dynamic notifications of trait changes.

                Parameters
                ----------
                handler : callable
                    A callable that is called when a trait changes. Its
                    signature should be ``handler(change)``, where ``change`` is a
                    dictionary. The change dictionary at least holds a 'type' key.
                    * ``type``: the type of notification.
                    Other keys may be passed depending on the value of 'type'. In the
                    case where type is 'change', we also have the following keys:
                    * ``owner`` : the HasTraits instance
                    * ``old`` : the old value of the modified trait attribute
                    * ``new`` : the new value of the modified trait attribute
                    * ``name`` : the name of the modified trait attribute.
                names : list, str, All
                    If names is All, the handler will apply to all traits.  If a list
                    of str, handler will apply to all names in the list.  If a
                    str, the handler will apply just to that name.
                type : str, All (default: 'change')
                    The type of notification to filter by. If equal to All, then all
                    notifications are passed to the observe handler.
        
        """
    def unobserve(self, handler, names=All, type='change'):
        """
        Remove a trait change handler.

                This is used to unregister handlers to trait change notifications.

                Parameters
                ----------
                handler : callable
                    The callable called when a trait attribute changes.
                names : list, str, All (default: All)
                    The names of the traits for which the specified handler should be
                    uninstalled. If names is All, the specified handler is uninstalled
                    from the list of notifiers corresponding to all changes.
                type : str or All (default: 'change')
                    The type of notification to filter by. If All, the specified handler
                    is uninstalled from the list of notifiers corresponding to all types.
        
        """
    def unobserve_all(self, name=All):
        """
        Remove trait change handlers of any type for the specified name.
                If name is not specified, removes all trait notifiers.
        """
    def _register_validator(self, handler, names):
        """
        Setup a handler to be called when a trait should be cross validated.

                This is used to setup dynamic notifications for cross-validation.

                If a validator is already registered for any of the provided names, a
                TraitError is raised and no new validator is registered.

                Parameters
                ----------
                handler : callable
                    A callable that is called when the given trait is cross-validated.
                    Its signature is handler(proposal), where proposal is a Bunch (dictionary with attribute access)
                    with the following attributes/keys:
                        * ``owner`` : the HasTraits instance
                        * ``value`` : the proposed value for the modified trait attribute
                        * ``trait`` : the TraitType instance associated with the attribute
                names : List of strings
                    The names of the traits that should be cross-validated
        
        """
    def add_traits(self, **traits):
        """
        Dynamically add trait attributes to the HasTraits instance.
        """
    def set_trait(self, name, value):
        """
        Forcibly sets trait attribute, including read-only attributes.
        """
    def class_trait_names(cls, **metadata):
        """
        Get a list of all the names of this class' traits.

                This method is just like the :meth:`trait_names` method,
                but is unbound.
        
        """
    def class_traits(cls, **metadata):
        """
        Get a ``dict`` of all the traits of this class.  The dictionary
                is keyed on the name and the values are the TraitType objects.

                This method is just like the :meth:`traits` method, but is unbound.

                The TraitTypes returned don't know anything about the values
                that the various HasTrait's instances are holding.

                The metadata kwargs allow functions to be passed in which
                filter traits based on metadata values.  The functions should
                take a single value as an argument and return a boolean.  If
                any function returns False, then the trait is not included in
                the output.  If a metadata key doesn't exist, None will be passed
                to the function.
        
        """
    def class_own_traits(cls, **metadata):
        """
        Get a dict of all the traitlets defined on this class, not a parent.

                Works like `class_traits`, except for excluding traits from parents.
        
        """
    def has_trait(self, name):
        """
        Returns True if the object has a trait with the specified name.
        """
    def trait_has_value(self, name):
        """
        Returns True if the specified trait has a value.

                This will return false even if ``getattr`` would return a
                dynamically generated default value. These default values
                will be recognized as existing only after they have been
                generated.

                Example

                .. code-block:: python
                    class MyClass(HasTraits):
                        i = Int()

                    mc = MyClass()
                    assert not mc.trait_has_value("i")
                    mc.i # generates a default value
                    assert mc.trait_has_value("i")
        
        """
    def trait_values(self, **metadata):
        """
        A ``dict`` of trait names and their values.

                The metadata kwargs allow functions to be passed in which
                filter traits based on metadata values.  The functions should
                take a single value as an argument and return a boolean.  If
                any function returns False, then the trait is not included in
                the output.  If a metadata key doesn't exist, None will be passed
                to the function.

                Returns
                -------
                A ``dict`` of trait names and their values.

                Notes
                -----
                Trait values are retrieved via ``getattr``, any exceptions raised
                by traits or the operations they may trigger will result in the
                absence of a trait value in the result ``dict``.
        
        """
    def _get_trait_default_generator(self, name):
        """
        Return default generator for a given trait

                Walk the MRO to resolve the correct default generator according to inheritance.
        
        """
    def trait_defaults(self, *names, **metadata):
        """
        Return a trait's default value or a dictionary of them

                Notes
                -----
                Dynamically generated default values may
                depend on the current state of the object.
        """
    def trait_names(self, **metadata):
        """
        Get a list of all the names of this class' traits.
        """
    def traits(self, **metadata):
        """
        Get a ``dict`` of all the traits of this class.  The dictionary
                is keyed on the name and the values are the TraitType objects.

                The TraitTypes returned don't know anything about the values
                that the various HasTrait's instances are holding.

                The metadata kwargs allow functions to be passed in which
                filter traits based on metadata values.  The functions should
                take a single value as an argument and return a boolean.  If
                any function returns False, then the trait is not included in
                the output.  If a metadata key doesn't exist, None will be passed
                to the function.
        
        """
    def trait_metadata(self, traitname, key, default=None):
        """
        Get metadata values for trait by key.
        """
    def class_own_trait_events(cls, name):
        """
        Get a dict of all event handlers defined on this class, not a parent.

                Works like ``event_handlers``, except for excluding traits from parents.
        
        """
    def trait_events(cls, name=None):
        """
        Get a ``dict`` of all the event handlers of this class.

                Parameters
                ----------
                name : str (default: None)
                    The name of a trait of this class. If name is ``None`` then all
                    the event handlers of this class will be returned instead.

                Returns
                -------
                The event handlers associated with a trait name, or all event handlers.
        
        """
def ClassBasedTraitType(TraitType):
    """

        A trait with error reporting and string -> type resolution for Type,
        Instance and This.
    
    """
    def _resolve_string(self, string):
        """

                Resolve a string supplied for a type into an actual object.
        
        """
def Type(ClassBasedTraitType):
    """
    A trait whose value must be a subclass of a specified class.
    """
    def __init__ (self, default_value=Undefined, klass=None, **kwargs):
        """
        Construct a Type trait

                A Type trait specifies that its values must be subclasses of
                a particular class.

                If only ``default_value`` is given, it is used for the ``klass`` as
                well. If neither are given, both default to ``object``.

                Parameters
                ----------
                default_value : class, str or None
                    The default value must be a subclass of klass.  If an str,
                    the str must be a fully specified class name, like 'foo.bar.Bah'.
                    The string is resolved into real class, when the parent
                    :class:`HasTraits` class is instantiated.
                klass : class, str [ default object ]
                    Values of this trait must be a subclass of klass.  The klass
                    may be specified in a string like: 'foo.bar.MyClass'.
                    The string is resolved into real class, when the parent
                    :class:`HasTraits` class is instantiated.
                allow_none : bool [ default False ]
                    Indicates whether None is allowed as an assignable value.
        
        """
    def validate(self, obj, value):
        """
        Validates that the value is a valid object instance.
        """
    def info(self):
        """
         Returns a description of the trait.
        """
    def instance_init(self, obj):
        """
        f'{value.__module__}.{value.__name__}'
        """
def Instance(ClassBasedTraitType):
    """
    A trait whose value must be an instance of a specified class.

        The value can also be an instance of a subclass of the specified class.

        Subclasses can declare default classes by overriding the klass attribute
    
    """
    def __init__(self, klass=None, args=None, kw=None, **kwargs):
        """
        Construct an Instance trait.

                This trait allows values that are instances of a particular
                class or its subclasses.  Our implementation is quite different
                from that of enthough.traits as we don't allow instances to be used
                for klass and we handle the ``args`` and ``kw`` arguments differently.

                Parameters
                ----------
                klass : class, str
                    The class that forms the basis for the trait.  Class names
                    can also be specified as strings, like 'foo.bar.Bar'.
                args : tuple
                    Positional arguments for generating the default value.
                kw : dict
                    Keyword arguments for generating the default value.
                allow_none : bool [ default False ]
                    Indicates whether None is allowed as a value.

                Notes
                -----
                If both ``args`` and ``kw`` are None, then the default value is None.
                If ``args`` is a tuple and ``kw`` is a dict, then the default is
                created as ``klass(*args, **kw)``.  If exactly one of ``args`` or ``kw`` is
                None, the None is replaced by ``()`` or ``{}``, respectively.
        
        """
    def validate(self, obj, value):
        """
        a
        """
    def instance_init(self, obj):
        """

            Mixin for forward-declared versions of Instance and Type.
    
        """
    def _resolve_string(self, string):
        """

                Find the specified class name by looking for it in the module in which
                our this_class attribute was defined.
        
        """
def ForwardDeclaredType(ForwardDeclaredMixin, Type):
    """

        Forward-declared version of Type.
    
    """
def ForwardDeclaredInstance(ForwardDeclaredMixin, Instance):
    """

        Forward-declared version of Instance.
    
    """
def This(ClassBasedTraitType):
    """
    A trait for instances of the class containing this trait.

        Because how how and when class bodies are executed, the ``This``
        trait can only have a default value of None.  This, and because we
        always validate default values, ``allow_none`` is *always* true.
    
    """
    def __init__(self, **kwargs):
        """
         What if value is a superclass of obj.__class__?  This is
         complicated if it was the superclass that defined the This
         trait.

        """
def Union(TraitType):
    """
    A trait type representing a Union type.
    """
    def __init__(self, trait_types, **kwargs):
        """
        Construct a Union  trait.

                This trait allows values that are allowed by at least one of the
                specified trait types. A Union traitlet cannot have metadata on
                its own, besides the metadata of the listed types.

                Parameters
                ----------
                trait_types : sequence
                    The list of trait types of length at least 1.

                Notes
                -----
                Union([Float(), Bool(), Int()]) attempts to validate the provided values
                with the validation function of Float, then Bool, and finally Int.
        
        """
    def default(self, obj=None):
        """
         In the case of an element trait, the name is None

        """
    def __or__(self, other):
        """
        -----------------------------------------------------------------------------
         Basic TraitTypes implementations/subclasses
        -----------------------------------------------------------------------------



        """
def Any(TraitType):
    """
    A trait which allows any value.
    """
def _validate_bounds(trait, obj, value):
    """

        Validate that a number to be applied to a trait is between bounds.

        If value is not between min_bound and max_bound, this raises a
        TraitError with an error message appropriate for this trait.
    
    """
def Int(TraitType):
    """
    An int trait.
    """
    def __init__(self, default_value=Undefined, allow_none=False, **kwargs):
        """
        'min'
        """
    def validate(self, obj, value):
        """
        'None'
        """
def CInt(Int):
    """
    A casting version of the int trait.
    """
    def validate(self, obj, value):
        """
        A float trait.
        """
    def __init__(self, default_value=Undefined, allow_none=False, **kwargs):
        """
        'min'
        """
    def validate(self, obj, value):
        """
        'None'
        """
def CFloat(Float):
    """
    A casting version of the float trait.
    """
    def validate(self, obj, value):
        """
        A trait for complex numbers.
        """
    def validate(self, obj, value):
        """
        'None'
        """
def CComplex(Complex):
    """
    A casting version of the complex number trait.
    """
    def validate (self, obj, value):
        """
         We should always be explicit about whether we're using bytes or unicode, both
         for Python 3 conversion and for reliable unicode behaviour on Python 2. So
         we don't have a Str type.

        """
def Bytes(TraitType):
    """
    A trait for byte strings.
    """
    def validate(self, obj, value):
        """
        None
        """
def CBytes(Bytes):
    """
    A casting version of the byte string trait.
    """
    def validate(self, obj, value):
        """
        A trait for unicode strings.
        """
    def validate(self, obj, value):
        """
        'ascii'
        """
    def from_string(self, s):
        """
        'None'
        """
def CUnicode(Unicode):
    """
    A casting version of the unicode trait.
    """
    def validate(self, obj, value):
        """
        A string holding a valid object name in this version of Python.

            This does not check that the name exists in any scope.
        """
    def validate(self, obj, value):
        """
        'None'
        """
def DottedObjectName(ObjectName):
    """
    A string holding a valid dotted object name in Python, such as A.b3._c
    """
    def validate(self, obj, value):
        """
        '.'
        """
def Bool(TraitType):
    """
    A boolean (True, False) trait.
    """
    def validate(self, obj, value):
        """
        'None'
        """
def CBool(Bool):
    """
    A casting version of the boolean trait.
    """
    def validate(self, obj, value):
        """
        An enum whose value must be in a given sequence.
        """
    def __init__(self, values, default_value=Undefined, **kwargs):
        """
        'allow_none'
        """
    def validate(self, obj, value):
        """
         Returns a description of the trait choices (not none).
        """
    def _info(self, as_rst=False):
        """
         Returns a description of the trait.
        """
    def info(self):
        """
        An enum of strings where the case should be ignored.
        """
    def __init__(self, values, default_value=Undefined, **kwargs):
        """
         Returns a description of the trait.
        """
    def info(self):
        """
        An case-ignoring enum matching choices by unique prefixes/substrings.
        """
2021-03-02 20:53:22,312 : INFO : tokenize_signature : --> do i ever get here?
    def __init__(self, values, default_value=Undefined,
                 case_sensitive=False, substring_matching=False, **kwargs):
        """
         Returns a description of the trait.
        """
    def info(self):
        """
        An instance of a container (list, set, etc.)

            To be subclassed by overriding klass.
    
        """
    def __init__(self, trait=None, default_value=None, **kwargs):
        """
        Create a container trait type from a list, set, or tuple.

                The default value is created by doing ``List(default_value)``,
                which creates a copy of the ``default_value``.

                ``trait`` can be specified, which restricts the type of elements
                in the container to that TraitType.

                If only one arg is given and it is not a Trait, it is taken as
                ``default_value``:

                ``c = List([1, 2, 3])``

                Parameters
                ----------
                trait : TraitType [ optional ]
                    the type for restricting the contents of the Container.  If unspecified,
                    types are not checked.
                default_value : SequenceType [ optional ]
                    The default value for the Trait.  Must be list/tuple/set, and
                    will be cast to the container type.
                allow_none : bool [ default False ]
                    Whether to allow the value to be None
                **kwargs : any
                    further keys for extensions to the Trait (e.g. config)

        
        """
    def validate(self, obj, value):
        """
        Load value from a single string
        """
    def from_string_list(self, s_list):
        """
        Return the value from a list of config strings

                This is where we parse CLI configuration
        
        """
    def item_from_string(self, s):
        """
        Cast a single item from a string

                Evaluated when parsing CLI configuration from a string
        
        """
def List(Container):
    """
    An instance of a Python list.
    """
    def __init__(self, trait=None, default_value=None, minlen=0, maxlen=sys.maxsize, **kwargs):
        """
        Create a List trait type from a list, set, or tuple.

                The default value is created by doing ``list(default_value)``,
                which creates a copy of the ``default_value``.

                ``trait`` can be specified, which restricts the type of elements
                in the container to that TraitType.

                If only one arg is given and it is not a Trait, it is taken as
                ``default_value``:

                ``c = List([1, 2, 3])``

                Parameters
                ----------
                trait : TraitType [ optional ]
                    the type for restricting the contents of the Container.
                    If unspecified, types are not checked.
                default_value : SequenceType [ optional ]
                    The default value for the Trait.  Must be list/tuple/set, and
                    will be cast to the container type.
                minlen : Int [ default 0 ]
                    The minimum length of the input list
                maxlen : Int [ default sys.maxsize ]
                    The maximum length of the input list
        
        """
    def length_error(self, obj, value):
        """
        The '%s' trait of %s instance must be of length %i <= L <= %i, but a value of %s was specified.
        """
    def validate_elements(self, obj, value):
        """
        An instance of a Python set.
        """
2021-03-02 20:53:22,317 : INFO : tokenize_signature : --> do i ever get here?
    def __init__(self, trait=None, default_value=None, minlen=0, maxlen=sys.maxsize,
                 **kwargs):
        """
        Create a Set trait type from a list, set, or tuple.

                The default value is created by doing ``set(default_value)``,
                which creates a copy of the ``default_value``.

                ``trait`` can be specified, which restricts the type of elements
                in the container to that TraitType.

                If only one arg is given and it is not a Trait, it is taken as
                ``default_value``:

                ``c = Set({1, 2, 3})``

                Parameters
                ----------
                trait : TraitType [ optional ]
                    the type for restricting the contents of the Container.
                    If unspecified, types are not checked.
                default_value : SequenceType [ optional ]
                    The default value for the Trait.  Must be list/tuple/set, and
                    will be cast to the container type.
                minlen : Int [ default 0 ]
                    The minimum length of the input list
                maxlen : Int [ default sys.maxsize ]
                    The maximum length of the input list
        
        """
    def default_value_repr(self):
        """
         Ensure default value is sorted for a reproducible build

        """
def Tuple(Container):
    """
    An instance of a Python tuple.
    """
    def __init__(self, *traits, **kwargs):
        """
        Create a tuple from a list, set, or tuple.

                Create a fixed-type tuple with Traits:

                ``t = Tuple(Int(), Str(), CStr())``

                would be length 3, with Int,Str,CStr for each element.

                If only one arg is given and it is not a Trait, it is taken as
                default_value:

                ``t = Tuple((1, 2, 3))``

                Otherwise, ``default_value`` *must* be specified by keyword.

                Parameters
                ----------
                `*traits` : TraitTypes [ optional ]
                    the types for restricting the contents of the Tuple.  If unspecified,
                    types are not checked. If specified, then each positional argument
                    corresponds to an element of the tuple.  Tuples defined with traits
                    are of fixed length.
                default_value : SequenceType [ optional ]
                    The default value for the Tuple.  Must be list/tuple/set, and
                    will be cast to a tuple. If ``traits`` are specified,
                    ``default_value`` must conform to the shape and type they specify.
        
        """
    def validate_elements(self, obj, value):
        """
         nothing to validate

        """
    def class_init(self, cls, name):
        """
        An instance of a Python dict.

            One or more traits can be passed to the constructor
            to validate the keys and/or values of the dict.
            If you need more detailed validation,
            you may use a custom validator method.

            .. versionchanged:: 5.0
                Added key_trait for validating dict keys.

            .. versionchanged:: 5.0
                Deprecated ambiguous ``trait``, ``traits`` args in favor of ``value_trait``, ``per_key_traits``.
    
        """
2021-03-02 20:53:22,320 : INFO : tokenize_signature : --> do i ever get here?
    def __init__(self, value_trait=None, per_key_traits=None, key_trait=None, default_value=Undefined,
                 **kwargs):
        """
        Create a dict trait type from a Python dict.

                The default value is created by doing ``dict(default_value)``,
                which creates a copy of the ``default_value``.

                Parameters
                ----------
                value_trait : TraitType [ optional ]
                    The specified trait type to check and use to restrict the values of
                    the dict. If unspecified, values are not checked.
                per_key_traits : Dictionary of {keys:trait types} [ optional, keyword-only ]
                    A Python dictionary containing the types that are valid for
                    restricting the values of the dict on a per-key basis.
                    Each value in this dict should be a Trait for validating
                key_trait : TraitType [ optional, keyword-only ]
                    The type for restricting the keys of the dict. If
                    unspecified, the types of the keys are not checked.
                default_value : SequenceType [ optional, keyword-only ]
                    The default value for the Dict.  Must be dict, tuple, or None, and
                    will be cast to a dict if not None. If any key or value traits are specified,
                    the `default_value` must conform to the constraints.

                Examples
                --------
                >>> d = Dict(Unicode())
                a dict whose values must be text

                >>> d2 = Dict(per_key_traits={"n": Integer(), "s": Unicode()})
                d2['n'] must be an integer
                d2['s'] must be text

                >>> d3 = Dict(value_trait=Integer(), key_trait=Unicode())
                d3's keys must be text
                d3's values must be integers
        
        """
    def element_error(self, obj, element, validator, side='Values'):
        """
         of the '%s' trait of %s instance must be %s, but a value of %s was specified.
        """
    def validate(self, obj, value):
        """
        'Keys'
        """
    def class_init(self, cls, name):
        """
        Load value from a single string
        """
    def from_string_list(self, s_list):
        """
        Return a dict from a list of config strings.

                This is where we parse CLI configuration.

                Each item should have the form ``"key=value"``.

                item parsing is done in :meth:`.item_from_string`.
        
        """
    def item_from_string(self, s):
        """
        Cast a single-key dict from a string.

                Evaluated when parsing CLI configuration from a string.

                Dicts expect strings of the form key=value.

                Returns a one-key dictionary,
                which will be merged in :meth:`.from_string_list`.
        
        """
def TCPAddress(TraitType):
    """
    A trait for an (ip, port) tuple.

        This allows for both IPv4 IP addresses as well as hostnames.
    
    """
    def validate(self, obj, value):
        """
        'None'
        """
def CRegExp(TraitType):
    """
    A casting compiled regular expression trait.

        Accepts both strings and compiled regular expressions. The resulting
        attribute will be a compiled regular expression.
    """
    def validate(self, obj, value):
        """
        Use a Enum class as model for the data type description.
            Note that if no default-value is provided, the first enum-value is used
            as default-value.

            .. sourcecode:: python

                # -- SINCE: Python 3.4 (or install backport: pip install enum34)
                import enum
                from traitlets import HasTraits, UseEnum

                class Color(enum.Enum):
                    red = 1         # -- IMPLICIT: default_value
                    blue = 2
                    green = 3

                class MyEntity(HasTraits):
                    color = UseEnum(Color, default_value=Color.blue)

                entity = MyEntity(color=Color.red)
                entity.color = Color.green    # USE: Enum-value (preferred)
                entity.color = "green"        # USE: name (as string)
                entity.color = "Color.green"  # USE: scoped-name (as string)
                entity.color = 3              # USE: number (as int)
                assert entity.color is Color.green
    
        """
    def __init__(self, enum_class, default_value=None, **kwargs):
        """
        REQUIRE: enum.Enum, but was: %r
        """
    def select_by_number(self, value, default=Undefined):
        """
        Selects enum-value by using its number-constant.
        """
    def select_by_name(self, value, default=Undefined):
        """
        Selects enum-value by using its name or scoped-name.
        """
    def validate(self, obj, value):
        """
         -- CONVERT: number => enum_value (item)

        """
    def _choices_str(self, as_rst=False):
        """
         Returns a description of the trait choices (not none).
        """
    def _info(self, as_rst=False):
        """
         Returns a description of the trait.
        """
    def info(self):
        """
        A trait which is callable.

            Notes
            -----
            Classes are callable, as are instances
            with a __call__() method.
        """
    def validate(self, obj, value):
        """
        add all trait types to `__all__`

            do in a function to avoid iterating through globals while defining local variables
    
        """
