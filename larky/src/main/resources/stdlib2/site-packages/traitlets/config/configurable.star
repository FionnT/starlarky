def ConfigurableError(Exception):
    """
    -----------------------------------------------------------------------------
     Configurable implementation
    -----------------------------------------------------------------------------


    """
def Configurable(HasTraits):
    """
    'traitlets.config.configurable.Configurable'
    """
    def __init__(self, **kwargs):
        """
        Create a configurable given a config config.

                Parameters
                ----------
                config : Config
                    If this is empty, default values are used. If config is a
                    :class:`Config` instance, it will be used to configure the
                    instance.
                parent : Configurable instance, optional
                    The parent Configurable instance of this object.

                Notes
                -----
                Subclasses of Configurable must call the :meth:`__init__` method of
                :class:`Configurable` *before* doing anything else and using
                :func:`super`::

                    class MyConfigurable(Configurable):
                        def __init__(self, config=None):
                            super(MyConfigurable, self).__init__(config=config)
                            # Then any other code you need to finish initialization.

                This ensures that instances will be configured properly.
        
        """
        def notice_config_override(change):
            """
            Record traits set by both config and kwargs.

                        They will need to be overridden again after loading config.
            
            """
    def section_names(cls):
        """
        return section names as a list
        """
    def _find_my_config(self, cfg):
        """
        extract my config from a global Config object

                will construct a Config object of only the config values that apply to me
                based on my mro(), as well as those of my parent(s) if they exist.

                If I am Bar and my parent is Foo, and their parent is Tim,
                this will return merge following config sections, in this order::

                    [Bar, Foo.Bar, Tim.Foo.Bar]

                With the last item being the highest priority.
        
        """
    def _load_config(self, cfg, section_names=None, traits=None):
        """
        load traits from a Config object
        """
    def _config_changed(self, change):
        """
        Update all the class traits having ``config=True`` in metadata.

                For any class trait with a ``config`` metadata attribute that is
                ``True``, we update the trait with the value of the corresponding
                config entry.
        
        """
    def update_config(self, config):
        """
        Update config and load the new values
        """
    def class_get_help(cls, inst=None):
        """
        Get the help string for this class in ReST format.

                If `inst` is given, it's current trait values will be used in place of
                class defaults.
        
        """
    def class_get_trait_help(cls, trait, inst=None, helptext=None):
        """
        Get the helptext string for a single trait.

                :param inst:
                    If given, it's current trait values will be used in place of
                    the class default.
                :param helptext:
                    If not given, uses the `help` attribute of the current trait.
        
        """
    def class_print_help(cls, inst=None):
        """
        Get the help string for a single trait and print it.
        """
    def _defining_class(cls, trait, classes):
        """
        Get the class that defines a trait

                For reducing redundant help output in config files.
                Returns the current class if:
                - the trait is defined on this class, or
                - the class where it is defined would not be in the config file

                Parameters
                ----------
                trait : Trait
                    The trait to look for
                classes : list
                    The list of other classes to consider for redundancy.
                    Will return `cls` even if it is not defined on `cls`
                    if the defining class is not in `classes`.
        
        """
    def class_config_section(cls, classes=None):
        """
        Get the config section for this class.

                Parameters
                ----------
                classes : list, optional
                    The list of other classes in the config file.
                    Used to reduce redundant information.
        
        """
        def c(s):
            """
            return a commented, wrapped block.
            """
    def class_config_rst_doc(cls):
        """
        Generate rST documentation for this class' config options.

                Excludes traits defined on parent classes.
        
        """
def LoggingConfigurable(Configurable):
    """
    A parent class for Configurables that log.

        Subclasses have a log trait, and the default behavior
        is to get the logger from the currently running Application.
    
    """
    def _log_default(self):
        """
        A configurable that only allows one instance.

            This class is for classes that should only have one instance of itself
            or *any* subclass. To create and retrieve such a class use the
            :meth:`SingletonConfigurable.instance` method.
    
        """
    def _walk_mro(cls):
        """
        Walk the cls.mro() for parent classes that are also singletons

                For use in instance()
        
        """
    def clear_instance(cls):
        """
        unset _instance for this class and singleton parents.
        
        """
    def instance(cls, *args, **kwargs):
        """
        Returns a global instance of this class.

                This method create a new instance if none have previously been created
                and returns a previously created instance is one already exists.

                The arguments and keyword arguments passed to this method are passed
                on to the :meth:`__init__` method of the class upon instantiation.

                Examples
                --------
                Create a singleton class using instance, and retrieve it::

                    >>> from traitlets.config.configurable import SingletonConfigurable
                    >>> class Foo(SingletonConfigurable): pass
                    >>> foo = Foo.instance()
                    >>> foo == Foo.instance()
                    True

                Create a subclass that is retrived using the base class instance::

                    >>> class Bar(SingletonConfigurable): pass
                    >>> class Bam(Bar): pass
                    >>> bam = Bam.instance()
                    >>> bam == Bar.instance()
                    True
        
        """
    def initialized(cls):
        """
        Has an instance been created?
        """
