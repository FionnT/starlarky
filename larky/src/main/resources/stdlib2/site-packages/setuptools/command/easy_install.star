def is_64bit():
    """
    P
    """
def samefile(p1, p2):
    """

        Determine if two paths reference the same file.

        Augments os.path.samefile to work on Windows and
        suppresses errors if the path doesn't exist.
    
    """
    def _to_bytes(s):
        """
        'ascii'
        """
    def _to_bytes(s):
        """
        'utf8'
        """
    def isascii(s):
        """
        'ascii'
        """
def _one_liner(text):
    """
    '\n'
    """
def easy_install(Command):
    """
    Manage a download/build/install process
    """
    def initialize_options(self):
        """
         the --user option seems to be an opt-in one,
         so the default should be False.

        """
    def delete_blockers(self, blockers):
        """
        Deleting %s
        """
    def _render_version():
        """

                Render the Setuptools version and installation details, then exit.
        
        """
    def finalize_options(self):
        """
        'prefix'
        """
    def _fix_install_dir_for_user_site(self):
        """

                Fix the install_dir if "--user" was used.
        
        """
    def _expand_attrs(self, attrs):
        """
        'posix'
        """
    def expand_basedirs(self):
        """
        Calls `os.path.expanduser` on install_base, install_platbase and
                root.
        """
    def expand_dirs(self):
        """
        Calls `os.path.expanduser` on install dirs.
        """
    def run(self, show_deprecation=True):
        """
        WARNING: The easy_install command is deprecated 
        and will be removed in a future version.
        """
    def pseudo_tempname(self):
        """
        Return a pseudo-tempname base in the install directory.
                This code is intentionally naive; if a malicious party can write to
                the target directory you're already in deep doodoo.
        
        """
    def warn_deprecated_options(self):
        """
        Verify that self.install_dir is .pth-capable dir, if needed
        """
    def cant_write_to_target(self):
        """
        '\n'
        """
    def check_pth_processing(self):
        """
        Empirically verify whether .pth files are supported in inst. dir
        """
    def install_egg_scripts(self, dist):
        """
        Write all the scripts for `dist`, unless scripts are excluded
        """
    def add_output(self, path):
        """
        Invalid argument %r: you can't use filenames or URLs 
        with --editable (except via the --find-links option).

        """
    def check_editable(self, spec):
        """
        %r already exists in %s; can't do a checkout there
        """
    def _tmpdir(self):
        """
        u"easy_install-
        """
    def easy_install(self, spec, deps=False):
        """
         It's a url, download it to tmpdir and process

        """
    def install_item(self, spec, download, tmpdir, deps, install_needed=False):
        """
         Installation is also needed if file in tmpdir or is not an egg

        """
    def select_scheme(self, name):
        """
        Sets the install directories by applying the install schemes.
        """
    def process_distribution(self, requirement, dist, deps=True, *info):
        """
        'dependency_links.txt'
        """
    def should_unzip(self, dist):
        """
        'not-zip-safe'
        """
    def maybe_move(self, spec, dist_filename, setup_base):
        """
        %r already exists in %s; build directory %s will not be kept

        """
    def install_wrapper_scripts(self, dist):
        """
        Generate a legacy script wrapper and install it
        """
    def _load_template(dev_path):
        """

                There are a couple of template scripts in the package. This
                function loads one of them and prepares it for use.
        
        """
    def write_script(self, script_name, contents, mode="t", blockers=()):
        """
        Write an executable file to the scripts directory
        """
    def install_eggs(self, spec, dist_filename, tmpdir):
        """
         .egg dirs or files are already built, so just return them

        """
    def egg_distribution(self, egg_path):
        """
        'EGG-INFO'
        """
    def install_egg(self, egg_path, tmpdir):
        """
        Removing 
        """
    def install_exe(self, dist_filename, tmpdir):
        """
         See if it's valid, get data

        """
    def exe_to_egg(self, dist_filename, egg_tmp):
        """
        Extract a bdist_wininst to the directories an egg would use
        """
        def process(src, dst):
            """
            '/'
            """
    def install_wheel(self, wheel_path, tmpdir):
        """
        Removing 
        """
    def installation_report(self, req, dist, what="Installed"):
        """
        Helpful installation message for display to package users
        """
    def report_editable(self, spec, setup_script):
        """
        '\n'
        """
    def run_setup(self, setup_script, setup_base, args):
        """
        'distutils.command.bdist_egg'
        """
    def build_and_install(self, setup_script, setup_base):
        """
        'bdist_egg'
        """
    def _set_fetcher_options(self, base):
        """

                When easy_install is about to run bdist_egg on a source dist, that
                source dist might have 'setup_requires' directives, requiring
                additional fetching. Ensure the fetcher options given to easy_install
                are available to that command as well.
        
        """
    def update_pth(self, dist):
        """
         drop old entries
        """
    def unpack_progress(self, src, dst):
        """
         Progress filter for unpacking

        """
    def unpack_and_compile(self, egg_path, destination):
        """
        '.py'
        """
    def byte_compile(self, to_compile):
        """
         try to make the byte compile messages quieter

        """
    def install_site_py(self):
        """
        Make sure there's a site.py in the target dir, if needed
        """
    def create_home_path(self):
        """
        Create directories under ~.
        """
    def _expand(self, *attrs):
        """
        'install'
        """
def _pythonpath():
    """
    'PYTHONPATH'
    """
def get_site_dirs():
    """

        Return a list of 'site' dirs
    
    """
def expand_paths(inputs):
    """
    Yield sys.path directories that might contain "old-style" packages
    """
def extract_wininst_cfg(dist_filename):
    """
    Extract configuration data from a bdist_wininst .exe

        Returns a configparser.RawConfigParser, or None
    
    """
def get_exe_prefixes(exe_filename):
    """
    Get exe->egg path translations for a given .exe file
    """
def PthDistributions(Environment):
    """
    A .pth file with Distribution paths in it
    """
    def __init__(self, filename, sitedirs=()):
        """
        'rt'
        """
    def save(self):
        """
        Write changed .pth file back to disk
        """
    def _wrap_lines(lines):
        """
        Add `dist` to the distribution map
        """
    def remove(self, dist):
        """
        Remove `dist` from the distribution map
        """
    def make_relative(self, path):
        """
        '/'
        """
def RewritePthDistributions(PthDistributions):
    """

            import sys
            sys.__plen = len(sys.path)
        
    """
def _first_line_re():
    """

        Return a regular expression based on first_line_re suitable for matching
        strings.
    
    """
def auto_chmod(func, arg, exc):
    """
    'nt'
    """
def update_dist_caches(dist_path, fix_zipimporter_caches):
    """

        Fix any globally cached `dist_path` related data

        `dist_path` should be a path of a newly installed egg distribution (zipped
        or unzipped).

        sys.path_importer_cache contains finder objects that have been cached when
        importing data from the original distribution. Any such finders need to be
        cleared since the replacement distribution might be packaged differently,
        e.g. a zipped egg distribution might get replaced with an unzipped egg
        folder or vice versa. Having the old finders cached may then cause Python
        to attempt loading modules from the replacement distribution using an
        incorrect loader.

        zipimport.zipimporter objects are Python loaders charged with importing
        data packaged inside zip archives. If stale loaders referencing the
        original distribution, are left behind, they can fail to load modules from
        the replacement distribution. E.g. if an old zipimport.zipimporter instance
        is used to load data from a new zipped egg archive, it may cause the
        operation to attempt to locate the requested data in the wrong location -
        one indicated by the original distribution's zip archive directory
        information. Such an operation may then fail outright, e.g. report having
        read a 'bad local file header', or even worse, it may fail silently &
        return invalid data.

        zipimport._zip_directory_cache contains cached zip archive directory
        information for all existing zipimport.zipimporter instances and all such
        instances connected to the same archive share the same cached directory
        information.

        If asked, and the underlying Python implementation allows it, we can fix
        all existing zipimport.zipimporter instances instead of having to track
        them down and remove them one by one, by updating their shared cached zip
        archive directory information. This, of course, assumes that the
        replacement distribution is packaged as a zipped egg.

        If not asked to fix existing zipimport.zipimporter instances, we still do
        our best to clear any remaining zipimport.zipimporter related cached data
        that might somehow later get used when attempting to load data from the new
        distribution and thus cause such load operations to fail. Note that when
        tracking down such remaining stale data, we can not catch every conceivable
        usage from here, and we clear only those that we know of and have found to
        cause problems if left alive. Any remaining caches should be updated by
        whomever is in charge of maintaining them, i.e. they should be ready to
        handle us replacing their zip archives with new distributions at runtime.

    
    """
def _collect_zipimporter_cache_entries(normalized_path, cache):
    """

        Return zipimporter cache entry keys related to a given normalized path.

        Alternative path spellings (e.g. those using different character case or
        those using alternative path separators) related to the same path are
        included. Any sub-path entries are included as well, i.e. those
        corresponding to zip archives embedded in other zip archives.

    
    """
def _update_zipimporter_cache(normalized_path, cache, updater=None):
    """

        Update zipimporter cache data for a given normalized path.

        Any sub-path entries are processed as well, i.e. those corresponding to zip
        archives embedded in other zip archives.

        Given updater is a callable taking a cache entry key and the original entry
        (after already removing the entry from the cache), and expected to update
        the entry and possibly return a new one to be inserted in its place.
        Returning None indicates that the entry should not be replaced with a new
        one. If no updater is given, the cache entries are simply removed without
        any additional processing, the same as if the updater simply returned None.

    
    """
def _uncache(normalized_path, cache):
    """
     PyPy Python implementation does not allow directly writing to the
     zipimport._zip_directory_cache and so prevents us from attempting to correct
     its content. The best we can do there is clear the problematic cache content
     and have PyPy repopulate it as needed. The downside is that if there are any
     stale zipimport.zipimporter instances laying around, attempting to use them
     will fail due to not having its zip archive directory information available
     instead of being automatically corrected to use the new correct zip archive
     directory information.

    """
    def _replace_zip_directory_cache_data(normalized_path):
        """
         N.B. In theory, we could load the zip directory information just
         once for all updated path spellings, and then copy it locally and
         update its contained path strings to contain the correct
         spelling, but that seems like a way too invasive move (this cache
         structure is not officially documented anywhere and could in
         theory change with new Python releases) for no significant
         benefit.

        """
def is_python(text, filename='<string>'):
    """
    Is this string a valid Python script?
    """
def is_sh(executable):
    """
    Determine if the specified executable is a .sh (contains a #! line)
    """
def nt_quote_arg(arg):
    """
    Quote a command line argument according to Windows parsing rules
    """
def is_python_script(script_text, filename):
    """
    Is this text, as a whole, a Python script? (as opposed to shell/bat/etc.
    
    """
    def _chmod(*args):
        """
        changing mode of %s to %o
        """
def CommandSpec(list):
    """

        A command spec for a #! header, specified as a list of arguments akin to
        those passed to Popen.
    
    """
    def best(cls):
        """

                Choose the best CommandSpec class based on environmental conditions.
        
        """
    def _sys_executable(cls):
        """
        '__PYVENV_LAUNCHER__'
        """
    def from_param(cls, param):
        """

                Construct a CommandSpec from a parameter to build_scripts, which may
                be None.
        
        """
    def from_environment(cls):
        """

                Construct a command spec from a simple string representing a command
                line parseable by shlex.split.
        
        """
    def install_options(self, script_text):
        """
        '-x'
        """
    def _extract_options(orig_script):
        """

                Extract any options from the first line of the script.
        
        """
    def as_header(self):
        """
        '"\''
        """
    def _render(items):
        """
        '#!'
        """
def WindowsCommandSpec(CommandSpec):
    """

        Encapsulates behavior around writing entry point scripts for console and
        gui apps.
    
    """
    def get_script_args(cls, dist, executable=None, wininst=False):
        """
         for backward compatibility

        """
    def get_script_header(cls, script_text, executable=None, wininst=False):
        """
         for backward compatibility

        """
    def get_args(cls, dist, header=None):
        """

                Yield write_script() argument tuples for a distribution's
                console_scripts and gui_scripts entry points.
        
        """
    def _ensure_safe_name(name):
        """

                Prevent paths in *_scripts entry point names.
        
        """
    def get_writer(cls, force_windows):
        """
         for backward compatibility

        """
    def best(cls):
        """

                Select the best ScriptWriter for this environment.
        
        """
    def _get_script_args(cls, type_, name, header, script_text):
        """
         Simply write the stub with no extension.

        """
    def get_header(cls, script_text="", executable=None):
        """
        Create a #! line, getting options (if any) from script_text
        """
def WindowsScriptWriter(ScriptWriter):
    """
     for backward compatibility

    """
    def best(cls):
        """

                Select the best ScriptWriter suitable for Windows
        
        """
    def _get_script_args(cls, type_, name, header, script_text):
        """
        For Windows, add a .py extension
        """
    def _adjust_header(cls, type_, orig_header):
        """

                Make sure 'pythonw' is used for gui and and 'python' is used for
                console (regardless of what sys.executable is).
        
        """
    def _use_header(new_header):
        """

                Should _adjust_header use the replaced header?

                On non-windows systems, always use. On
                Windows systems, only use the replaced header if it resolves
                to an executable on the system.
        
        """
def WindowsExecutableLauncherWriter(WindowsScriptWriter):
    """

            For Windows, add a .py extension and an .exe launcher
        
    """
def get_win_launcher(type):
    """

        Load the Windows launcher (executable) suitable for launching a script.

        `type` should be either 'cli' or 'gui'

        Returns the executable as a byte string.
    
    """
def load_launcher_manifest(name):
    """
    'launcher manifest.xml'
    """
def rmtree(path, ignore_errors=False, onerror=auto_chmod):
    """
     This function is called when setuptools*.egg is run using /bin/sh

    """
def main(argv=None, **kw):
    """

    """
        def _show_help(self, *args, **kw):
            """
            '-q'
            """
def _patch_usage():
    """

            usage: %(script)s [options] requirement_or_url ...
               or: %(script)s --help
        
    """
    def gen_usage(script_name):
        """

            Warning for EasyInstall deprecations, bypassing suppression.
    
        """
