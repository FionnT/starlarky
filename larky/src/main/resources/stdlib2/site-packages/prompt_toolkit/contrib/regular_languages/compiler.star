def _CompiledGrammar:
    """

        Compiles a grammar. This will take the parse tree of a regular expression
        and compile the grammar.

        :param root_node: :class~`.regex_parser.Node` instance.
        :param escape_funcs: `dict` mapping variable names to escape callables.
        :param unescape_funcs: `dict` mapping variable names to unescape callables.
    
    """
2021-03-02 20:51:41,670 : INFO : tokenize_signature : --> do i ever get here?
2021-03-02 20:51:41,670 : INFO : tokenize_signature : --> do i ever get here?
2021-03-02 20:51:41,670 : INFO : tokenize_signature : --> do i ever get here?
2021-03-02 20:51:41,670 : INFO : tokenize_signature : --> do i ever get here?
2021-03-02 20:51:41,670 : INFO : tokenize_signature : --> do i ever get here?
    def __init__(
        self,
        root_node: Node,
        escape_funcs: Optional[EscapeFuncDict] = None,
        unescape_funcs: Optional[EscapeFuncDict] = None,
    ) -> None:
        """
        : Dictionary that will map the regex names to Node instances.

        """
        def create_group_func(node: Variable) -> str:
            """
            n%s
            """
    def escape(self, varname: str, value: str) -> str:
        """

                Escape `value` to fit in the place of this variable into the grammar.
        
        """
    def unescape(self, varname: str, value: str) -> str:
        """

                Unescape `value`.
        
        """
2021-03-02 20:51:41,672 : INFO : tokenize_signature : --> do i ever get here?
2021-03-02 20:51:41,672 : INFO : tokenize_signature : --> do i ever get here?
    def _transform(
        cls, root_node: Node, create_group_func: Callable[[Variable], str]
    ) -> str:
        """

                Turn a :class:`Node` object into a regular expression.

                :param root_node: The :class:`Node` instance for which we generate the grammar.
                :param create_group_func: A callable which takes a `Node` and returns the next
                    free name for this node.
        
        """
        def transform(node: Node) -> str:
            """
             Turn `AnyNode` into an OR.

            """
2021-03-02 20:51:41,674 : INFO : tokenize_signature : --> do i ever get here?
2021-03-02 20:51:41,674 : INFO : tokenize_signature : --> do i ever get here?
    def _transform_prefix(
        cls, root_node: Node, create_group_func: Callable[[Variable], str]
    ) -> Iterable[str]:
        """

                Yield all the regular expressions matching a prefix of the grammar
                defined by the `Node` instance.

                For each `Variable`, one regex pattern will be generated, with this
                named group at the end. This is required because a regex engine will
                terminate once a match is found. For autocompletion however, we need
                the matches for all possible paths, so that we can provide completions
                for each `Variable`.

                - So, in the case of an `Any` (`A|B|C)', we generate a pattern for each
                  clause. This is one for `A`, one for `B` and one for `C`. Unless some
                  groups don't contain a `Variable`, then these can be merged together.
                - In the case of a `NodeSequence` (`ABC`), we generate a pattern for
                  each prefix that ends with a variable, and one pattern for the whole
                  sequence. So, that's one for `A`, one for `AB` and one for `ABC`.

                :param root_node: The :class:`Node` instance for which we generate the grammar.
                :param create_group_func: A callable which takes a `Node` and returns the next
                    free name for this node.
        
        """
        def contains_variable(node: Node) -> bool:
            """
             Generate separate pattern for all terms that contain variables
             within this OR. Terms that don't contain a variable can be merged
             together in one pattern.

            """
    def match(self, string: str) -> Optional["Match"]:
        """

                Match the string with the grammar.
                Returns a :class:`Match` instance or `None` when the input doesn't match the grammar.

                :param string: The input string.
        
        """
    def match_prefix(self, string: str) -> Optional["Match"]:
        """

                Do a partial match of the string with the grammar. The returned
                :class:`Match` instance can contain multiple representations of the
                match. This will never return `None`. If it doesn't match at all, the "trailing input"
                part will capture all of the input.

                :param string: The input string.
        
        """
def Match:
    """

        :param string: The input string.
        :param re_matches: List of (compiled_re_pattern, re_match) tuples.
        :param group_names_to_nodes: Dictionary mapping all the re group names to the matching Node instances.
    
    """
2021-03-02 20:51:41,677 : INFO : tokenize_signature : --> do i ever get here?
2021-03-02 20:51:41,678 : INFO : tokenize_signature : --> do i ever get here?
2021-03-02 20:51:41,678 : INFO : tokenize_signature : --> do i ever get here?
2021-03-02 20:51:41,678 : INFO : tokenize_signature : --> do i ever get here?
2021-03-02 20:51:41,678 : INFO : tokenize_signature : --> do i ever get here?
2021-03-02 20:51:41,678 : INFO : tokenize_signature : --> do i ever get here?
    def __init__(
        self,
        string: str,
        re_matches: List[Tuple[Pattern[str], RegexMatch[str]]],
        group_names_to_nodes: Dict[str, str],
        unescape_funcs: Dict[str, Callable[[str], str]],
    ):
        """

                Return a list of (varname, reg) tuples.
        
        """
        def get_tuples() -> Iterable[Tuple[str, Tuple[int, int]]]:
            """

                    Returns list of (Node, string_value) tuples.
        
            """
        def is_none(sl: Tuple[int, int]) -> bool:
            """
            Variables
            """
    def trailing_input(self) -> Optional["MatchVariable"]:
        """

                Get the `MatchVariable` instance, representing trailing input, if there is any.
                "Trailing input" is input at the end that does not match the grammar anymore, but
                when this is removed from the end of the input, the input would be a valid string.
        
        """
    def end_nodes(self) -> Iterable["MatchVariable"]:
        """

                Yields `MatchVariable` instances for all the nodes having their end
                position at the end of the input string.
        
        """
def Variables:
    """
    : List of (varname, value, slice) tuples.

    """
    def __repr__(self) -> str:
        """
        %s(%s)
        """
    def get(self, key: str, default: Optional[str] = None) -> Optional[str]:
        """
        MatchVariable
        """
def MatchVariable:
    """

        Represents a match of a variable in the grammar.

        :param varname: (string) Name of the variable.
        :param value: (string) Value of this variable.
        :param slice: (start, stop) tuple, indicating the position of this variable
                      in the input string.
    
    """
    def __init__(self, varname: str, value: str, slice: Tuple[int, int]) -> None:
        """
        %s(%r, %r)
        """
2021-03-02 20:51:41,682 : INFO : tokenize_signature : --> do i ever get here?
2021-03-02 20:51:41,682 : INFO : tokenize_signature : --> do i ever get here?
2021-03-02 20:51:41,682 : INFO : tokenize_signature : --> do i ever get here?
2021-03-02 20:51:41,682 : INFO : tokenize_signature : --> do i ever get here?
def compile(
    expression: str,
    escape_funcs: Optional[EscapeFuncDict] = None,
    unescape_funcs: Optional[EscapeFuncDict] = None,
) -> _CompiledGrammar:
    """

        Compile grammar (given as regex string), returning a `CompiledGrammar`
        instance.
    
    """
2021-03-02 20:51:41,683 : INFO : tokenize_signature : --> do i ever get here?
2021-03-02 20:51:41,683 : INFO : tokenize_signature : --> do i ever get here?
2021-03-02 20:51:41,683 : INFO : tokenize_signature : --> do i ever get here?
2021-03-02 20:51:41,683 : INFO : tokenize_signature : --> do i ever get here?
def _compile_from_parse_tree(
    root_node: Node,
    escape_funcs: Optional[EscapeFuncDict] = None,
    unescape_funcs: Optional[EscapeFuncDict] = None,
) -> _CompiledGrammar:
    """

        Compile grammar (given as parse tree), returning a `CompiledGrammar`
        instance.
    
    """
