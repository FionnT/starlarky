def Filter(metadef=ABCMeta):
    """

        Base class for any filter to activate/deactivate a feature, depending on a
        condition.

        The return value of ``__call__`` will tell if the feature should be active.
    
    """
    def __call__(self) -> bool:
        """

                The actual call to evaluate the filter.
        
        """
    def __and__(self, other: "Filter") -> "Filter":
        """

                Chaining of filters using the & operator.
        
        """
    def __or__(self, other: "Filter") -> "Filter":
        """

                Chaining of filters using the | operator.
        
        """
    def __invert__(self) -> "Filter":
        """

                Inverting of filters using the ~ operator.
        
        """
    def __bool__(self) -> None:
        """

                By purpose, we don't allow bool(...) operations directly on a filter,
                because the meaning is ambiguous.

                Executing a filter has to be done always by calling it. Providing
                defaults for `None` values should be done through an `is None` check
                instead of for instance ``filter1 or Always()``.
        
        """
def _AndCache(Dict[Tuple[Filter, Filter], "_AndList"]):
    """

        Cache for And operation between filters.
        (Filter classes are stateless, so we can reuse them.)

        Note: This could be a memory leak if we keep creating filters at runtime.
              If that is True, the filters should be weakreffed (not the tuple of
              filters), and tuples should be removed when one of these filters is
              removed. In practise however, there is a finite amount of filters.
    
    """
    def __missing__(self, filters: Tuple[Filter, Filter]) -> Filter:
        """
        Expecting filter, got %r
        """
def _OrCache(Dict[Tuple[Filter, Filter], "_OrList"]):
    """
     Cache for Or operation between filters. 
    """
    def __missing__(self, filters: Tuple[Filter, Filter]) -> Filter:
        """
        Expecting filter, got %r
        """
def _InvertCache(Dict[Filter, "_Invert"]):
    """
     Cache for inversion operator. 
    """
    def __missing__(self, filter: Filter) -> Filter:
        """

            Result of &-operation between several filters.
    
        """
    def __init__(self, filters: Iterable[Filter]) -> None:
        """
         Turn nested _AndLists into one.
        """
    def __call__(self) -> bool:
        """
        &
        """
def _OrList(Filter):
    """

        Result of |-operation between several filters.
    
    """
    def __init__(self, filters: Iterable[Filter]) -> None:
        """
         Turn nested _OrLists into one.
        """
    def __call__(self) -> bool:
        """
        |
        """
def _Invert(Filter):
    """

        Negation of another filter.
    
    """
    def __init__(self, filter: Filter) -> None:
        """
        ~%r
        """
def Always(Filter):
    """

        Always enable feature.
    
    """
    def __call__(self) -> bool:
        """
        Never
        """
def Never(Filter):
    """

        Never enable feature.
    
    """
    def __call__(self) -> bool:
        """

            Turn any callable into a Filter. The callable is supposed to not take any
            arguments.

            This can be used as a decorator::

                @Condition
                def feature_is_active():  # `feature_is_active` becomes a Filter.
                    return True

            :param func: Callable which takes no inputs and returns a boolean.
    
        """
    def __init__(self, func: Callable[[], bool]):
        """
        Condition(%r)
        """
