2021-03-02 20:51:50,467 : INFO : tokenize_signature : --> do i ever get here?
2021-03-02 20:51:50,467 : INFO : tokenize_signature : --> do i ever get here?
2021-03-02 20:51:50,467 : INFO : tokenize_signature : --> do i ever get here?
2021-03-02 20:51:50,467 : INFO : tokenize_signature : --> do i ever get here?
def _split_multiline_prompt(
    get_prompt_text: _StyleAndTextTuplesCallable,
) -> Tuple[
    Callable[[], bool], _StyleAndTextTuplesCallable, _StyleAndTextTuplesCallable
]:
    """

        Take a `get_prompt_text` function and return three new functions instead.
        One that tells whether this prompt consists of multiple lines; one that
        returns the fragments to be shown on the lines above the input; and another
        one with the fragments to be shown at the first line of the input.
    
    """
    def has_before_fragments() -> bool:
        """
        \n
        """
    def before() -> StyleAndTextTuples:
        """
        \n
        """
    def first_input_line() -> StyleAndTextTuples:
        """
        \n
        """
def _RPrompt(Window):
    """

        The prompt that is displayed on the right side of the Window.
    
    """
    def __init__(self, text: AnyFormattedText) -> None:
        """
        class:rprompt
        """
def CompleteStyle(str, Enum):
    """

        How to display autocompletions for the prompt.
    
    """
def PromptSession(Generic[_T]):
    """

        PromptSession for a prompt application, which can be used as a GNU Readline
        replacement.

        This is a wrapper around a lot of ``prompt_toolkit`` functionality and can
        be a replacement for `raw_input`.

        All parameters that expect "formatted text" can take either just plain text
        (a unicode object), a list of ``(style_str, text)`` tuples or an HTML object.

        Example usage::

            s = PromptSession(message='>')
            text = s.prompt()

        :param message: Plain text or formatted text to be shown before the prompt.
            This can also be a callable that returns formatted text.
        :param multiline: `bool` or :class:`~prompt_toolkit.filters.Filter`.
            When True, prefer a layout that is more adapted for multiline input.
            Text after newlines is automatically indented, and search/arg input is
            shown below the input, instead of replacing the prompt.
        :param wrap_lines: `bool` or :class:`~prompt_toolkit.filters.Filter`.
            When True (the default), automatically wrap long lines instead of
            scrolling horizontally.
        :param is_password: Show asterisks instead of the actual typed characters.
        :param editing_mode: ``EditingMode.VI`` or ``EditingMode.EMACS``.
        :param vi_mode: `bool`, if True, Identical to ``editing_mode=EditingMode.VI``.
        :param complete_while_typing: `bool` or
            :class:`~prompt_toolkit.filters.Filter`. Enable autocompletion while
            typing.
        :param validate_while_typing: `bool` or
            :class:`~prompt_toolkit.filters.Filter`. Enable input validation while
            typing.
        :param enable_history_search: `bool` or
            :class:`~prompt_toolkit.filters.Filter`. Enable up-arrow parting
            string matching.
        :param search_ignore_case:
            :class:`~prompt_toolkit.filters.Filter`. Search case insensitive.
        :param lexer: :class:`~prompt_toolkit.lexers.Lexer` to be used for the
            syntax highlighting.
        :param validator: :class:`~prompt_toolkit.validation.Validator` instance
            for input validation.
        :param completer: :class:`~prompt_toolkit.completion.Completer` instance
            for input completion.
        :param complete_in_thread: `bool` or
            :class:`~prompt_toolkit.filters.Filter`. Run the completer code in a
            background thread in order to avoid blocking the user interface.
            For ``CompleteStyle.READLINE_LIKE``, this setting has no effect. There
            we always run the completions in the main thread.
        :param reserve_space_for_menu: Space to be reserved for displaying the menu.
            (0 means that no space needs to be reserved.)
        :param auto_suggest: :class:`~prompt_toolkit.auto_suggest.AutoSuggest`
            instance for input suggestions.
        :param style: :class:`.Style` instance for the color scheme.
        :param include_default_pygments_style: `bool` or
            :class:`~prompt_toolkit.filters.Filter`. Tell whether the default
            styling for Pygments lexers has to be included. By default, this is
            true, but it is recommended to be disabled if another Pygments style is
            passed as the `style` argument, otherwise, two Pygments styles will be
            merged.
        :param style_transformation:
            :class:`~prompt_toolkit.style.StyleTransformation` instance.
        :param swap_light_and_dark_colors: `bool` or
            :class:`~prompt_toolkit.filters.Filter`. When enabled, apply
            :class:`~prompt_toolkit.style.SwapLightAndDarkStyleTransformation`.
            This is useful for switching between dark and light terminal
            backgrounds.
        :param enable_system_prompt: `bool` or
            :class:`~prompt_toolkit.filters.Filter`. Pressing Meta+'!' will show
            a system prompt.
        :param enable_suspend: `bool` or :class:`~prompt_toolkit.filters.Filter`.
            Enable Control-Z style suspension.
        :param enable_open_in_editor: `bool` or
            :class:`~prompt_toolkit.filters.Filter`. Pressing 'v' in Vi mode or
            C-X C-E in emacs mode will open an external editor.
        :param history: :class:`~prompt_toolkit.history.History` instance.
        :param clipboard: :class:`~prompt_toolkit.clipboard.Clipboard` instance.
            (e.g. :class:`~prompt_toolkit.clipboard.InMemoryClipboard`)
        :param rprompt: Text or formatted text to be displayed on the right side.
            This can also be a callable that returns (formatted) text.
        :param bottom_toolbar: Formatted text or callable which is supposed to
            return formatted text.
        :param prompt_continuation: Text that needs to be displayed for a multiline
            prompt continuation. This can either be formatted text or a callable
            that takes a `prompt_width`, `line_number` and `wrap_count` as input
            and returns formatted text. When this is `None` (the default), then
            `prompt_width` spaces will be used.
        :param complete_style: ``CompleteStyle.COLUMN``,
            ``CompleteStyle.MULTI_COLUMN`` or ``CompleteStyle.READLINE_LIKE``.
        :param mouse_support: `bool` or :class:`~prompt_toolkit.filters.Filter`
            to enable mouse support.
        :param placeholder: Text to be displayed when no input has been given
            yet. Unlike the `default` parameter, this won't be returned as part of
            the output ever. This can be formatted text or a callable that returns
            formatted text.
        :param refresh_interval: (number; in seconds) When given, refresh the UI
            every so many seconds.
        :param input: `Input` object. (Note that the preferred way to change the
            input/output is by creating an `AppSession`.)
        :param output: `Output` object.
    
    """
2021-03-02 20:51:50,470 : INFO : tokenize_signature : --> do i ever get here?
2021-03-02 20:51:50,470 : INFO : tokenize_signature : --> do i ever get here?
2021-03-02 20:51:50,470 : INFO : tokenize_signature : --> do i ever get here?
2021-03-02 20:51:50,470 : INFO : tokenize_signature : --> do i ever get here?
2021-03-02 20:51:50,470 : INFO : tokenize_signature : --> do i ever get here?
2021-03-02 20:51:50,471 : INFO : tokenize_signature : --> do i ever get here?
2021-03-02 20:51:50,471 : INFO : tokenize_signature : --> do i ever get here?
2021-03-02 20:51:50,471 : INFO : tokenize_signature : --> do i ever get here?
2021-03-02 20:51:50,471 : INFO : tokenize_signature : --> do i ever get here?
2021-03-02 20:51:50,471 : INFO : tokenize_signature : --> do i ever get here?
2021-03-02 20:51:50,471 : INFO : tokenize_signature : --> do i ever get here?
2021-03-02 20:51:50,471 : INFO : tokenize_signature : --> do i ever get here?
2021-03-02 20:51:50,471 : INFO : tokenize_signature : --> do i ever get here?
2021-03-02 20:51:50,472 : INFO : tokenize_signature : --> do i ever get here?
2021-03-02 20:51:50,472 : INFO : tokenize_signature : --> do i ever get here?
2021-03-02 20:51:50,472 : INFO : tokenize_signature : --> do i ever get here?
2021-03-02 20:51:50,472 : INFO : tokenize_signature : --> do i ever get here?
2021-03-02 20:51:50,472 : INFO : tokenize_signature : --> do i ever get here?
2021-03-02 20:51:50,472 : INFO : tokenize_signature : --> do i ever get here?
2021-03-02 20:51:50,473 : INFO : tokenize_signature : --> do i ever get here?
2021-03-02 20:51:50,473 : INFO : tokenize_signature : --> do i ever get here?
2021-03-02 20:51:50,473 : INFO : tokenize_signature : --> do i ever get here?
2021-03-02 20:51:50,473 : INFO : tokenize_signature : --> do i ever get here?
2021-03-02 20:51:50,473 : INFO : tokenize_signature : --> do i ever get here?
2021-03-02 20:51:50,473 : INFO : tokenize_signature : --> do i ever get here?
2021-03-02 20:51:50,473 : INFO : tokenize_signature : --> do i ever get here?
2021-03-02 20:51:50,473 : INFO : tokenize_signature : --> do i ever get here?
2021-03-02 20:51:50,473 : INFO : tokenize_signature : --> do i ever get here?
2021-03-02 20:51:50,474 : INFO : tokenize_signature : --> do i ever get here?
2021-03-02 20:51:50,474 : INFO : tokenize_signature : --> do i ever get here?
2021-03-02 20:51:50,474 : INFO : tokenize_signature : --> do i ever get here?
2021-03-02 20:51:50,474 : INFO : tokenize_signature : --> do i ever get here?
2021-03-02 20:51:50,474 : INFO : tokenize_signature : --> do i ever get here?
2021-03-02 20:51:50,474 : INFO : tokenize_signature : --> do i ever get here?
2021-03-02 20:51:50,474 : INFO : tokenize_signature : --> do i ever get here?
2021-03-02 20:51:50,474 : INFO : tokenize_signature : --> do i ever get here?
2021-03-02 20:51:50,474 : INFO : tokenize_signature : --> do i ever get here?
2021-03-02 20:51:50,474 : INFO : tokenize_signature : --> do i ever get here?
2021-03-02 20:51:50,475 : INFO : tokenize_signature : --> do i ever get here?
2021-03-02 20:51:50,475 : INFO : tokenize_signature : --> do i ever get here?
2021-03-02 20:51:50,475 : INFO : tokenize_signature : --> do i ever get here?
2021-03-02 20:51:50,475 : INFO : tokenize_signature : --> do i ever get here?
2021-03-02 20:51:50,475 : INFO : tokenize_signature : --> do i ever get here?
    def __init__(
        self,
        message: AnyFormattedText = "",
        *,
        multiline: FilterOrBool = False,
        wrap_lines: FilterOrBool = True,
        is_password: FilterOrBool = False,
        vi_mode: bool = False,
        editing_mode: EditingMode = EditingMode.EMACS,
        complete_while_typing: FilterOrBool = True,
        validate_while_typing: FilterOrBool = True,
        enable_history_search: FilterOrBool = False,
        search_ignore_case: FilterOrBool = False,
        lexer: Optional[Lexer] = None,
        enable_system_prompt: FilterOrBool = False,
        enable_suspend: FilterOrBool = False,
        enable_open_in_editor: FilterOrBool = False,
        validator: Optional[Validator] = None,
        completer: Optional[Completer] = None,
        complete_in_thread: bool = False,
        reserve_space_for_menu: int = 8,
        complete_style: CompleteStyle = CompleteStyle.COLUMN,
        auto_suggest: Optional[AutoSuggest] = None,
        style: Optional[BaseStyle] = None,
        style_transformation: Optional[StyleTransformation] = None,
        swap_light_and_dark_colors: FilterOrBool = False,
        color_depth: Optional[ColorDepth] = None,
        include_default_pygments_style: FilterOrBool = True,
        history: Optional[History] = None,
        clipboard: Optional[Clipboard] = None,
        prompt_continuation: Optional[PromptContinuationText] = None,
        rprompt: AnyFormattedText = None,
        bottom_toolbar: AnyFormattedText = None,
        mouse_support: FilterOrBool = False,
        input_processors: Optional[List[Processor]] = None,
        placeholder: Optional[AnyFormattedText] = None,
        key_bindings: Optional[KeyBindingsBase] = None,
        erase_when_done: bool = False,
        tempfile_suffix: Optional[Union[str, Callable[[], str]]] = ".txt",
        tempfile: Optional[Union[str, Callable[[], str]]] = None,
        refresh_interval: float = 0,
        input: Optional[Input] = None,
        output: Optional[Output] = None,
    ) -> None:
        """
         Ensure backwards-compatibility, when `vi_mode` is passed.

        """
    def _dyncond(self, attr_name: str) -> Condition:
        """

                Dynamically take this setting from this 'PromptSession' class.
                `attr_name` represents an attribute name of this class. Its value
                can either be a boolean or a `Filter`.

                This returns something that can be used as either a `Filter`
                or `Filter`.
        
        """
        def dynamic() -> bool:
            """

                    Create and return the default input buffer.
        
            """
        def accept(buff: Buffer) -> bool:
            """
            Accept the content of the default buffer. This is called when
                        the validation succeeds.
            """
    def _create_search_buffer(self) -> Buffer:
        """

                Create `Layout` for this prompt.
        
        """
        def display_placeholder() -> bool:
            """

            """
        def get_search_buffer_control() -> SearchBufferControl:
            """
             Return the UIControl to be focused when searching start. 
            """
        def multi_column_complete_style() -> bool:
            """
             Build the layout.

            """
2021-03-02 20:51:50,480 : INFO : tokenize_signature : --> do i ever get here?
2021-03-02 20:51:50,481 : INFO : tokenize_signature : --> do i ever get here?
    def _create_application(
        self, editing_mode: EditingMode, erase_when_done: bool
    ) -> Application[_T]:
        """

                Create the `Application` object.
        
        """
    def _create_prompt_bindings(self) -> KeyBindings:
        """

                Create the KeyBindings for a prompt application.
        
        """
        def do_accept() -> bool:
            """
            enter
            """
        def _accept_input(event: E) -> None:
            """
             Accept input when enter has been pressed. 
            """
        def readline_complete_style() -> bool:
            """
            tab
            """
        def _complete_like_readline(event: E) -> None:
            """
             Display completions (like Readline). 
            """
        def _keyboard_interrupt(event: E) -> None:
            """
             Abort when Control-C has been pressed. 
            """
        def ctrl_d_condition() -> bool:
            """
            Ctrl-D binding is only active when the default buffer is selected
                        and empty.
            """
        def _eof(event: E) -> None:
            """
             Exit when Control-D has been pressed. 
            """
        def enable_suspend() -> bool:
            """
            c-z
            """
        def _suspend(event: E) -> None:
            """

                        Suspend process to background.
            
            """
2021-03-02 20:51:50,483 : INFO : tokenize_signature : --> do i ever get here?
2021-03-02 20:51:50,483 : INFO : tokenize_signature : --> do i ever get here?
2021-03-02 20:51:50,483 : INFO : tokenize_signature : --> do i ever get here?
2021-03-02 20:51:50,484 : INFO : tokenize_signature : --> do i ever get here?
2021-03-02 20:51:50,484 : INFO : tokenize_signature : --> do i ever get here?
2021-03-02 20:51:50,484 : INFO : tokenize_signature : --> do i ever get here?
2021-03-02 20:51:50,484 : INFO : tokenize_signature : --> do i ever get here?
2021-03-02 20:51:50,484 : INFO : tokenize_signature : --> do i ever get here?
2021-03-02 20:51:50,484 : INFO : tokenize_signature : --> do i ever get here?
2021-03-02 20:51:50,484 : INFO : tokenize_signature : --> do i ever get here?
2021-03-02 20:51:50,484 : INFO : tokenize_signature : --> do i ever get here?
2021-03-02 20:51:50,484 : INFO : tokenize_signature : --> do i ever get here?
2021-03-02 20:51:50,484 : INFO : tokenize_signature : --> do i ever get here?
2021-03-02 20:51:50,484 : INFO : tokenize_signature : --> do i ever get here?
2021-03-02 20:51:50,485 : INFO : tokenize_signature : --> do i ever get here?
2021-03-02 20:51:50,485 : INFO : tokenize_signature : --> do i ever get here?
2021-03-02 20:51:50,485 : INFO : tokenize_signature : --> do i ever get here?
2021-03-02 20:51:50,485 : INFO : tokenize_signature : --> do i ever get here?
2021-03-02 20:51:50,485 : INFO : tokenize_signature : --> do i ever get here?
2021-03-02 20:51:50,485 : INFO : tokenize_signature : --> do i ever get here?
2021-03-02 20:51:50,485 : INFO : tokenize_signature : --> do i ever get here?
2021-03-02 20:51:50,485 : INFO : tokenize_signature : --> do i ever get here?
2021-03-02 20:51:50,485 : INFO : tokenize_signature : --> do i ever get here?
2021-03-02 20:51:50,485 : INFO : tokenize_signature : --> do i ever get here?
2021-03-02 20:51:50,485 : INFO : tokenize_signature : --> do i ever get here?
2021-03-02 20:51:50,485 : INFO : tokenize_signature : --> do i ever get here?
2021-03-02 20:51:50,486 : INFO : tokenize_signature : --> do i ever get here?
2021-03-02 20:51:50,486 : INFO : tokenize_signature : --> do i ever get here?
2021-03-02 20:51:50,486 : INFO : tokenize_signature : --> do i ever get here?
2021-03-02 20:51:50,486 : INFO : tokenize_signature : --> do i ever get here?
2021-03-02 20:51:50,486 : INFO : tokenize_signature : --> do i ever get here?
2021-03-02 20:51:50,486 : INFO : tokenize_signature : --> do i ever get here?
2021-03-02 20:51:50,486 : INFO : tokenize_signature : --> do i ever get here?
2021-03-02 20:51:50,486 : INFO : tokenize_signature : --> do i ever get here?
2021-03-02 20:51:50,486 : INFO : tokenize_signature : --> do i ever get here?
2021-03-02 20:51:50,486 : INFO : tokenize_signature : --> do i ever get here?
2021-03-02 20:51:50,486 : INFO : tokenize_signature : --> do i ever get here?
2021-03-02 20:51:50,486 : INFO : tokenize_signature : --> do i ever get here?
2021-03-02 20:51:50,487 : INFO : tokenize_signature : --> do i ever get here?
2021-03-02 20:51:50,487 : INFO : tokenize_signature : --> do i ever get here?
2021-03-02 20:51:50,487 : INFO : tokenize_signature : --> do i ever get here?
2021-03-02 20:51:50,487 : INFO : tokenize_signature : --> do i ever get here?
2021-03-02 20:51:50,487 : INFO : tokenize_signature : --> do i ever get here?
2021-03-02 20:51:50,487 : INFO : tokenize_signature : --> do i ever get here?
2021-03-02 20:51:50,487 : INFO : tokenize_signature : --> do i ever get here?
2021-03-02 20:51:50,487 : INFO : tokenize_signature : --> do i ever get here?
2021-03-02 20:51:50,487 : INFO : tokenize_signature : --> do i ever get here?
2021-03-02 20:51:50,487 : INFO : tokenize_signature : --> do i ever get here?
    def prompt(
        self,
        # When any of these arguments are passed, this value is overwritten
        # in this PromptSession.
        message: Optional[AnyFormattedText] = None,
        # `message` should go first, because people call it as
        # positional argument.
        *,
        editing_mode: Optional[EditingMode] = None,
        refresh_interval: Optional[float] = None,
        vi_mode: Optional[bool] = None,
        lexer: Optional[Lexer] = None,
        completer: Optional[Completer] = None,
        complete_in_thread: Optional[bool] = None,
        is_password: Optional[bool] = None,
        key_bindings: Optional[KeyBindingsBase] = None,
        bottom_toolbar: Optional[AnyFormattedText] = None,
        style: Optional[BaseStyle] = None,
        color_depth: Optional[ColorDepth] = None,
        include_default_pygments_style: Optional[FilterOrBool] = None,
        style_transformation: Optional[StyleTransformation] = None,
        swap_light_and_dark_colors: Optional[FilterOrBool] = None,
        rprompt: Optional[AnyFormattedText] = None,
        multiline: Optional[FilterOrBool] = None,
        prompt_continuation: Optional[PromptContinuationText] = None,
        wrap_lines: Optional[FilterOrBool] = None,
        enable_history_search: Optional[FilterOrBool] = None,
        search_ignore_case: Optional[FilterOrBool] = None,
        complete_while_typing: Optional[FilterOrBool] = None,
        validate_while_typing: Optional[FilterOrBool] = None,
        complete_style: Optional[CompleteStyle] = None,
        auto_suggest: Optional[AutoSuggest] = None,
        validator: Optional[Validator] = None,
        clipboard: Optional[Clipboard] = None,
        mouse_support: Optional[FilterOrBool] = None,
        input_processors: Optional[List[Processor]] = None,
        placeholder: Optional[AnyFormattedText] = None,
        reserve_space_for_menu: Optional[int] = None,
        enable_system_prompt: Optional[FilterOrBool] = None,
        enable_suspend: Optional[FilterOrBool] = None,
        enable_open_in_editor: Optional[FilterOrBool] = None,
        tempfile_suffix: Optional[Union[str, Callable[[], str]]] = None,
        tempfile: Optional[Union[str, Callable[[], str]]] = None,
        # Following arguments are specific to the current `prompt()` call.
        default: Union[str, Document] = "",
        accept_default: bool = False,
        pre_run: Optional[Callable[[], None]] = None,
        set_exception_handler: bool = True,
    ) -> _T:
        """

                Display the prompt.

                The first set of arguments is a subset of the :class:`~.PromptSession`
                class itself. For these, passing in ``None`` will keep the current
                values that are active in the session. Passing in a value will set the
                attribute for the session, which means that it applies to the current,
                but also to the next prompts.

                Note that in order to erase a ``Completer``, ``Validator`` or
                ``AutoSuggest``, you can't use ``None``. Instead pass in a
                ``DummyCompleter``, ``DummyValidator`` or ``DummyAutoSuggest`` instance
                respectively. For a ``Lexer`` you can pass in an empty ``SimpleLexer``.

                Additional arguments, specific for this prompt:

                :param default: The default input text to be shown. (This can be edited
                    by the user).
                :param accept_default: When `True`, automatically accept the default
                    value without allowing the user to edit the input.
                :param pre_run: Callable, called at the start of `Application.run`.

                This method will raise ``KeyboardInterrupt`` when control-c has been
                pressed (for abort) and ``EOFError`` when control-d has been pressed
                (for exit).
        
        """
    async def _dumb_prompt(self, message: AnyFormattedText = "") -> _T:
            """

                    Prompt function for dumb terminals.

                    Dumb terminals have minimum rendering capabilities. We can only print
                    text to the screen. We can't use colors, and we can't do cursor
                    movements. The Emacs inferior shell is an example of a dumb terminal.

                    We will show the prompt, and wait for the input. We still handle arrow
                    keys, and all custom key bindings, but we don't really render the
                    cursor movements. Instead we only print the typed character that's
                    right before the cursor.
        
            """
        def on_text_changed(_) -> None:
            """
             Render line ending.

            """
2021-03-02 20:51:50,491 : INFO : tokenize_signature : --> do i ever get here?
2021-03-02 20:51:50,491 : INFO : tokenize_signature : --> do i ever get here?
2021-03-02 20:51:50,491 : INFO : tokenize_signature : --> do i ever get here?
2021-03-02 20:51:50,491 : INFO : tokenize_signature : --> do i ever get here?
2021-03-02 20:51:50,491 : INFO : tokenize_signature : --> do i ever get here?
2021-03-02 20:51:50,491 : INFO : tokenize_signature : --> do i ever get here?
2021-03-02 20:51:50,491 : INFO : tokenize_signature : --> do i ever get here?
2021-03-02 20:51:50,491 : INFO : tokenize_signature : --> do i ever get here?
2021-03-02 20:51:50,491 : INFO : tokenize_signature : --> do i ever get here?
2021-03-02 20:51:50,491 : INFO : tokenize_signature : --> do i ever get here?
2021-03-02 20:51:50,491 : INFO : tokenize_signature : --> do i ever get here?
2021-03-02 20:51:50,491 : INFO : tokenize_signature : --> do i ever get here?
2021-03-02 20:51:50,491 : INFO : tokenize_signature : --> do i ever get here?
2021-03-02 20:51:50,492 : INFO : tokenize_signature : --> do i ever get here?
2021-03-02 20:51:50,492 : INFO : tokenize_signature : --> do i ever get here?
2021-03-02 20:51:50,492 : INFO : tokenize_signature : --> do i ever get here?
2021-03-02 20:51:50,492 : INFO : tokenize_signature : --> do i ever get here?
2021-03-02 20:51:50,492 : INFO : tokenize_signature : --> do i ever get here?
2021-03-02 20:51:50,492 : INFO : tokenize_signature : --> do i ever get here?
2021-03-02 20:51:50,492 : INFO : tokenize_signature : --> do i ever get here?
2021-03-02 20:51:50,492 : INFO : tokenize_signature : --> do i ever get here?
2021-03-02 20:51:50,492 : INFO : tokenize_signature : --> do i ever get here?
2021-03-02 20:51:50,492 : INFO : tokenize_signature : --> do i ever get here?
2021-03-02 20:51:50,492 : INFO : tokenize_signature : --> do i ever get here?
2021-03-02 20:51:50,492 : INFO : tokenize_signature : --> do i ever get here?
2021-03-02 20:51:50,492 : INFO : tokenize_signature : --> do i ever get here?
2021-03-02 20:51:50,493 : INFO : tokenize_signature : --> do i ever get here?
2021-03-02 20:51:50,493 : INFO : tokenize_signature : --> do i ever get here?
2021-03-02 20:51:50,493 : INFO : tokenize_signature : --> do i ever get here?
2021-03-02 20:51:50,493 : INFO : tokenize_signature : --> do i ever get here?
2021-03-02 20:51:50,493 : INFO : tokenize_signature : --> do i ever get here?
2021-03-02 20:51:50,493 : INFO : tokenize_signature : --> do i ever get here?
2021-03-02 20:51:50,493 : INFO : tokenize_signature : --> do i ever get here?
2021-03-02 20:51:50,493 : INFO : tokenize_signature : --> do i ever get here?
2021-03-02 20:51:50,493 : INFO : tokenize_signature : --> do i ever get here?
2021-03-02 20:51:50,493 : INFO : tokenize_signature : --> do i ever get here?
2021-03-02 20:51:50,493 : INFO : tokenize_signature : --> do i ever get here?
2021-03-02 20:51:50,493 : INFO : tokenize_signature : --> do i ever get here?
2021-03-02 20:51:50,494 : INFO : tokenize_signature : --> do i ever get here?
2021-03-02 20:51:50,494 : INFO : tokenize_signature : --> do i ever get here?
2021-03-02 20:51:50,494 : INFO : tokenize_signature : --> do i ever get here?
2021-03-02 20:51:50,494 : INFO : tokenize_signature : --> do i ever get here?
2021-03-02 20:51:50,494 : INFO : tokenize_signature : --> do i ever get here?
2021-03-02 20:51:50,494 : INFO : tokenize_signature : --> do i ever get here?
2021-03-02 20:51:50,494 : INFO : tokenize_signature : --> do i ever get here?
2021-03-02 20:51:50,494 : INFO : tokenize_signature : --> do i ever get here?
2021-03-02 20:51:50,494 : INFO : tokenize_signature : --> do i ever get here?
2021-03-02 20:51:50,494 : INFO : tokenize_signature : --> do i ever get here?
    async def prompt_async(
        self,
        # When any of these arguments are passed, this value is overwritten
        # in this PromptSession.
        message: Optional[AnyFormattedText] = None,
        # `message` should go first, because people call it as
        # positional argument.
        *,
        editing_mode: Optional[EditingMode] = None,
        refresh_interval: Optional[float] = None,
        vi_mode: Optional[bool] = None,
        lexer: Optional[Lexer] = None,
        completer: Optional[Completer] = None,
        complete_in_thread: Optional[bool] = None,
        is_password: Optional[bool] = None,
        key_bindings: Optional[KeyBindingsBase] = None,
        bottom_toolbar: Optional[AnyFormattedText] = None,
        style: Optional[BaseStyle] = None,
        color_depth: Optional[ColorDepth] = None,
        include_default_pygments_style: Optional[FilterOrBool] = None,
        style_transformation: Optional[StyleTransformation] = None,
        swap_light_and_dark_colors: Optional[FilterOrBool] = None,
        rprompt: Optional[AnyFormattedText] = None,
        multiline: Optional[FilterOrBool] = None,
        prompt_continuation: Optional[PromptContinuationText] = None,
        wrap_lines: Optional[FilterOrBool] = None,
        enable_history_search: Optional[FilterOrBool] = None,
        search_ignore_case: Optional[FilterOrBool] = None,
        complete_while_typing: Optional[FilterOrBool] = None,
        validate_while_typing: Optional[FilterOrBool] = None,
        complete_style: Optional[CompleteStyle] = None,
        auto_suggest: Optional[AutoSuggest] = None,
        validator: Optional[Validator] = None,
        clipboard: Optional[Clipboard] = None,
        mouse_support: Optional[FilterOrBool] = None,
        input_processors: Optional[List[Processor]] = None,
        placeholder: Optional[AnyFormattedText] = None,
        reserve_space_for_menu: Optional[int] = None,
        enable_system_prompt: Optional[FilterOrBool] = None,
        enable_suspend: Optional[FilterOrBool] = None,
        enable_open_in_editor: Optional[FilterOrBool] = None,
        tempfile_suffix: Optional[Union[str, Callable[[], str]]] = None,
        tempfile: Optional[Union[str, Callable[[], str]]] = None,
        # Following arguments are specific to the current `prompt()` call.
        default: Union[str, Document] = "",
        accept_default: bool = False,
        pre_run: Optional[Callable[[], None]] = None,
        set_exception_handler: bool = True,
    ) -> _T:
            """
             This is not reactive.
            """
2021-03-02 20:51:50,497 : INFO : tokenize_signature : --> do i ever get here?
2021-03-02 20:51:50,497 : INFO : tokenize_signature : --> do i ever get here?
    def _add_pre_run_callables(
        self, pre_run: Optional[Callable[[], None]], accept_default: bool
    ) -> None:
        """
         Validate and handle input. We use `call_from_executor` in
         order to run it "soon" (during the next iteration of the
         event loop), instead of right now. Otherwise, it won't
         display the default value.

        """
    def editing_mode(self) -> EditingMode:
        """
         If there is an autocompletion menu to be shown, make sure that our
         layout has at least a minimal height in order to display it.

        """
    def _get_prompt(self) -> StyleAndTextTuples:
        """
        class:prompt
        """
2021-03-02 20:51:50,498 : INFO : tokenize_signature : --> do i ever get here?
2021-03-02 20:51:50,498 : INFO : tokenize_signature : --> do i ever get here?
    def _get_continuation(
        self, width: int, line_number: int, wrap_count: int
    ) -> StyleAndTextTuples:
        """

                Insert the prompt continuation.

                :param width: The width that was used for the prompt. (more or less can
                    be used.)
                :param line_number:
                :param wrap_count: Amount of times that the line has been wrapped.
        
        """
2021-03-02 20:51:50,498 : INFO : tokenize_signature : --> do i ever get here?
2021-03-02 20:51:50,498 : INFO : tokenize_signature : --> do i ever get here?
2021-03-02 20:51:50,498 : INFO : tokenize_signature : --> do i ever get here?
2021-03-02 20:51:50,499 : INFO : tokenize_signature : --> do i ever get here?
2021-03-02 20:51:50,499 : INFO : tokenize_signature : --> do i ever get here?
    def _get_line_prefix(
        self,
        line_number: int,
        wrap_count: int,
        get_prompt_text_2: _StyleAndTextTuplesCallable,
    ) -> StyleAndTextTuples:
        """

                Return whatever needs to be inserted before every line.
                (the prompt, or a line continuation.)
        
        """
    def _get_arg_text(self) -> StyleAndTextTuples:
        """
         'arg' toolbar, for in multiline mode. 
        """
    def _inline_arg(self) -> StyleAndTextTuples:
        """
         'arg' prefix, for in single line mode. 
        """
    def input(self) -> Input:
        """
         Following arguments are specific to the current `prompt()` call.

        """
2021-03-02 20:51:50,502 : INFO : tokenize_signature : --> do i ever get here?
2021-03-02 20:51:50,502 : INFO : tokenize_signature : --> do i ever get here?
def create_confirm_session(
    message: str, suffix: str = " (y/n) "
) -> PromptSession[bool]:
    """

        Create a `PromptSession` object for the 'confirm' function.
    
    """
    def yes(event: E) -> None:
        """
        y
        """
    def no(event: E) -> None:
        """
        n
        """
    def _(event: E) -> None:
        """
         Disallow inserting other text. 
        """
def confirm(message: str = "Confirm?", suffix: str = " (y/n) ") -> bool:
    """

        Display a confirmation prompt that returns True/False.
    
    """
