def patch_stdout(raw: bool = False) -> Generator[None, None, None]:
    """

        Replace `sys.stdout` by an :class:`_StdoutProxy` instance.

        Writing to this proxy will make sure that the text appears above the
        prompt, and that it doesn't destroy the output from the renderer.  If no
        application is curring, the behaviour should be identical to writing to
        `sys.stdout` directly.

        Warning: If a new event loop is installed using `asyncio.set_event_loop()`,
            then make sure that the context manager is applied after the event loop
            is changed. Printing to stdout will be scheduled in the event loop
            that's active when the context manager is created.

        :param raw: (`bool`) When True, vt100 terminal escape sequences are not
                    removed/escaped.
    
    """
def StdoutProxy:
    """

        Proxy object for stdout which captures everything and prints output above
        the current application.
    
    """
2021-03-02 20:51:47,582 : INFO : tokenize_signature : --> do i ever get here?
2021-03-02 20:51:47,582 : INFO : tokenize_signature : --> do i ever get here?
    def __init__(
        self, raw: bool = False, original_stdout: Optional[TextIO] = None
    ) -> None:
        """
         errors/encoding attribute for compatibility with sys.__stdout__.

        """
    def _write_and_flush(self, text: str) -> None:
        """

                Write the given text to stdout and flush.
                If an application is running, use `run_in_terminal`.
        
        """
        def write_and_flush() -> None:
            """
             If an application is running, use `run_in_terminal`, otherwise
             call it directly.

            """
    def _write(self, data: str) -> None:
        """

                Note: print()-statements cause to multiple write calls.
                      (write('line') and write('\n')). Of course we don't want to call
                      `run_in_terminal` for every individual call, because that's too
                      expensive, and as long as the newline hasn't been written, the
                      text itself is again overwritten by the rendering of the input
                      command line. Therefor, we have a little buffer which holds the
                      text until a newline is written to stdout.
        
        """
    def _flush(self) -> None:
        """

        """
    def write(self, data: str) -> int:
        """
         Pretend everything was written.
        """
    def flush(self) -> None:
        """

                Flush buffered output.
        
        """
    def fileno(self) -> int:
        """

                Return file descriptor.
        
        """
    def isatty(self) -> bool:
