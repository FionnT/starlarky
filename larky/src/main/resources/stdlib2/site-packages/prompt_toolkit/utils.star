def Event(Generic[_Sender]):
    """

        Simple event to which event handlers can be attached. For instance::

            class Cls:
                def __init__(self):
                    # Define event. The first parameter is the sender.
                    self.event = Event(self)

            obj = Cls()

            def handler(sender):
                pass

            # Add event handler by using the += operator.
            obj.event += handler

            # Fire event.
            obj.event()
    
    """
2021-03-02 20:51:48,980 : INFO : tokenize_signature : --> do i ever get here?
2021-03-02 20:51:48,980 : INFO : tokenize_signature : --> do i ever get here?
    def __init__(
        self, sender: _Sender, handler: Optional[Callable[[_Sender], None]] = None
    ):
        """
         Fire event. 
        """
    def fire(self) -> None:
        """
         Alias for just calling the event. 
        """
    def add_handler(self, handler: Callable[[_Sender], None]) -> None:
        """

                Add another handler to this callback.
                (Handler should be a callable that takes exactly one parameter: the
                sender object.)
        
        """
    def remove_handler(self, handler: Callable[[_Sender], None]) -> None:
        """

                Remove a handler from this callback.
        
        """
    def __iadd__(self, handler: Callable[[_Sender], None]) -> "Event[_Sender]":
        """

                `event += handler` notation for adding a handler.
        
        """
    def __isub__(self, handler: Callable[[_Sender], None]) -> "Event[_Sender]":
        """

                `event -= handler` notation for removing a handler.
        
        """
def DummyContext(ContextManager[None]):
    """

        (contextlib.nested is not available on Py3)
    
    """
    def __enter__(self) -> None:
        """

            Cache for wcwidth sizes.
    
        """
    def __init__(self) -> None:
        """
         Keep track of the "long" strings in this cache.

        """
    def __missing__(self, string: str) -> int:
        """
         Note: We use the `max(0, ...` because some non printable control
               characters, like e.g. Ctrl-underscore get a -1 wcwidth value.
               It can be possible that these characters end up in the input
               text.

        """
def get_cwidth(string: str) -> int:
    """

        Return width of a string. Wrapper around ``wcwidth``.
    
    """
def suspend_to_background_supported() -> bool:
    """

        Returns `True` when the Python implementation supports
        suspend-to-background. This is typically `False' on Windows systems.
    
    """
def is_windows() -> bool:
    """

        True when we are using Windows.
    
    """
def is_windows_vt100_supported() -> bool:
    """

        True when we are using Windows, but VT100 escape sequences are supported.
    
    """
def is_conemu_ansi() -> bool:
    """

        True when the ConEmu Windows console is used.
    
    """
def in_main_thread() -> bool:
    """

        True when the current thread is the main thread.
    
    """
def get_term_environment_variable() -> str:
    """
     Return the $TERM environment variable. 
    """
2021-03-02 20:51:48,984 : INFO : tokenize_signature : --> do i ever get here?
2021-03-02 20:51:48,984 : INFO : tokenize_signature : --> do i ever get here?
def take_using_weights(
    items: List[_T], weights: List[int]
) -> Generator[_T, None, None]:
    """

        Generator that keeps yielding items from the items list, in proportion to
        their weight. For instance::

            # Getting the first 70 items from this generator should have yielded 10
            # times A, 20 times B and 40 times C, all distributed equally..
            take_using_weights(['A', 'B', 'C'], [5, 10, 20])

        :param items: List of items to take from.
        :param weights: Integers representing the weight. (Numbers have to be
                        integers, not floats.)
    
    """
def to_str(value: Union[Callable[[], str], str]) -> str:
    """
     Turn callable or string into string. 
    """
def to_int(value: Union[Callable[[], int], int]) -> int:
    """
     Turn callable or int into int. 
    """
def to_float(value: AnyFloat) -> float:
    """
     Turn callable or float into float. 
    """
def is_dumb_terminal(term: Optional[str] = None) -> bool:
    """

        True if this terminal type is considered "dumb".

        If so, we should fall back to the simplest possible form of line editing,
        without cursor positioning and color support.
    
    """
