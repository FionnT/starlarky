def PosixStdinReader:
    """

        Wrapper around stdin which reads (nonblocking) the next available 1024
        bytes and decodes it.

        Note that you can't be sure that the input file is closed if the ``read``
        function returns an empty string. When ``errors=ignore`` is passed,
        ``read`` can return an empty string if all malformed input was replaced by
        an empty string. (We can't block here and wait for more input.) So, because
        of that, check the ``closed`` attribute, to be sure that the file has been
        closed.

        :param stdin_fd: File descriptor from which we read.
        :param errors:  Can be 'ignore', 'strict' or 'replace'.
            On Python3, this can be 'surrogateescape', which is the default.

            'surrogateescape' is preferred, because this allows us to transfer
            unrecognised bytes to the key bindings. Some terminals, like lxterminal
            and Guake, use the 'Mxx' notation to send mouse events, where each 'x'
            can be any possible byte.
    
    """
2021-03-02 20:51:33,496 : INFO : tokenize_signature : --> do i ever get here?
2021-03-02 20:51:33,496 : INFO : tokenize_signature : --> do i ever get here?
    def __init__(
        self, stdin_fd: int, errors: str = "surrogateescape", encoding: str = "utf-8"
    ) -> None:
        """
         Create incremental decoder for decoding stdin.
         We can not just do `os.read(stdin.fileno(), 1024).decode('utf-8')`, because
         it could be that we are in the middle of a utf-8 byte sequence.

        """
    def read(self, count: int = 1024) -> str:
        """
         By default we choose a rather small chunk size, because reading
         big amounts of input at once, causes the event loop to process
         all these key bindings also at once without going back to the
         loop. This will make the application feel unresponsive.

        """
