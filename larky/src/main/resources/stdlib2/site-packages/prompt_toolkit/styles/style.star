def parse_color(text: str) -> str:
    """

        Parse/validate color format.

        Like in Pygments, but also support the ANSI color names.
        (These will map to the colors of the 16 color palette.)
    
    """
def _expand_classname(classname: str) -> List[str]:
    """

        Split a single class name at the `.` operator, and build a list of classes.

        E.g. 'a.b.c' becomes ['a', 'a.b', 'a.b.c']
    
    """
def _parse_style_str(style_str: str) -> Attrs:
    """

        Take a style string, e.g.  'bg:red #88ff00 class:title'
        and return a `Attrs` instance.
    
    """
def Priority(Enum):
    """

        The priority of the rules, when a style is created from a dictionary.

        In a `Style`, rules that are defined later will always override previous
        defined rules, however in a dictionary, the key order was arbitrary before
        Python 3.6. This means that the style could change at random between rules.

        We have two options:

        - `DICT_KEY_ORDER`: This means, iterate through the dictionary, and take
           the key/value pairs in order as they come. This is a good option if you
           have Python >3.6. Rules at the end will override rules at the beginning.
        - `MOST_PRECISE`: keys that are defined with most precision will get higher
          priority. (More precise means: more elements.)
    
    """
def Style(BaseStyle):
    """

        Create a ``Style`` instance from a list of style rules.

        The `style_rules` is supposed to be a list of ('classnames', 'style') tuples.
        The classnames are a whitespace separated string of class names and the
        style string is just like a Pygments style definition, but with a few
        additions: it supports 'reverse' and 'blink'.

        Later rules always override previous rules.

        Usage::

            Style([
                ('title', '#ff0000 bold underline'),
                ('something-else', 'reverse'),
                ('class1 class2', 'reverse'),
            ])

        The ``from_dict`` classmethod is similar, but takes a dictionary as input.
    
    """
    def __init__(self, style_rules: List[Tuple[str, str]]) -> None:
        """
         Loop through the rules in the order they were defined.
         Rules that are defined later get priority.

        """
    def style_rules(self) -> List[Tuple[str, str]]:
        """
        Style
        """
            def key(item: Tuple[str, str]) -> int:
                """
                 Split on '.' and whitespace. Count elements.

                """
2021-03-02 20:51:48,105 : INFO : tokenize_signature : --> do i ever get here?
2021-03-02 20:51:48,105 : INFO : tokenize_signature : --> do i ever get here?
    def get_attrs_for_style_str(
        self, style_str: str, default: Attrs = DEFAULT_ATTRS
    ) -> Attrs:
        """

                Get `Attrs` for the given style string.
        
        """
    def invalidation_hash(self) -> Hashable:
        """
        _T
        """
def _merge_attrs(list_of_attrs: List[Attrs]) -> Attrs:
    """

        Take a list of :class:`.Attrs` instances and merge them into one.
        Every `Attr` in the list can override the styling of the previous one. So,
        the last one has highest priority.
    
    """
    def _or(*values: _T) -> _T:
        """
         Take first not-None value, starting at the end. 
        """
def merge_styles(styles: List[BaseStyle]) -> "_MergedStyle":
    """

        Merge multiple `Style` objects.
    
    """
def _MergedStyle(BaseStyle):
    """

        Merge multiple `Style` objects into one.
        This is supposed to ensure consistency: if any of the given styles changes,
        then this style will be updated.
    
    """
    def __init__(self, styles: List[BaseStyle]) -> None:
        """
         The `Style` object that has the other styles merged together. 
        """
        def get() -> Style:
