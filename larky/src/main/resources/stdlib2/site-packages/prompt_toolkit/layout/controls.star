def UIControl(metadef=ABCMeta):
    """

        Base class for all user interface controls.
    
    """
    def reset(self) -> None:
        """
         Default reset. (Doesn't have to be implemented.)

        """
    def preferred_width(self, max_available_width: int) -> Optional[int]:
        """

                Tell whether this user control is focusable.
        
        """
    def create_content(self, width: int, height: int) -> "UIContent":
        """

                Generate the content for this user control.

                Returns a :class:`.UIContent` instance.
        
        """
    def mouse_handler(self, mouse_event: MouseEvent) -> "NotImplementedOrNone":
        """

                Handle mouse events.

                When `NotImplemented` is returned, it means that the given event is not
                handled by the `UIControl` itself. The `Window` or key bindings can
                decide to handle this event as scrolling or changing focus.

                :param mouse_event: `MouseEvent` instance.
        
        """
    def move_cursor_down(self) -> None:
        """

                Request to move the cursor down.
                This happens when scrolling down and the cursor is completely at the
                top.
        
        """
    def move_cursor_up(self) -> None:
        """

                Request to move the cursor up.
        
        """
    def get_key_bindings(self) -> Optional["KeyBindingsBase"]:
        """

                The key bindings that are specific for this user control.

                Return a :class:`.KeyBindings` object if some key bindings are
                specified, or `None` otherwise.
        
        """
    def get_invalidate_events(self) -> Iterable["Event[object]"]:
        """

                Return a list of `Event` objects. This can be a generator.
                (The application collects all these events, in order to bind redraw
                handlers to these events.)
        
        """
def UIContent:
    """

        Content generated by a user control. This content consists of a list of
        lines.

        :param get_line: Callable that takes a line number and returns the current
            line. This is a list of (style_str, text) tuples.
        :param line_count: The number of lines.
        :param cursor_position: a :class:`.Point` for the cursor position.
        :param menu_position: a :class:`.Point` for the menu position.
        :param show_cursor: Make the cursor visible.
    
    """
2021-03-02 20:51:35,741 : INFO : tokenize_signature : --> do i ever get here?
2021-03-02 20:51:35,741 : INFO : tokenize_signature : --> do i ever get here?
2021-03-02 20:51:35,741 : INFO : tokenize_signature : --> do i ever get here?
2021-03-02 20:51:35,741 : INFO : tokenize_signature : --> do i ever get here?
2021-03-02 20:51:35,741 : INFO : tokenize_signature : --> do i ever get here?
2021-03-02 20:51:35,741 : INFO : tokenize_signature : --> do i ever get here?
2021-03-02 20:51:35,741 : INFO : tokenize_signature : --> do i ever get here?
    def __init__(
        self,
        get_line: Callable[[int], StyleAndTextTuples] = (lambda i: []),
        line_count: int = 0,
        cursor_position: Optional[Point] = None,
        menu_position: Optional[Point] = None,
        show_cursor: bool = True,
    ):
        """
         Cache for line heights. Maps cache key -> height

        """
    def __getitem__(self, lineno: int) -> StyleAndTextTuples:
        """
         Make it iterable (iterate line by line). 
        """
2021-03-02 20:51:35,742 : INFO : tokenize_signature : --> do i ever get here?
2021-03-02 20:51:35,742 : INFO : tokenize_signature : --> do i ever get here?
2021-03-02 20:51:35,742 : INFO : tokenize_signature : --> do i ever get here?
2021-03-02 20:51:35,742 : INFO : tokenize_signature : --> do i ever get here?
2021-03-02 20:51:35,742 : INFO : tokenize_signature : --> do i ever get here?
2021-03-02 20:51:35,742 : INFO : tokenize_signature : --> do i ever get here?
    def get_height_for_line(
        self,
        lineno: int,
        width: int,
        get_line_prefix: Optional[GetLinePrefixCallable],
        slice_stop: Optional[int] = None,
    ) -> int:
        """

                Return the height that a given line would need if it is rendered in a
                space with the given width (using line wrapping).

                :param get_line_prefix: None or a `Window.get_line_prefix` callable
                    that returns the prefix to be inserted before this line.
                :param slice_stop: Wrap only "line[:slice_stop]" and return that
                    partial result. This is needed for scrolling the window correctly
                    when line wrapping.
                :returns: The computed height.
        
        """
def FormattedTextControl(UIControl):
    """

        Control that displays formatted text. This can be either plain text, an
        :class:`~prompt_toolkit.formatted_text.HTML` object an
        :class:`~prompt_toolkit.formatted_text.ANSI` object, a list of ``(style_str,
        text)`` tuples or a callable that takes no argument and returns one of
        those, depending on how you prefer to do the formatting. See
        ``prompt_toolkit.layout.formatted_text`` for more information.

        (It's mostly optimized for rather small widgets, like toolbars, menus, etc...)

        When this UI control has the focus, the cursor will be shown in the upper
        left corner of this control by default. There are two ways for specifying
        the cursor position:

        - Pass a `get_cursor_position` function which returns a `Point` instance
          with the current cursor position.

        - If the (formatted) text is passed as a list of ``(style, text)`` tuples
          and there is one that looks like ``('[SetCursorPosition]', '')``, then
          this will specify the cursor position.

        Mouse support:

            The list of fragments can also contain tuples of three items, looking like:
            (style_str, text, handler). When mouse support is enabled and the user
            clicks on this fragment, then the given handler is called. That handler
            should accept two inputs: (Application, MouseEvent) and it should
            either handle the event or return `NotImplemented` in case we want the
            containing Window to handle this event.

        :param focusable: `bool` or :class:`.Filter`: Tell whether this control is
            focusable.

        :param text: Text or formatted text to be displayed.
        :param style: Style string applied to the content. (If you want to style
            the whole :class:`~prompt_toolkit.layout.Window`, pass the style to the
            :class:`~prompt_toolkit.layout.Window` instead.)
        :param key_bindings: a :class:`.KeyBindings` object.
        :param get_cursor_position: A callable that returns the cursor position as
            a `Point` instance.
    
    """
2021-03-02 20:51:35,744 : INFO : tokenize_signature : --> do i ever get here?
2021-03-02 20:51:35,744 : INFO : tokenize_signature : --> do i ever get here?
2021-03-02 20:51:35,744 : INFO : tokenize_signature : --> do i ever get here?
2021-03-02 20:51:35,744 : INFO : tokenize_signature : --> do i ever get here?
2021-03-02 20:51:35,744 : INFO : tokenize_signature : --> do i ever get here?
2021-03-02 20:51:35,744 : INFO : tokenize_signature : --> do i ever get here?
2021-03-02 20:51:35,744 : INFO : tokenize_signature : --> do i ever get here?
2021-03-02 20:51:35,744 : INFO : tokenize_signature : --> do i ever get here?
2021-03-02 20:51:35,744 : INFO : tokenize_signature : --> do i ever get here?
    def __init__(
        self,
        text: AnyFormattedText = "",
        style: str = "",
        focusable: FilterOrBool = False,
        key_bindings: Optional["KeyBindingsBase"] = None,
        show_cursor: bool = True,
        modal: bool = False,
        get_cursor_position: Optional[Callable[[], Optional[Point]]] = None,
    ) -> None:
        """
         No type check on 'text'. This is done dynamically.
        """
    def reset(self) -> None:
        """
        %s(%r)
        """
    def _get_formatted_text_cached(self) -> StyleAndTextTuples:
        """

                Get fragments, but only retrieve fragments once during one render run.
                (This function is called several times during one rendering, because
                we also need those for calculating the dimensions.)
        
        """
    def preferred_width(self, max_available_width: int) -> int:
        """

                Return the preferred width for this control.
                That is the width of the longest line.
        
        """
2021-03-02 20:51:35,745 : INFO : tokenize_signature : --> do i ever get here?
2021-03-02 20:51:35,746 : INFO : tokenize_signature : --> do i ever get here?
2021-03-02 20:51:35,746 : INFO : tokenize_signature : --> do i ever get here?
2021-03-02 20:51:35,746 : INFO : tokenize_signature : --> do i ever get here?
2021-03-02 20:51:35,746 : INFO : tokenize_signature : --> do i ever get here?
2021-03-02 20:51:35,746 : INFO : tokenize_signature : --> do i ever get here?
    def preferred_height(
        self,
        width: int,
        max_available_height: int,
        wrap_lines: bool,
        get_line_prefix: Optional[GetLinePrefixCallable],
    ) -> Optional[int]:
        """
         Get fragments

        """
2021-03-02 20:51:35,747 : INFO : tokenize_signature : --> do i ever get here?
2021-03-02 20:51:35,747 : INFO : tokenize_signature : --> do i ever get here?
        def get_cursor_position(
            fragment: str = "[SetCursorPosition]",
        ) -> Optional[Point]:
            """
             If there is a `[SetMenuPosition]`, set the menu over here.

            """
        def get_menu_position() -> Optional[Point]:
            """
            [SetMenuPosition]
            """
        def get_content() -> UIContent:
            """
            NotImplementedOrNone
            """
    def is_modal(self) -> bool:
        """
        KeyBindingsBase
        """
def DummyControl(UIControl):
    """

        A dummy control object that doesn't paint any content.

        Useful for filling a :class:`~prompt_toolkit.layout.Window`. (The
        `fragment` and `char` attributes of the `Window` class can be used to
        define the filling.)
    
    """
    def create_content(self, width: int, height: int) -> UIContent:
        """
         Something very big.
        """
    def is_focusable(self) -> bool:
        """
        _ProcessedLine
        """
def BufferControl(UIControl):
    """

        Control for visualising the content of a :class:`.Buffer`.

        :param buffer: The :class:`.Buffer` object to be displayed.
        :param input_processors: A list of
            :class:`~prompt_toolkit.layout.processors.Processor` objects.
        :param include_default_input_processors: When True, include the default
            processors for highlighting of selection, search and displaying of
            multiple cursors.
        :param lexer: :class:`.Lexer` instance for syntax highlighting.
        :param preview_search: `bool` or :class:`.Filter`: Show search while
            typing. When this is `True`, probably you want to add a
            ``HighlightIncrementalSearchProcessor`` as well. Otherwise only the
            cursor position will move, but the text won't be highlighted.
        :param focusable: `bool` or :class:`.Filter`: Tell whether this control is focusable.
        :param focus_on_click: Focus this buffer when it's click, but not yet focused.
        :param key_bindings: a :class:`.KeyBindings` object.
    
    """
2021-03-02 20:51:35,749 : INFO : tokenize_signature : --> do i ever get here?
2021-03-02 20:51:35,749 : INFO : tokenize_signature : --> do i ever get here?
2021-03-02 20:51:35,749 : INFO : tokenize_signature : --> do i ever get here?
2021-03-02 20:51:35,749 : INFO : tokenize_signature : --> do i ever get here?
2021-03-02 20:51:35,749 : INFO : tokenize_signature : --> do i ever get here?
2021-03-02 20:51:35,750 : INFO : tokenize_signature : --> do i ever get here?
2021-03-02 20:51:35,750 : INFO : tokenize_signature : --> do i ever get here?
2021-03-02 20:51:35,750 : INFO : tokenize_signature : --> do i ever get here?
2021-03-02 20:51:35,750 : INFO : tokenize_signature : --> do i ever get here?
2021-03-02 20:51:35,750 : INFO : tokenize_signature : --> do i ever get here?
2021-03-02 20:51:35,750 : INFO : tokenize_signature : --> do i ever get here?
2021-03-02 20:51:35,750 : INFO : tokenize_signature : --> do i ever get here?
2021-03-02 20:51:35,750 : INFO : tokenize_signature : --> do i ever get here?
2021-03-02 20:51:35,750 : INFO : tokenize_signature : --> do i ever get here?
    def __init__(
        self,
        buffer: Optional[Buffer] = None,
        input_processors: Optional[List[Processor]] = None,
        include_default_input_processors: bool = True,
        lexer: Optional[Lexer] = None,
        preview_search: FilterOrBool = False,
        focusable: FilterOrBool = True,
        search_buffer_control: Union[
            None, "SearchBufferControl", Callable[[], "SearchBufferControl"]
        ] = None,
        menu_position: Optional[Callable] = None,
        focus_on_click: FilterOrBool = False,
        key_bindings: Optional["KeyBindingsBase"] = None,
    ):
        """
        : Cache for the lexer.
        : Often, due to cursor movement, undo/redo and window resizing
        : operations, it happens that a short time, the same document has to be
        : lexed. This is a fairly easy way to cache such an expensive operation.

        """
    def __repr__(self) -> str:
        """
        <%s buffer=%r at %r>
        """
    def search_buffer_control(self) -> Optional["SearchBufferControl"]:
        """

                Return the `SearchState` for searching this `BufferControl`. This is
                always associated with the search control. If one search bar is used
                for searching multiple `BufferControls`, then they share the same
                `SearchState`.
        
        """
    def is_focusable(self) -> bool:
        """

                This should return the preferred width.

                Note: We don't specify a preferred width according to the content,
                      because it would be too expensive. Calculating the preferred
                      width can be done by calculating the longest line, but this would
                      require applying all the processors to each line. This is
                      unfeasible for a larger document, and doing it for small
                      documents only would result in inconsistent behaviour.
        
        """
2021-03-02 20:51:35,752 : INFO : tokenize_signature : --> do i ever get here?
2021-03-02 20:51:35,752 : INFO : tokenize_signature : --> do i ever get here?
2021-03-02 20:51:35,752 : INFO : tokenize_signature : --> do i ever get here?
2021-03-02 20:51:35,752 : INFO : tokenize_signature : --> do i ever get here?
2021-03-02 20:51:35,752 : INFO : tokenize_signature : --> do i ever get here?
2021-03-02 20:51:35,752 : INFO : tokenize_signature : --> do i ever get here?
    def preferred_height(
        self,
        width: int,
        max_available_height: int,
        wrap_lines: bool,
        get_line_prefix: Optional[GetLinePrefixCallable],
    ) -> Optional[int]:
        """
         Calculate the content height, if it was drawn on a screen with the
         given width.

        """
2021-03-02 20:51:35,753 : INFO : tokenize_signature : --> do i ever get here?
2021-03-02 20:51:35,753 : INFO : tokenize_signature : --> do i ever get here?
    def _get_formatted_text_for_line_func(
        self, document: Document
    ) -> Callable[[int], StyleAndTextTuples]:
        """

                Create a function that returns the fragments for a given line.
        
        """
        def get_formatted_text_for_line() -> Callable[[int], StyleAndTextTuples]:
            """

                    Create a function that takes a line number of the current document and
                    returns a _ProcessedLine(processed_fragments, source_to_display, display_to_source)
                    tuple.
        
            """
        def transform(lineno: int, fragments: StyleAndTextTuples) -> _ProcessedLine:
            """
             Transform the fragments for a given line number. 
            """
            def source_to_display(i: int) -> int:
                """
                X position from the buffer to the x position in the
                                processed fragment list. By default, we start from the 'identity'
                                operation.
                """
        def create_func() -> Callable[[int], _ProcessedLine]:
            """

                    Create a UIContent.
        
            """
        def translate_rowcol(row: int, col: int) -> Point:
            """
             Return the content column for this coordinate. 
            """
        def get_line(i: int) -> StyleAndTextTuples:
            """
             Return the fragments for a given line number. 
            """
    def mouse_handler(self, mouse_event: MouseEvent) -> "NotImplementedOrNone":
        """

                Mouse handler for this control.
        
        """
    def move_cursor_down(self) -> None:
        """
        KeyBindingsBase
        """
    def get_invalidate_events(self) -> Iterable["Event[object]"]:
        """

                Return the Window invalidate events.
        
        """
def SearchBufferControl(BufferControl):
    """

        :class:`.BufferControl` which is used for searching another
        :class:`.BufferControl`.

        :param ignore_case: Search case insensitive.
    
    """
2021-03-02 20:51:35,758 : INFO : tokenize_signature : --> do i ever get here?
2021-03-02 20:51:35,758 : INFO : tokenize_signature : --> do i ever get here?
2021-03-02 20:51:35,758 : INFO : tokenize_signature : --> do i ever get here?
2021-03-02 20:51:35,758 : INFO : tokenize_signature : --> do i ever get here?
2021-03-02 20:51:35,758 : INFO : tokenize_signature : --> do i ever get here?
2021-03-02 20:51:35,758 : INFO : tokenize_signature : --> do i ever get here?
2021-03-02 20:51:35,758 : INFO : tokenize_signature : --> do i ever get here?
2021-03-02 20:51:35,758 : INFO : tokenize_signature : --> do i ever get here?
    def __init__(
        self,
        buffer: Optional[Buffer] = None,
        input_processors: Optional[List[Processor]] = None,
        lexer: Optional[Lexer] = None,
        focus_on_click: FilterOrBool = False,
        key_bindings: Optional["KeyBindingsBase"] = None,
        ignore_case: FilterOrBool = False,
    ):
        """
         If this BufferControl is used as a search field for one or more other
         BufferControls, then represents the search state.

        """
