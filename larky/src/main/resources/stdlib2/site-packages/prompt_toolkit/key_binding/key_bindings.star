def Binding:
    """

        Key binding: (key sequence + handler + filter).
        (Immutable binding class.)

        :param record_in_macro: When True, don't record this key binding when a
            macro is recorded.
    
    """
2021-03-02 20:51:43,945 : INFO : tokenize_signature : --> do i ever get here?
2021-03-02 20:51:43,945 : INFO : tokenize_signature : --> do i ever get here?
2021-03-02 20:51:43,945 : INFO : tokenize_signature : --> do i ever get here?
2021-03-02 20:51:43,945 : INFO : tokenize_signature : --> do i ever get here?
2021-03-02 20:51:43,945 : INFO : tokenize_signature : --> do i ever get here?
2021-03-02 20:51:43,945 : INFO : tokenize_signature : --> do i ever get here?
2021-03-02 20:51:43,945 : INFO : tokenize_signature : --> do i ever get here?
2021-03-02 20:51:43,945 : INFO : tokenize_signature : --> do i ever get here?
2021-03-02 20:51:43,945 : INFO : tokenize_signature : --> do i ever get here?
    def __init__(
        self,
        keys: Tuple[Union[Keys, str], ...],
        handler: KeyHandlerCallable,
        filter: FilterOrBool = True,
        eager: FilterOrBool = False,
        is_global: FilterOrBool = False,
        save_before: Callable[["KeyPressEvent"], bool] = (lambda e: True),
        record_in_macro: FilterOrBool = True,
    ) -> None:
        """
        KeyPressEvent
        """
    def __repr__(self) -> str:
        """
        %s(keys=%r, handler=%r)
        """
def KeyBindingsBase(metadef=ABCMeta):
    """

        Interface for a KeyBindings.
    
    """
    def _version(self) -> Hashable:
        """

                For cache invalidation. - This should increase every time that
                something changes.
        
        """
    def get_bindings_for_keys(self, keys: KeysTuple) -> List[Binding]:
        """

                Return a list of key bindings that can handle these keys.
                (This return also inactive bindings, so the `filter` still has to be
                called, for checking it.)

                :param keys: tuple of keys.
        
        """
    def get_bindings_starting_with_keys(self, keys: KeysTuple) -> List[Binding]:
        """

                Return a list of key bindings that handle a key sequence starting with
                `keys`. (It does only return bindings for which the sequences are
                longer than `keys`. And like `get_bindings_for_keys`, it also includes
                inactive bindings.)

                :param keys: tuple of keys.
        
        """
    def bindings(self) -> List[Binding]:
        """

                List of `Binding` objects.
                (These need to be exposed, so that `KeyBindings` objects can be merged
                together.)
        
        """
def KeyBindings(KeyBindingsBase):
    """

        A container for a set of key bindings.

        Example usage::

            kb = KeyBindings()

            @kb.add('c-t')
            def _(event):
                print('Control-T pressed')

            @kb.add('c-a', 'c-b')
            def _(event):
                print('Control-A pressed, followed by Control-B')

            @kb.add('c-x', filter=is_searching)
            def _(event):
                print('Control-X pressed')  # Works only if we are searching.

    
    """
    def __init__(self) -> None:
        """
         For cache invalidation.
        """
    def _clear_cache(self) -> None:
        """
        KeyPressEvent
        """
            def decorator(func: T) -> T:
                """
                 We're adding an existing Binding object.

                """
    def remove(self, *args: Union[Keys, str, KeyHandlerCallable]) -> None:
        """

                Remove a key binding.

                This expects either a function that was given to `add` method as
                parameter or a sequence of key bindings.

                Raises `ValueError` when no bindings was found.

                Usage::

                    remove(handler)  # Pass handler.
                    remove('c-x', 'c-a')  # Or pass the key bindings.
        
        """
    def get_bindings_for_keys(self, keys: KeysTuple) -> List[Binding]:
        """

                Return a list of key bindings that can handle this key.
                (This return also inactive bindings, so the `filter` still has to be
                called, for checking it.)

                :param keys: tuple of keys.
        
        """
        def get() -> List[Binding]:
            """
             Place bindings that have more 'Any' occurrences in them at the end.

            """
    def get_bindings_starting_with_keys(self, keys: KeysTuple) -> List[Binding]:
        """

                Return a list of key bindings that handle a key sequence starting with
                `keys`. (It does only return bindings for which the sequences are
                longer than `keys`. And like `get_bindings_for_keys`, it also includes
                inactive bindings.)

                :param keys: tuple of keys.
        
        """
        def get() -> List[Binding]:
            """

                Replace key by alias and verify whether it's a valid one.
    
            """
2021-03-02 20:51:43,951 : INFO : tokenize_signature : --> do i ever get here?
2021-03-02 20:51:43,951 : INFO : tokenize_signature : --> do i ever get here?
2021-03-02 20:51:43,952 : INFO : tokenize_signature : --> do i ever get here?
2021-03-02 20:51:43,952 : INFO : tokenize_signature : --> do i ever get here?
2021-03-02 20:51:43,952 : INFO : tokenize_signature : --> do i ever get here?
2021-03-02 20:51:43,952 : INFO : tokenize_signature : --> do i ever get here?
def key_binding(
    filter: FilterOrBool = True,
    eager: FilterOrBool = False,
    is_global: FilterOrBool = False,
    save_before: Callable[["KeyPressEvent"], bool] = (lambda event: True),
    record_in_macro: FilterOrBool = True,
) -> Callable[[KeyHandlerCallable], Binding]:
    """

        Decorator that turn a function into a `Binding` object. This can be added
        to a `KeyBindings` object when a key binding is assigned.
    
    """
    def decorator(function: KeyHandlerCallable) -> Binding:
        """

            Common part for ConditionalKeyBindings and _MergedKeyBindings.
    
        """
    def __init__(self) -> None:
        """
         `KeyBindings` to be synchronized with all the others.

        """
    def _update_cache(self) -> None:
        """

                If `self._last_version` is outdated, then this should update
                the version and `self._bindings2`.
        
        """
    def bindings(self) -> List[Binding]:
        """

            Wraps around a `KeyBindings`. Disable/enable all the key bindings according to
            the given (additional) filter.::

                @Condition
                def setting_is_true():
                    return True  # or False

                registry = ConditionalKeyBindings(key_bindings, setting_is_true)

            When new key bindings are added to this object. They are also
            enable/disabled according to the given `filter`.

            :param registries: List of :class:`.KeyBindings` objects.
            :param filter: :class:`~prompt_toolkit.filters.Filter` object.
    
        """
2021-03-02 20:51:43,953 : INFO : tokenize_signature : --> do i ever get here?
2021-03-02 20:51:43,954 : INFO : tokenize_signature : --> do i ever get here?
    def __init__(
        self, key_bindings: KeyBindingsBase, filter: FilterOrBool = True
    ) -> None:
        """
         If the original key bindings was changed. Update our copy version. 
        """
def _MergedKeyBindings(_Proxy):
    """

        Merge multiple registries of key bindings into one.

        This class acts as a proxy to multiple :class:`.KeyBindings` objects, but
        behaves as if this is just one bigger :class:`.KeyBindings`.

        :param registries: List of :class:`.KeyBindings` objects.
    
    """
    def __init__(self, registries: Sequence[KeyBindingsBase]) -> None:
        """

                If one of the original registries was changed. Update our merged
                version.
        
        """
def merge_key_bindings(bindings: Sequence[KeyBindingsBase]) -> _MergedKeyBindings:
    """

        Merge multiple :class:`.Keybinding` objects together.

        Usage::

            bindings = merge_key_bindings([bindings1, bindings2, ...])
    
    """
def DynamicKeyBindings(_Proxy):
    """

        KeyBindings class that can dynamically returns any KeyBindings.

        :param get_key_bindings: Callable that returns a :class:`.KeyBindings` instance.
    
    """
2021-03-02 20:51:43,955 : INFO : tokenize_signature : --> do i ever get here?
2021-03-02 20:51:43,955 : INFO : tokenize_signature : --> do i ever get here?
    def __init__(
        self, get_key_bindings: Callable[[], Optional[KeyBindingsBase]]
    ) -> None:
        """
         Empty key bindings.
        """
    def _update_cache(self) -> None:
        """

            Wrapper around a :class:`.KeyBindings` object that only exposes the global
            key bindings.
    
        """
    def __init__(self, key_bindings: KeyBindingsBase) -> None:
        """

                If one of the original registries was changed. Update our merged
                version.
        
        """
