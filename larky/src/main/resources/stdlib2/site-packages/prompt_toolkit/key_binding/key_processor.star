def KeyPress:
    """

        :param key: A `Keys` instance or text (one character).
        :param data: The received string on stdin. (Often vt100 escape codes.)
    
    """
    def __init__(self, key: Union[Keys, str], data: Optional[str] = None) -> None:
        """
         'key' is a one character string.
        """
    def __repr__(self) -> str:
        """
        %s(key=%r, data=%r)
        """
    def __eq__(self, other: object) -> bool:
        """

        Helper object to indicate flush operation in the KeyProcessor.
        NOTE: the implementation is very similar to the VT100 parser.

        """
def KeyProcessor:
    """

        Statemachine that receives :class:`KeyPress` instances and according to the
        key bindings in the given :class:`KeyBindings`, calls the matching handlers.

        ::

            p = KeyProcessor(key_bindings)

            # Send keys into the processor.
            p.feed(KeyPress(Keys.ControlX, '\x18'))
            p.feed(KeyPress(Keys.ControlC, '\x03')

            # Process all the keys in the queue.
            p.process_keys()

            # Now the ControlX-ControlC callback will be called if this sequence is
            # registered in the key bindings.

        :param key_bindings: `KeyBindingsBase` instance.
    
    """
    def __init__(self, key_bindings: KeyBindingsBase) -> None:
        """
         The queue of keys not yet send to our _process generator/state machine.

        """
    def _get_matches(self, key_presses: List[KeyPress]) -> List[Binding]:
        """

                For a list of :class:`KeyPress` instances. Give the matching handlers
                that would handle this.
        
        """
    def _is_prefix_of_longer_match(self, key_presses: List[KeyPress]) -> bool:
        """

                For a list of :class:`KeyPress` instances. Return True if there is any
                handler that is bound to a suffix of this keys.
        
        """
    def _process(self) -> Generator[None, KeyPress, None]:
        """

                Coroutine implementing the key match algorithm. Key strokes are sent
                into this generator, and it calls the appropriate handlers.
        
        """
    def feed(self, key_press: KeyPress, first: bool = False) -> None:
        """

                Add a new :class:`KeyPress` to the input queue.
                (Don't forget to call `process_keys` in order to process the queue.)

                :param first: If true, insert before everything else.
        
        """
    def feed_multiple(self, key_presses: List[KeyPress], first: bool = False) -> None:
        """

                :param first: If true, insert before everything else.
        
        """
    def process_keys(self) -> None:
        """

                Process all the keys in the `input_queue`.
                (To be called after `feed`.)

                Note: because of the `feed`/`process_keys` separation, it is
                      possible to call `feed` from inside a key binding.
                      This function keeps looping until the queue is empty.
        
        """
        def not_empty() -> bool:
            """
             When the application result is set, stop processing keys.  (E.g.
             if ENTER was received, followed by a few additional key strokes,
             leave the other keys in the queue.)

            """
        def get_next() -> KeyPress:
            """
             Only process CPR responses. Everything else is typeahead.

            """
    def empty_queue(self) -> List[KeyPress]:
        """

                Empty the input queue. Return the unprocessed input.
        
        """
    def _call_handler(self, handler: Binding, key_sequence: List[KeyPress]) -> None:
        """
         Save the state of the current buffer.

        """
    def _fix_vi_cursor_position(self, event: "KeyPressEvent") -> None:
        """

                After every command, make sure that if we are in Vi navigation mode, we
                never put the cursor after the last character of a line. (Unless it's
                an empty line.)
        
        """
    def _leave_vi_temp_navigation_mode(self, event: "KeyPressEvent") -> None:
        """

                If we're in Vi temporary navigation (normal) mode, return to
                insert/replace mode after executing one action.
        
        """
    def _start_timeout(self) -> None:
        """

                Start auto flush timeout. Similar to Vim's `timeoutlen` option.

                Start a background coroutine with a timer. When this timeout expires
                and no key was pressed in the meantime, we flush all data in the queue
                and call the appropriate key binding handlers.
        
        """
        async def wait() -> None:
                """
                 Wait for timeout. 
                """
        def flush_keys() -> None:
            """
             Flush keys. 
            """
def KeyPressEvent:
    """

        Key press event, delivered to key bindings.

        :param key_processor_ref: Weak reference to the `KeyProcessor`.
        :param arg: Repetition argument.
        :param key_sequence: List of `KeyPress` instances.
        :param previouskey_sequence: Previous list of `KeyPress` instances.
        :param is_repeat: True when the previous event was delivered to the same handler.
    
    """
2021-03-02 20:51:44,300 : INFO : tokenize_signature : --> do i ever get here?
2021-03-02 20:51:44,300 : INFO : tokenize_signature : --> do i ever get here?
2021-03-02 20:51:44,300 : INFO : tokenize_signature : --> do i ever get here?
2021-03-02 20:51:44,300 : INFO : tokenize_signature : --> do i ever get here?
2021-03-02 20:51:44,300 : INFO : tokenize_signature : --> do i ever get here?
2021-03-02 20:51:44,300 : INFO : tokenize_signature : --> do i ever get here?
2021-03-02 20:51:44,300 : INFO : tokenize_signature : --> do i ever get here?
    def __init__(
        self,
        key_processor_ref: "weakref.ReferenceType[KeyProcessor]",
        arg: Optional[str],
        key_sequence: List[KeyPress],
        previous_key_sequence: List[KeyPress],
        is_repeat: bool,
    ) -> None:
        """
        : True when the previous key sequence was handled by the same handler.

        """
    def __repr__(self) -> str:
        """
        KeyPressEvent(arg=%r, key_sequence=%r, is_repeat=%r)
        """
    def data(self) -> str:
        """
        KeyProcessor was lost. This should not happen.
        """
    def app(self) -> "Application[Any]":
        """

                The current `Application` object.
        
        """
    def current_buffer(self) -> "Buffer":
        """

                The current buffer.
        
        """
    def arg(self) -> int:
        """

                Repetition argument.
        
        """
    def arg_present(self) -> bool:
        """

                True if repetition argument was explicitly provided.
        
        """
    def append_to_arg_count(self, data: str) -> None:
        """

                Add digit to the input argument.

                :param data: the typed digit as string
        
        """
    def cli(self) -> "Application":
        """
         For backward-compatibility. 
        """
