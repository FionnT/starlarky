def register(name: str) -> Callable[[_T], _T]:
    """

        Store handler in the `_readline_commands` dictionary.
    
    """
    def decorator(handler: _T) -> _T:
        """
         `handler` is a callable or Binding. 
        """
def get_by_name(name: str) -> Binding:
    """

        Return the handler for the (Readline) command with the given name.
    
    """
def beginning_of_buffer(event: E) -> None:
    """

        Move to the start of the buffer.
    
    """
def end_of_buffer(event: E) -> None:
    """

        Move to the end of the buffer.
    
    """
def beginning_of_line(event: E) -> None:
    """

        Move to the start of the current line.
    
    """
def end_of_line(event: E) -> None:
    """

        Move to the end of the line.
    
    """
def forward_char(event: E) -> None:
    """

        Move forward a character.
    
    """
def backward_char(event: E) -> None:
    """
     Move back a character. 
    """
def forward_word(event: E) -> None:
    """

        Move forward to the end of the next word. Words are composed of letters and
        digits.
    
    """
def backward_word(event: E) -> None:
    """

        Move back to the start of the current or previous word. Words are composed
        of letters and digits.
    
    """
def clear_screen(event: E) -> None:
    """

        Clear the screen and redraw everything at the top of the screen.
    
    """
def redraw_current_line(event: E) -> None:
    """

        Refresh the current line.
        (Readline defines this command, but prompt-toolkit doesn't have it.)
    
    """
def accept_line(event: E) -> None:
    """

        Accept the line regardless of where the cursor is.
    
    """
def previous_history(event: E) -> None:
    """

        Move `back` through the history list, fetching the previous command.
    
    """
def next_history(event: E) -> None:
    """

        Move `forward` through the history list, fetching the next command.
    
    """
def beginning_of_history(event: E) -> None:
    """

        Move to the first line in the history.
    
    """
def end_of_history(event: E) -> None:
    """

        Move to the end of the input history, i.e., the line currently being entered.
    
    """
def reverse_search_history(event: E) -> None:
    """

        Search backward starting at the current line and moving `up` through
        the history as necessary. This is an incremental search.
    
    """
def end_of_file(event: E) -> None:
    """

        Exit.
    
    """
def delete_char(event: E) -> None:
    """

        Delete character before the cursor.
    
    """
def backward_delete_char(event: E) -> None:
    """

        Delete the character behind the cursor.
    
    """
def self_insert(event: E) -> None:
    """

        Insert yourself.
    
    """
def transpose_chars(event: E) -> None:
    """

        Emulate Emacs transpose-char behavior: at the beginning of the buffer,
        do nothing.  At the end of a line or buffer, swap the characters before
        the cursor.  Otherwise, move the cursor right, and then swap the
        characters before the cursor.
    
    """
def uppercase_word(event: E) -> None:
    """

        Uppercase the current (or following) word.
    
    """
def downcase_word(event: E) -> None:
    """

        Lowercase the current (or following) word.
    
    """
def capitalize_word(event: E) -> None:
    """

        Capitalize the current (or following) word.
    
    """
def quoted_insert(event: E) -> None:
    """

        Add the next character typed to the line verbatim. This is how to insert
        key sequences like C-q, for example.
    
    """
def kill_line(event: E) -> None:
    """

        Kill the text from the cursor to the end of the line.

        If we are at the end of the line, this should remove the newline.
        (That way, it is possible to delete multiple lines by executing this
        command multiple times.)
    
    """
def kill_word(event: E) -> None:
    """

        Kill from point to the end of the current word, or if between words, to the
        end of the next word. Word boundaries are the same as forward-word.
    
    """
def unix_word_rubout(event: E, WORD: bool = True) -> None:
    """

        Kill the word behind point, using whitespace as a word boundary.
        Usually bound to ControlW.
    
    """
def backward_kill_word(event: E) -> None:
    """

        Kills the word before point, using "not a letter nor a digit" as a word boundary.
        Usually bound to M-Del or M-Backspace.
    
    """
def delete_horizontal_space(event: E) -> None:
    """

        Delete all spaces and tabs around point.
    
    """
def unix_line_discard(event: E) -> None:
    """

        Kill backward from the cursor to the beginning of the current line.
    
    """
def yank(event: E) -> None:
    """

        Paste before cursor.
    
    """
def yank_nth_arg(event: E) -> None:
    """

        Insert the first argument of the previous command. With an argument, insert
        the nth word from the previous command (start counting at 0).
    
    """
def yank_last_arg(event: E) -> None:
    """

        Like `yank_nth_arg`, but if no argument has been given, yank the last word
        of each line.
    
    """
def yank_pop(event: E) -> None:
    """

        Rotate the kill ring, and yank the new top. Only works following yank or
        yank-pop.
    
    """
def complete(event: E) -> None:
    """

        Attempt to perform completion.
    
    """
def menu_complete(event: E) -> None:
    """

        Generate completions, or go to the next completion. (This is the default
        way of completing input in prompt_toolkit.)
    
    """
def menu_complete_backward(event: E) -> None:
    """

        Move backward through the list of possible completions.
    
    """
def start_kbd_macro(event: E) -> None:
    """

        Begin saving the characters typed into the current keyboard macro.
    
    """
def end_kbd_macro(event: E) -> None:
    """

        Stop saving the characters typed into the current keyboard macro and save
        the definition.
    
    """
def call_last_kbd_macro(event: E) -> None:
    """

        Re-execute the last keyboard macro defined, by making the characters in the
        macro appear as if typed at the keyboard.

        Notice that we pass `record_in_macro=False`. This ensures that the 'c-x e'
        key sequence doesn't appear in the recording itself. This function inserts
        the body of the called macro back into the KeyProcessor, so these keys will
        be added later on to the macro of their handlers have `record_in_macro=True`.
    
    """
def print_last_kbd_macro(event: E) -> None:
    """

        Print the last keyboard macro.
    
    """
    def print_macro() -> None:
        """

         Miscellaneous Commands.




        """
def undo(event: E) -> None:
    """

        Incremental undo.
    
    """
def insert_comment(event: E) -> None:
    """

        Without numeric argument, comment all lines.
        With numeric argument, uncomment all lines.
        In any case accept the input.
    
    """
        def change(line: str) -> str:
            """

            """
        def change(line: str) -> str:
            """

            """
def vi_editing_mode(event: E) -> None:
    """

        Switch to Vi editing mode.
    
    """
def emacs_editing_mode(event: E) -> None:
    """

        Switch to Emacs editing mode.
    
    """
def prefix_meta(event: E) -> None:
    """

        Metafy the next character typed. This is for keyboards without a meta key.

        Sometimes people also want to bind other keys to Meta, e.g. 'jj'::

            key_bindings.add_key_binding('j', 'j', filter=ViInsertMode())(prefix_meta)
    
    """
def operate_and_get_next(event: E) -> None:
    """

        Accept the current line for execution and fetch the next line relative to
        the current line from the history for editing.
    
    """
    def set_working_index() -> None:
        """
        edit-and-execute-command
        """
def edit_and_execute(event: E) -> None:
    """

        Invoke an editor on the current command line, and accept the result.
    
    """
