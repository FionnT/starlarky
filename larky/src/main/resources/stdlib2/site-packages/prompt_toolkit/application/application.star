def Application(Generic[_AppResult]):
    """

        The main Application class!
        This glues everything together.

        :param layout: A :class:`~prompt_toolkit.layout.Layout` instance.
        :param key_bindings:
            :class:`~prompt_toolkit.key_binding.KeyBindingsBase` instance for
            the key bindings.
        :param clipboard: :class:`~prompt_toolkit.clipboard.Clipboard` to use.
        :param on_abort: What to do when Control-C is pressed.
        :param on_exit: What to do when Control-D is pressed.
        :param full_screen: When True, run the application on the alternate screen buffer.
        :param color_depth: Any :class:`~.ColorDepth` value, a callable that
            returns a :class:`~.ColorDepth` or `None` for default.
        :param erase_when_done: (bool) Clear the application output when it finishes.
        :param reverse_vi_search_direction: Normally, in Vi mode, a '/' searches
            forward and a '?' searches backward. In Readline mode, this is usually
            reversed.
        :param min_redraw_interval: Number of seconds to wait between redraws. Use
            this for applications where `invalidate` is called a lot. This could cause
            a lot of terminal output, which some terminals are not able to process.

            `None` means that every `invalidate` will be scheduled right away
            (which is usually fine).

            When one `invalidate` is called, but a scheduled redraw of a previous
            `invalidate` call has not been executed yet, nothing will happen in any
            case.

        :param max_render_postpone_time: When there is high CPU (a lot of other
            scheduled calls), postpone the rendering max x seconds.  '0' means:
            don't postpone. '.5' means: try to draw at least twice a second.

        :param refresh_interval: Automatically invalidate the UI every so many
            seconds. When `None` (the default), only invalidate when `invalidate`
            has been called.

        Filters:

        :param mouse_support: (:class:`~prompt_toolkit.filters.Filter` or
            boolean). When True, enable mouse support.
        :param paste_mode: :class:`~prompt_toolkit.filters.Filter` or boolean.
        :param editing_mode: :class:`~prompt_toolkit.enums.EditingMode`.

        :param enable_page_navigation_bindings: When `True`, enable the page
            navigation key bindings. These include both Emacs and Vi bindings like
            page-up, page-down and so on to scroll through pages. Mostly useful for
            creating an editor or other full screen applications. Probably, you
            don't want this for the implementation of a REPL. By default, this is
            enabled if `full_screen` is set.

        Callbacks (all of these should accept an
        :class:`~prompt_toolkit.application.Application` object as input.)

        :param on_reset: Called during reset.
        :param on_invalidate: Called when the UI has been invalidated.
        :param before_render: Called right before rendering.
        :param after_render: Called right after rendering.

        I/O:
        (Note that the preferred way to change the input/output is by creating an
        `AppSession` with the required input/output objects. If you need multiple
        applications running at the same time, you have to create a separate
        `AppSession` using a `with create_app_session():` block.

        :param input: :class:`~prompt_toolkit.input.Input` instance.
        :param output: :class:`~prompt_toolkit.output.Output` instance. (Probably
                       Vt100_Output or Win32Output.)

        Usage:

            app = Application(...)
            app.run()

            # Or
            await app.run_async()
    
    """
2021-03-02 20:51:54,229 : INFO : tokenize_signature : --> do i ever get here?
2021-03-02 20:51:54,229 : INFO : tokenize_signature : --> do i ever get here?
2021-03-02 20:51:54,230 : INFO : tokenize_signature : --> do i ever get here?
2021-03-02 20:51:54,230 : INFO : tokenize_signature : --> do i ever get here?
2021-03-02 20:51:54,230 : INFO : tokenize_signature : --> do i ever get here?
2021-03-02 20:51:54,230 : INFO : tokenize_signature : --> do i ever get here?
2021-03-02 20:51:54,230 : INFO : tokenize_signature : --> do i ever get here?
2021-03-02 20:51:54,230 : INFO : tokenize_signature : --> do i ever get here?
2021-03-02 20:51:54,230 : INFO : tokenize_signature : --> do i ever get here?
2021-03-02 20:51:54,230 : INFO : tokenize_signature : --> do i ever get here?
2021-03-02 20:51:54,230 : INFO : tokenize_signature : --> do i ever get here?
2021-03-02 20:51:54,230 : INFO : tokenize_signature : --> do i ever get here?
2021-03-02 20:51:54,230 : INFO : tokenize_signature : --> do i ever get here?
2021-03-02 20:51:54,230 : INFO : tokenize_signature : --> do i ever get here?
2021-03-02 20:51:54,230 : INFO : tokenize_signature : --> do i ever get here?
2021-03-02 20:51:54,231 : INFO : tokenize_signature : --> do i ever get here?
2021-03-02 20:51:54,231 : INFO : tokenize_signature : --> do i ever get here?
2021-03-02 20:51:54,231 : INFO : tokenize_signature : --> do i ever get here?
2021-03-02 20:51:54,231 : INFO : tokenize_signature : --> do i ever get here?
2021-03-02 20:51:54,231 : INFO : tokenize_signature : --> do i ever get here?
2021-03-02 20:51:54,231 : INFO : tokenize_signature : --> do i ever get here?
2021-03-02 20:51:54,231 : INFO : tokenize_signature : --> do i ever get here?
2021-03-02 20:51:54,231 : INFO : tokenize_signature : --> do i ever get here?
2021-03-02 20:51:54,231 : INFO : tokenize_signature : --> do i ever get here?
2021-03-02 20:51:54,231 : INFO : tokenize_signature : --> do i ever get here?
2021-03-02 20:51:54,232 : INFO : tokenize_signature : --> do i ever get here?
2021-03-02 20:51:54,232 : INFO : tokenize_signature : --> do i ever get here?
2021-03-02 20:51:54,232 : INFO : tokenize_signature : --> do i ever get here?
2021-03-02 20:51:54,232 : INFO : tokenize_signature : --> do i ever get here?
2021-03-02 20:51:54,232 : INFO : tokenize_signature : --> do i ever get here?
    def __init__(
        self,
        layout: Optional[Layout] = None,
        style: Optional[BaseStyle] = None,
        include_default_pygments_style: FilterOrBool = True,
        style_transformation: Optional[StyleTransformation] = None,
        key_bindings: Optional[KeyBindingsBase] = None,
        clipboard: Optional[Clipboard] = None,
        full_screen: bool = False,
        color_depth: Union[
            ColorDepth, Callable[[], Union[ColorDepth, None]], None
        ] = None,
        mouse_support: FilterOrBool = False,
        enable_page_navigation_bindings: Optional[
            FilterOrBool
        ] = None,  # Can be None, True or False.
        paste_mode: FilterOrBool = False,
        editing_mode: EditingMode = EditingMode.EMACS,
        erase_when_done: bool = False,
        reverse_vi_search_direction: FilterOrBool = False,
        min_redraw_interval: Union[float, int, None] = None,
        max_render_postpone_time: Union[float, int, None] = 0.01,
        refresh_interval: Optional[float] = None,
        on_reset: Optional[ApplicationEventHandler] = None,
        on_invalidate: Optional[ApplicationEventHandler] = None,
        before_render: Optional[ApplicationEventHandler] = None,
        after_render: Optional[ApplicationEventHandler] = None,
        # I/O.
        input: Optional[Input] = None,
        output: Optional[Output] = None,
    ):
        """
         If `enable_page_navigation_bindings` is not specified, enable it in
         case of full screen applications only. This can be overridden by the user.

        """
    def _create_merged_style(self, include_default_pygments_style: Filter) -> BaseStyle:
        """

                Create a `Style` object that merges the default UI style, the default
                pygments style, and the custom user style.
        
        """
        def conditional_pygments_style() -> BaseStyle:
            """

                    The active :class:`.ColorDepth`.

                    The current value is determined as follows:
                    - If a color depth was given explicitely to this application, use that
                      value.
                    - Otherwise, fall back to the color depth that is reported by the
                      :class:`.Output` implementation. If the :class:`.Output` class was
                      created using `output.defaults.create_output`, then this value is
                      coming from the $PROMPT_TOOLKIT_COLOR_DEPTH environment variable.
        
            """
    def current_buffer(self) -> Buffer:
        """

                The currently focused :class:`~.Buffer`.

                (This returns a dummy :class:`.Buffer` when none of the actual buffers
                has the focus. In this case, it's really not practical to check for
                `None` values or catch exceptions every time.)
        
        """
    def current_search_state(self) -> SearchState:
        """

                Return the current :class:`.SearchState`. (The one for the focused
                :class:`.BufferControl`.)
        
        """
    def reset(self) -> None:
        """

                Reset everything, for reading the next input.
        
        """
    def invalidate(self) -> None:
        """

                Thread safe way of sending a repaint trigger to the input event loop.
        
        """
        def redraw() -> None:
            """
             When a minimum redraw interval is set, wait minimum this amount
             of time between redraws.

            """
                async def redraw_in_future() -> None:
                        """
                         True when a redraw operation has been scheduled. 
                        """
    def _redraw(self, render_as_done: bool = False) -> None:
        """

                Render the command line again. (Not thread safe!) (From other threads,
                or if unsure, use :meth:`.Application.invalidate`.)

                :param render_as_done: make sure to put the cursor after the UI.
        
        """
        def run_in_context() -> None:
            """
             Only draw when no sub application was started.

            """
    def _start_auto_refresh_task(self) -> None:
        """

                Start a while/true loop in the background for automatic invalidation of
                the UI.
        
        """
            async def auto_refresh(refresh_interval) -> None:
                    """

                            Make sure to attach 'invalidate' handlers to all invalidate events in
                            the UI.
        
                    """
        def gather_events() -> Iterable[Event[object]]:
            """

                    Handler for invalidate events coming from UIControls.

                    (This handles the difference in signature between event handler and
                    `self.invalidate`. It also needs to be a method -not a nested
                    function-, so that we can remove it again .)
        
            """
    def _on_resize(self) -> None:
        """

                When the window size changes, we erase the current output and request
                again the cursor position. When the CPR answer arrives, the output is
                drawn again.
        
        """
    def _pre_run(self, pre_run: Optional[Callable[[], None]] = None) -> None:
        """
         Called during `run`. 
        """
2021-03-02 20:51:54,239 : INFO : tokenize_signature : --> do i ever get here?
2021-03-02 20:51:54,239 : INFO : tokenize_signature : --> do i ever get here?
2021-03-02 20:51:54,239 : INFO : tokenize_signature : --> do i ever get here?
2021-03-02 20:51:54,239 : INFO : tokenize_signature : --> do i ever get here?
    async def run_async(
        self,
        pre_run: Optional[Callable[[], None]] = None,
        set_exception_handler: bool = True,
    ) -> _AppResult:
            """

                    Run the prompt_toolkit :class:`~prompt_toolkit.application.Application`
                    until :meth:`~prompt_toolkit.application.Application.exit` has been
                    called. Return the value that was passed to
                    :meth:`~prompt_toolkit.application.Application.exit`.

                    This is the main entry point for a prompt_toolkit
                    :class:`~prompt_toolkit.application.Application` and usually the only
                    place where the event loop is actually running.

                    :param pre_run: Optional callable, which is called right after the
                        "reset" of the application.
                    :param set_exception_handler: When set, in case of an exception, go out
                        of the alternate screen and hide the application, display the
                        exception, and wait for the user to press ENTER.
        
            """
        async def _run_async() -> _AppResult:
                """
                 Coroutine. 
                """
            def read_from_input() -> None:
                """
                 Ignore when we aren't running anymore. This callback will
                 removed from the loop next time. (It could be that it was
                 still in the 'tasks' list of the loop.)
                 Except: if we need to process incoming CPRs.

                """
            async def auto_flush_input() -> None:
                    """
                     Flush input after timeout.
                     (Used for flushing the enter key.)
                     This sleep can be cancelled, in that case we won't flush yet.

                    """
            def flush_input() -> None:
                """
                 Get keys, and feed to key processor.

                """
        async def _run_async2() -> _AppResult:
                """
                 Make sure to set `_invalidated` to `False` to begin with,
                 otherwise we're not going to paint anything. This can happen if
                 this application had run before on a different event loop, and a
                 paint was scheduled using `call_soon_threadsafe` with
                 `max_postpone_time`.

                """
2021-03-02 20:51:54,242 : INFO : tokenize_signature : --> do i ever get here?
2021-03-02 20:51:54,242 : INFO : tokenize_signature : --> do i ever get here?
2021-03-02 20:51:54,242 : INFO : tokenize_signature : --> do i ever get here?
2021-03-02 20:51:54,242 : INFO : tokenize_signature : --> do i ever get here?
    def run(
        self,
        pre_run: Optional[Callable[[], None]] = None,
        set_exception_handler: bool = True,
    ) -> _AppResult:
        """

                A blocking 'run' call that waits until the UI is finished.

                This will start the current asyncio event loop. If no loop is set for
                the current thread, then it will create a new loop.

                :param pre_run: Optional callable, which is called right after the
                    "reset" of the application.
                :param set_exception_handler: When set, in case of an exception, go out
                    of the alternate screen and hide the application, display the
                    exception, and wait for the user to press ENTER.
        
        """
2021-03-02 20:51:54,243 : INFO : tokenize_signature : --> do i ever get here?
2021-03-02 20:51:54,243 : INFO : tokenize_signature : --> do i ever get here?
    def _handle_exception(
        self, loop: AbstractEventLoop, context: Dict[str, Any]
    ) -> None:
        """

                Handler for event loop exceptions.
                This will print the exception, using run_in_terminal.
        
        """
        async def in_term() -> None:
                """
                 Print output. Similar to 'loop.default_exception_handler',
                 but don't use logger. (This works better on Python 2.)

                """
2021-03-02 20:51:54,243 : INFO : tokenize_signature : --> do i ever get here?
2021-03-02 20:51:54,243 : INFO : tokenize_signature : --> do i ever get here?
    def create_background_task(
        self, coroutine: Awaitable[None]
    ) -> "asyncio.Task[None]":
        """

                Start a background task (coroutine) for the running application.
                If asyncio had nurseries like Trio, we would create a nursery in
                `Application.run_async`, and run the given coroutine in that nursery.
        
        """
    async def cancel_and_wait_for_background_tasks(self) -> None:
            """

                    Cancel all background tasks, and wait for the cancellation to be done.
                    If any of the background tasks raised an exception, this will also
                    propagate the exception.

                    (If we had nurseries like Trio, this would be the `__aexit__` of a
                    nursery.)
        
            """
    def cpr_not_supported_callback(self) -> None:
        """

                Called when we don't receive the cursor position response in time.
        
        """
        def in_terminal() -> None:
            """
            WARNING: your terminal doesn't support cursor position requests (CPR).\r\n

            """
    def exit(self) -> None:
        """
         Exit without arguments. 
        """
    def exit(self, *, result: _AppResult, style: str = "") -> None:
        """
         Exit with `_AppResult`. 
        """
2021-03-02 20:51:54,244 : INFO : tokenize_signature : --> do i ever get here?
2021-03-02 20:51:54,244 : INFO : tokenize_signature : --> do i ever get here?
    def exit(
        self, *, exception: Union[BaseException, Type[BaseException]], style: str = ""
    ) -> None:
        """
         Exit with exception. 
        """
2021-03-02 20:51:54,245 : INFO : tokenize_signature : --> do i ever get here?
2021-03-02 20:51:54,245 : INFO : tokenize_signature : --> do i ever get here?
2021-03-02 20:51:54,245 : INFO : tokenize_signature : --> do i ever get here?
2021-03-02 20:51:54,245 : INFO : tokenize_signature : --> do i ever get here?
2021-03-02 20:51:54,245 : INFO : tokenize_signature : --> do i ever get here?
    def exit(
        self,
        result: Optional[_AppResult] = None,
        exception: Optional[Union[BaseException, Type[BaseException]]] = None,
        style: str = "",
    ) -> None:
        """

                Exit application.

                :param result: Set this result for the application.
                :param exception: Set this exception as the result for an application. For
                    a prompt, this is often `EOFError` or `KeyboardInterrupt`.
                :param style: Apply this style on the whole content when quitting,
                    often this is 'class:exiting' for a prompt. (Used when
                    `erase_when_done` is not set.)
        
        """
    def _request_absolute_cursor_position(self) -> None:
        """

                Send CPR request.
        
        """
2021-03-02 20:51:54,246 : INFO : tokenize_signature : --> do i ever get here?
2021-03-02 20:51:54,246 : INFO : tokenize_signature : --> do i ever get here?
2021-03-02 20:51:54,246 : INFO : tokenize_signature : --> do i ever get here?
2021-03-02 20:51:54,246 : INFO : tokenize_signature : --> do i ever get here?
2021-03-02 20:51:54,246 : INFO : tokenize_signature : --> do i ever get here?
2021-03-02 20:51:54,246 : INFO : tokenize_signature : --> do i ever get here?
    async def run_system_command(
        self,
        command: str,
        wait_for_enter: bool = True,
        display_before_text: AnyFormattedText = "",
        wait_text: str = "Press ENTER to continue...",
    ) -> None:
            """

                    Run system command (While hiding the prompt. When finished, all the
                    output will scroll above the prompt.)

                    :param command: Shell command to be executed.
                    :param wait_for_enter: FWait for the user to press enter, when the
                        command is finished.
                    :param display_before_text: If given, text to be displayed before the
                        command executes.
                    :return: A `Future` object.
        
            """
            def run_command() -> None:
                """
                 Wait for the user to press enter.

                """
    def suspend_to_background(self, suspend_group: bool = True) -> None:
        """

                (Not thread safe -- to be called from inside the key bindings.)
                Suspend process.

                :param suspend_group: When true, suspend the whole process group.
                    (This is the default, and probably what you want.)
        
        """
            def run() -> None:
                """
                 Send `SIGTSTP` to own process.
                 This will cause it to suspend.

                 Usually we want the whole process group to be suspended. This
                 handles the case when input is piped from another process.

                """
2021-03-02 20:51:54,247 : INFO : tokenize_signature : --> do i ever get here?
2021-03-02 20:51:54,248 : INFO : tokenize_signature : --> do i ever get here?
    def print_text(
        self, text: AnyFormattedText, style: Optional[BaseStyle] = None
    ) -> None:
        """

                Print a list of (style_str, text) tuples to the output.
                (When the UI is running, this method has to be called through
                `run_in_terminal`, otherwise it will destroy the UI.)

                :param text: List of ``(style_str, text)`` tuples.
                :param style: Style class to use. Defaults to the active style in the CLI.
        
        """
    def is_running(self) -> bool:
        """
         `True` when the application is currently active/running. 
        """
    def is_done(self) -> bool:
        """

                Return a list of used style strings. This is helpful for debugging, and
                for writing a new `Style`.
        
        """
def _CombinedRegistry(KeyBindingsBase):
    """

        The `KeyBindings` of key bindings for a `Application`.
        This merges the global key bindings with the one of the current user
        control.
    
    """
    def __init__(self, app: Application[_AppResult]) -> None:
        """
        Not needed - this object is not going to be wrapped in another
                KeyBindings object.
        """
    def bindings(self) -> List[Binding]:
        """
        Not needed - this object is not going to be wrapped in another
                KeyBindings object.
        """
2021-03-02 20:51:54,249 : INFO : tokenize_signature : --> do i ever get here?
2021-03-02 20:51:54,249 : INFO : tokenize_signature : --> do i ever get here?
    def _create_key_bindings(
        self, current_window: Window, other_controls: List[UIControl]
    ) -> KeyBindingsBase:
        """

                Create a `KeyBindings` object that merges the `KeyBindings` from the
                `UIControl` with all the parent controls and the global key bindings.
        
        """
    def _key_bindings(self) -> KeyBindingsBase:
        """

            Create a sub application to wait for the enter key press.
            This has two advantages over using 'input'/'raw_input':
            - This will share the same input/output I/O.
            - This doesn't block the event loop.
    
        """
    def _ok(event: E) -> None:
        """
         Disallow typing. 
        """
2021-03-02 20:51:54,252 : INFO : tokenize_signature : --> do i ever get here?
2021-03-02 20:51:54,252 : INFO : tokenize_signature : --> do i ever get here?
def attach_winch_signal_handler(
    handler: Callable[[], None]
) -> Generator[None, None, None]:
    """

        Attach the given callback as a WINCH signal handler within the context
        manager. Restore the original signal handler when done.

        The `Application.run` method will register SIGWINCH, so that it will
        properly repaint when the terminal window resizes. However, using
        `run_in_terminal`, we can temporarily send an application to the
        background, and run an other app in between, which will then overwrite the
        SIGWINCH. This is why it's important to restore the handler when the app
        terminates.
    
    """
