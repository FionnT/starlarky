def EditReadOnlyBuffer(Exception):
    """
     Attempt editing of read-only :class:`.Buffer`. 
    """
def ValidationState(Enum):
    """
     The validation state of a buffer. This is set after the validation. 
    """
def CompletionState:
    """

        Immutable class that contains a completion state.
    
    """
2021-03-02 20:51:49,152 : INFO : tokenize_signature : --> do i ever get here?
2021-03-02 20:51:49,152 : INFO : tokenize_signature : --> do i ever get here?
2021-03-02 20:51:49,152 : INFO : tokenize_signature : --> do i ever get here?
2021-03-02 20:51:49,153 : INFO : tokenize_signature : --> do i ever get here?
2021-03-02 20:51:49,153 : INFO : tokenize_signature : --> do i ever get here?
    def __init__(
        self,
        original_document: "Document",
        completions: Optional[List["Completion"]] = None,
        complete_index: Optional[int] = None,
    ):
        """
        : Document as it was when the completion started.

        """
    def __repr__(self) -> str:
        """
        %s(%r, <%r> completions, index=%r)
        """
    def go_to_index(self, index: Optional[int]) -> None:
        """

                Create a new :class:`.CompletionState` object with the new index.

                When `index` is `None` deselect the completion.
        
        """
    def new_text_and_position(self) -> Tuple[str, int]:
        """

                Return (new_text, new_cursor_position) for this completion.
        
        """
    def current_completion(self) -> Optional["Completion"]:
        """

                Return the current completion, or return `None` when no completion is
                selected.
        
        """
def YankNthArgState:
    """

        For yank-last-arg/yank-nth-arg: Keep track of where we are in the history.
    
    """
2021-03-02 20:51:49,154 : INFO : tokenize_signature : --> do i ever get here?
2021-03-02 20:51:49,155 : INFO : tokenize_signature : --> do i ever get here?
    def __init__(
        self, history_position: int = 0, n: int = -1, previous_inserted_word: str = ""
    ):
        """
        %s(history_position=%r, n=%r, previous_inserted_word=%r)
        """
def Buffer:
    """

        The core data structure that holds the text and cursor position of the
        current input line and implements all text manipulations on top of it. It
        also implements the history, undo stack and the completion state.

        :param completer: :class:`~prompt_toolkit.completion.Completer` instance.
        :param history: :class:`~prompt_toolkit.history.History` instance.
        :param tempfile_suffix: The tempfile suffix (extension) to be used for the
            "open in editor" function. For a Python REPL, this would be ".py", so
            that the editor knows the syntax highlighting to use. This can also be
            a callable that returns a string.
        :param tempfile: For more advanced tempfile situations where you need
            control over the subdirectories and filename. For a Git Commit Message,
            this would be ".git/COMMIT_EDITMSG", so that the editor knows the syntax
            highlighting to use. This can also be a callable that returns a string.
        :param name: Name for this buffer. E.g. DEFAULT_BUFFER. This is mostly
            useful for key bindings where we sometimes prefer to refer to a buffer
            by their name instead of by reference.
        :param accept_handler: Called when the buffer input is accepted. (Usually
            when the user presses `enter`.) The accept handler receives this
            `Buffer` as input and should return True when the buffer text should be
            kept instead of calling reset.

            In case of a `PromptSession` for instance, we want to keep the text,
            because we will exit the application, and only reset it during the next
            run.

        Events:

        :param on_text_changed: When the buffer text changes. (Callable on None.)
        :param on_text_insert: When new text is inserted. (Callable on None.)
        :param on_cursor_position_changed: When the cursor moves. (Callable on None.)
        :param on_completions_changed: When the completions were changed. (Callable on None.)
        :param on_suggestion_set: When an auto-suggestion text has been set. (Callable on None.)

        Filters:

        :param complete_while_typing: :class:`~prompt_toolkit.filters.Filter`
            or `bool`. Decide whether or not to do asynchronous autocompleting while
            typing.
        :param validate_while_typing: :class:`~prompt_toolkit.filters.Filter`
            or `bool`. Decide whether or not to do asynchronous validation while
            typing.
        :param enable_history_search: :class:`~prompt_toolkit.filters.Filter` or
            `bool` to indicate when up-arrow partial string matching is enabled. It
            is advised to not enable this at the same time as
            `complete_while_typing`, because when there is an autocompletion found,
            the up arrows usually browse through the completions, rather than
            through the history.
        :param read_only: :class:`~prompt_toolkit.filters.Filter`. When True,
            changes will not be allowed.
        :param multiline: :class:`~prompt_toolkit.filters.Filter` or `bool`. When
            not set, pressing `Enter` will call the `accept_handler`.  Otherwise,
            pressing `Esc-Enter` is required.
    
    """
2021-03-02 20:51:49,155 : INFO : tokenize_signature : --> do i ever get here?
2021-03-02 20:51:49,155 : INFO : tokenize_signature : --> do i ever get here?
2021-03-02 20:51:49,155 : INFO : tokenize_signature : --> do i ever get here?
2021-03-02 20:51:49,156 : INFO : tokenize_signature : --> do i ever get here?
2021-03-02 20:51:49,156 : INFO : tokenize_signature : --> do i ever get here?
2021-03-02 20:51:49,156 : INFO : tokenize_signature : --> do i ever get here?
2021-03-02 20:51:49,156 : INFO : tokenize_signature : --> do i ever get here?
2021-03-02 20:51:49,156 : INFO : tokenize_signature : --> do i ever get here?
2021-03-02 20:51:49,156 : INFO : tokenize_signature : --> do i ever get here?
2021-03-02 20:51:49,156 : INFO : tokenize_signature : --> do i ever get here?
2021-03-02 20:51:49,156 : INFO : tokenize_signature : --> do i ever get here?
2021-03-02 20:51:49,156 : INFO : tokenize_signature : --> do i ever get here?
2021-03-02 20:51:49,156 : INFO : tokenize_signature : --> do i ever get here?
2021-03-02 20:51:49,157 : INFO : tokenize_signature : --> do i ever get here?
2021-03-02 20:51:49,157 : INFO : tokenize_signature : --> do i ever get here?
2021-03-02 20:51:49,157 : INFO : tokenize_signature : --> do i ever get here?
2021-03-02 20:51:49,157 : INFO : tokenize_signature : --> do i ever get here?
2021-03-02 20:51:49,157 : INFO : tokenize_signature : --> do i ever get here?
2021-03-02 20:51:49,157 : INFO : tokenize_signature : --> do i ever get here?
2021-03-02 20:51:49,157 : INFO : tokenize_signature : --> do i ever get here?
2021-03-02 20:51:49,157 : INFO : tokenize_signature : --> do i ever get here?
    def __init__(
        self,
        completer: Optional[Completer] = None,
        auto_suggest: Optional[AutoSuggest] = None,
        history: Optional[History] = None,
        validator: Optional[Validator] = None,
        tempfile_suffix: Union[str, Callable[[], str]] = "",
        tempfile: Union[str, Callable[[], str]] = "",
        name: str = "",
        complete_while_typing: FilterOrBool = False,
        validate_while_typing: FilterOrBool = False,
        enable_history_search: FilterOrBool = False,
        document: Optional[Document] = None,
        accept_handler: Optional[BufferAcceptHandler] = None,
        read_only: FilterOrBool = False,
        multiline: FilterOrBool = True,
        on_text_changed: Optional[BufferEventHandler] = None,
        on_text_insert: Optional[BufferEventHandler] = None,
        on_cursor_position_changed: Optional[BufferEventHandler] = None,
        on_completions_changed: Optional[BufferEventHandler] = None,
        on_suggestion_set: Optional[BufferEventHandler] = None,
    ):
        """
         Accept both filters and booleans as input.

        """
        def new_history_item(item: str) -> None:
            """
             XXX: Keep in mind that this function can be called in a different
                  thread!
             Insert the new string into `_working_lines`.

            """
    def __repr__(self) -> str:
        """
        ...
        """
2021-03-02 20:51:49,159 : INFO : tokenize_signature : --> do i ever get here?
2021-03-02 20:51:49,159 : INFO : tokenize_signature : --> do i ever get here?
    def reset(
        self, document: Optional[Document] = None, append_to_history: bool = False
    ) -> None:
        """

                :param append_to_history: Append current input to history first.
        
        """
    def _set_text(self, value: str) -> bool:
        """
         set text at current working_index. Return whether it changed. 
        """
    def _set_cursor_position(self, value: int) -> bool:
        """
         Set cursor position. Return whether it changed. 
        """
    def text(self) -> str:
        """

                Setting text. (When doing this, make sure that the cursor_position is
                valid for this text. text/cursor_position should be consistent at any time,
                otherwise set a Document instead.)
        
        """
    def cursor_position(self) -> int:
        """

                Setting cursor position.
        
        """
    def working_index(self) -> int:
        """
         Make sure to reset the cursor position, otherwise we end up in
         situations where the cursor position is out of the bounds of the
         text.

        """
    def _text_changed(self) -> None:
        """
         Remove any validation errors and complete state.

        """
    def _cursor_position_changed(self) -> None:
        """
         Remove any complete state.
         (Input validation should only be undone when the cursor position
         changes.)

        """
    def document(self) -> Document:
        """

                Return :class:`~prompt_toolkit.document.Document` instance from the
                current text, cursor position and selection state.
        
        """
    def document(self, value: Document) -> None:
        """

                Set :class:`~prompt_toolkit.document.Document` instance.

                This will set both the text and cursor position at the same time, but
                atomically. (Change events will be triggered only after both have been set.)
        
        """
    def set_document(self, value: Document, bypass_readonly: bool = False) -> None:
        """

                Set :class:`~prompt_toolkit.document.Document` instance. Like the
                ``document`` property, but accept an ``bypass_readonly`` argument.

                :param bypass_readonly: When True, don't raise an
                                        :class:`.EditReadOnlyBuffer` exception, even
                                        when the buffer is read-only.

                .. warning::

                    When this buffer is read-only and `bypass_readonly` was not passed,
                    the `EditReadOnlyBuffer` exception will be caught by the
                    `KeyProcessor` and is silently suppressed. This is important to
                    keep in mind when writing key bindings, because it won't do what
                    you expect, and there won't be a stack trace. Use try/finally
                    around this function if you need some cleanup code.
        
        """
    def is_returnable(self) -> bool:
        """

                True when there is something handling accept.
        
        """
    def save_to_undo_stack(self, clear_redo_stack: bool = True) -> None:
        """

                Safe current state (input text and cursor position), so that we can
                restore it by calling undo.
        
        """
2021-03-02 20:51:49,164 : INFO : tokenize_signature : --> do i ever get here?
2021-03-02 20:51:49,164 : INFO : tokenize_signature : --> do i ever get here?
2021-03-02 20:51:49,164 : INFO : tokenize_signature : --> do i ever get here?
2021-03-02 20:51:49,164 : INFO : tokenize_signature : --> do i ever get here?
    def transform_lines(
        self,
        line_index_iterator: Iterable[int],
        transform_callback: Callable[[str], str],
    ) -> str:
        """

                Transforms the text on a range of lines.
                When the iterator yield an index not in the range of lines that the
                document contains, it skips them silently.

                To uppercase some lines::

                    new_text = transform_lines(range(5,10), lambda text: text.upper())

                :param line_index_iterator: Iterator of line numbers (int)
                :param transform_callback: callable that takes the original text of a
                                           line, and return the new text for this line.

                :returns: The new text.
        
        """
    def transform_current_line(self, transform_callback: Callable[[str], str]) -> None:
        """

                Apply the given transformation function to the current line.

                :param transform_callback: callable that takes a string and return a new string.
        
        """
2021-03-02 20:51:49,165 : INFO : tokenize_signature : --> do i ever get here?
2021-03-02 20:51:49,165 : INFO : tokenize_signature : --> do i ever get here?
    def transform_region(
        self, from_: int, to: int, transform_callback: Callable[[str], str]
    ) -> None:
        """

                Transform a part of the input string.

                :param from_: (int) start position.
                :param to: (int) end position.
                :param transform_callback: Callable which accepts a string and returns
                    the transformed string.
        
        """
    def cursor_left(self, count: int = 1) -> None:
        """
         (for multiline edit). Move cursor to the previous line.  
        """
    def cursor_down(self, count: int = 1) -> None:
        """
         (for multiline edit). Move cursor to the next line.  
        """
2021-03-02 20:51:49,166 : INFO : tokenize_signature : --> do i ever get here?
2021-03-02 20:51:49,166 : INFO : tokenize_signature : --> do i ever get here?
    def auto_up(
        self, count: int = 1, go_to_start_of_line_if_history_changes: bool = False
    ) -> None:
        """

                If we're not on the first line (of a multiline input) go a line up,
                otherwise go back in history. (If nothing is selected.)
        
        """
2021-03-02 20:51:49,167 : INFO : tokenize_signature : --> do i ever get here?
2021-03-02 20:51:49,167 : INFO : tokenize_signature : --> do i ever get here?
    def auto_down(
        self, count: int = 1, go_to_start_of_line_if_history_changes: bool = False
    ) -> None:
        """

                If we're not on the last line (of a multiline input) go a line down,
                otherwise go forward in history. (If nothing is selected.)
        
        """
    def delete_before_cursor(self, count: int = 1) -> str:
        """

                Delete specified number of characters before cursor and return the
                deleted text.
        
        """
    def delete(self, count: int = 1) -> str:
        """

                Delete specified number of characters and Return the deleted text.
        
        """
    def join_next_line(self, separator: str = " ") -> None:
        """

                Join the next line to the current one by deleting the line ending after
                the current line.
        
        """
    def join_selected_lines(self, separator: str = " ") -> None:
        """

                Join the selected lines.
        
        """
    def swap_characters_before_cursor(self) -> None:
        """

                Swap the last two characters before the cursor.
        
        """
    def go_to_history(self, index: int) -> None:
        """

                Go to this item in the history.
        
        """
    def complete_next(self, count: int = 1, disable_wrap_around: bool = False) -> None:
        """

                Browse to the next completions.
                (Does nothing if there are no completion.)
        
        """
2021-03-02 20:51:49,170 : INFO : tokenize_signature : --> do i ever get here?
2021-03-02 20:51:49,170 : INFO : tokenize_signature : --> do i ever get here?
    def complete_previous(
        self, count: int = 1, disable_wrap_around: bool = False
    ) -> None:
        """

                Browse to the previous completions.
                (Does nothing if there are no completion.)
        
        """
    def cancel_completion(self) -> None:
        """

                Cancel completion, go back to the original text.
        
        """
    def _set_completions(self, completions: List[Completion]) -> CompletionState:
        """

                Start completions. (Generate list of completions and initialize.)

                By default, no completion will be selected.
        
        """
    def start_history_lines_completion(self) -> None:
        """

                Start a completion based on all the other lines in the document and the
                history.
        
        """
    def go_to_completion(self, index: Optional[int]) -> None:
        """

                Select a completion from the list of current completions.
        
        """
    def apply_completion(self, completion: Completion) -> None:
        """

                Insert a given completion.
        
        """
    def _set_history_search(self) -> None:
        """

                Set `history_search_text`.
                (The text before the cursor will be used for filtering the history.)
        
        """
    def _history_matches(self, i: int) -> bool:
        """

                True when the current entry matches the history search.
                (when we don't have history search, it's also True.)
        
        """
    def history_forward(self, count: int = 1) -> None:
        """

                Move forwards through the history.

                :param count: Amount of items to move forward.
        
        """
    def history_backward(self, count: int = 1) -> None:
        """

                Move backwards through history.
        
        """
2021-03-02 20:51:49,174 : INFO : tokenize_signature : --> do i ever get here?
2021-03-02 20:51:49,174 : INFO : tokenize_signature : --> do i ever get here?
    def yank_nth_arg(
        self, n: Optional[int] = None, _yank_last_arg: bool = False
    ) -> None:
        """

                Pick nth word from previous history entry (depending on current
                `yank_nth_arg_state`) and insert it at current position. Rotate through
                history if called repeatedly. If no `n` has been given, take the first
                argument. (The second word.)

                :param n: (None or int), The index of the word from the previous line
                    to take.
        
        """
    def yank_last_arg(self, n: Optional[int] = None) -> None:
        """

                Like `yank_nth_arg`, but if no argument has been given, yank the last
                word by default.
        
        """
2021-03-02 20:51:49,175 : INFO : tokenize_signature : --> do i ever get here?
2021-03-02 20:51:49,175 : INFO : tokenize_signature : --> do i ever get here?
    def start_selection(
        self, selection_type: SelectionType = SelectionType.CHARACTERS
    ) -> None:
        """

                Take the current cursor position as the start of this selection.
        
        """
    def copy_selection(self, _cut: bool = False) -> ClipboardData:
        """

                Copy selected text and return :class:`.ClipboardData` instance.

                Notice that this doesn't store the copied data on the clipboard yet.
                You can store it like this:

                .. code:: python

                    data = buffer.copy_selection()
                    get_app().clipboard.set_data(data)
        
        """
    def cut_selection(self) -> ClipboardData:
        """

                Delete selected text and return :class:`.ClipboardData` instance.
        
        """
2021-03-02 20:51:49,176 : INFO : tokenize_signature : --> do i ever get here?
2021-03-02 20:51:49,176 : INFO : tokenize_signature : --> do i ever get here?
2021-03-02 20:51:49,176 : INFO : tokenize_signature : --> do i ever get here?
2021-03-02 20:51:49,176 : INFO : tokenize_signature : --> do i ever get here?
2021-03-02 20:51:49,176 : INFO : tokenize_signature : --> do i ever get here?
    def paste_clipboard_data(
        self,
        data: ClipboardData,
        paste_mode: PasteMode = PasteMode.EMACS,
        count: int = 1,
    ) -> None:
        """

                Insert the data from the clipboard.
        
        """
    def newline(self, copy_margin: bool = True) -> None:
        """

                Insert a line ending at the current position.
        
        """
    def insert_line_above(self, copy_margin: bool = True) -> None:
        """

                Insert a new line above the current one.
        
        """
    def insert_line_below(self, copy_margin: bool = True) -> None:
        """

                Insert a new line below the current one.
        
        """
2021-03-02 20:51:49,178 : INFO : tokenize_signature : --> do i ever get here?
2021-03-02 20:51:49,178 : INFO : tokenize_signature : --> do i ever get here?
2021-03-02 20:51:49,178 : INFO : tokenize_signature : --> do i ever get here?
2021-03-02 20:51:49,178 : INFO : tokenize_signature : --> do i ever get here?
2021-03-02 20:51:49,178 : INFO : tokenize_signature : --> do i ever get here?
2021-03-02 20:51:49,178 : INFO : tokenize_signature : --> do i ever get here?
    def insert_text(
        self,
        data: str,
        overwrite: bool = False,
        move_cursor: bool = True,
        fire_event: bool = True,
    ) -> None:
        """

                Insert characters at cursor position.

                :param fire_event: Fire `on_text_insert` event. This is mainly used to
                    trigger autocompletion while typing.
        
        """
    def undo(self) -> None:
        """
         Pop from the undo-stack until we find a text that if different from
         the current text. (The current logic of `save_to_undo_stack` will
         cause that the top of the undo stack is usually the same as the
         current text, so in that case we have to pop twice.)

        """
    def redo(self) -> None:
        """
         Copy current state on undo stack.

        """
    def validate(self, set_cursor: bool = False) -> bool:
        """

                Returns `True` if valid.

                :param set_cursor: Set the cursor position, if an error was found.
        
        """
    async def _validate_async(self) -> None:
            """

                    Asynchronous version of `validate()`.
                    This one doesn't set the cursor position.

                    We have both variants, because a synchronous version is required.
                    Handling the ENTER key needs to be completely synchronous, otherwise
                    stuff like type-ahead is going to give very weird results. (People
                    could type input while the ENTER key is still processed.)

                    An asynchronous version is required if we have `validate_while_typing`
                    enabled.
        
            """
    def append_to_history(self) -> None:
        """

                Append the current input to the history.
        
        """
2021-03-02 20:51:49,181 : INFO : tokenize_signature : --> do i ever get here?
2021-03-02 20:51:49,181 : INFO : tokenize_signature : --> do i ever get here?
2021-03-02 20:51:49,181 : INFO : tokenize_signature : --> do i ever get here?
2021-03-02 20:51:49,181 : INFO : tokenize_signature : --> do i ever get here?
2021-03-02 20:51:49,181 : INFO : tokenize_signature : --> do i ever get here?
    def _search(
        self,
        search_state: SearchState,
        include_current_position: bool = False,
        count: int = 1,
    ) -> Optional[Tuple[int, int]]:
        """

                Execute search. Return (working_index, cursor_position) tuple when this
                search is applied. Returns `None` when this text cannot be found.
        
        """
2021-03-02 20:51:49,182 : INFO : tokenize_signature : --> do i ever get here?
2021-03-02 20:51:49,182 : INFO : tokenize_signature : --> do i ever get here?
        def search_once(
            working_index: int, document: Document
        ) -> Optional[Tuple[int, Document]]:
            """

                        Do search one time.
                        Return (working_index, document) or `None`
            
            """
    def document_for_search(self, search_state: SearchState) -> Document:
        """

                Return a :class:`~prompt_toolkit.document.Document` instance that has
                the text/cursor position for this search, if we would apply it. This
                will be used in the
                :class:`~prompt_toolkit.layout.BufferControl` to display feedback while
                searching.
        
        """
2021-03-02 20:51:49,184 : INFO : tokenize_signature : --> do i ever get here?
2021-03-02 20:51:49,184 : INFO : tokenize_signature : --> do i ever get here?
2021-03-02 20:51:49,184 : INFO : tokenize_signature : --> do i ever get here?
2021-03-02 20:51:49,184 : INFO : tokenize_signature : --> do i ever get here?
2021-03-02 20:51:49,184 : INFO : tokenize_signature : --> do i ever get here?
    def get_search_position(
        self,
        search_state: SearchState,
        include_current_position: bool = True,
        count: int = 1,
    ) -> int:
        """

                Get the cursor position for this search.
                (This operation won't change the `working_index`. It's won't go through
                the history. Vi text objects can't span multiple items.)
        
        """
2021-03-02 20:51:49,184 : INFO : tokenize_signature : --> do i ever get here?
2021-03-02 20:51:49,184 : INFO : tokenize_signature : --> do i ever get here?
2021-03-02 20:51:49,184 : INFO : tokenize_signature : --> do i ever get here?
2021-03-02 20:51:49,184 : INFO : tokenize_signature : --> do i ever get here?
2021-03-02 20:51:49,184 : INFO : tokenize_signature : --> do i ever get here?
    def apply_search(
        self,
        search_state: SearchState,
        include_current_position: bool = True,
        count: int = 1,
    ) -> None:
        """

                Apply search. If something is found, set `working_index` and
                `cursor_position`.
        
        """
    def exit_selection(self) -> None:
        """

                Simple (file) tempfile implementation.
                Return (tempfile, cleanup_func).
        
        """
        def cleanup() -> None:
            """
             Complex (directory) tempfile implementation.

            """
        def cleanup() -> None:
            """
            asyncio.Task[None]
            """
        async def run() -> None:
                """
                 Open in editor
                 (We need to use `run_in_terminal`, because not all editors go to
                 the alternate screen buffer, and some could influence the cursor
                 position.)

                """
    def _open_file_in_editor(self, filename: str) -> bool:
        """

                Call editor executable.

                Return True when we received a zero return code.
        
        """
2021-03-02 20:51:49,187 : INFO : tokenize_signature : --> do i ever get here?
2021-03-02 20:51:49,187 : INFO : tokenize_signature : --> do i ever get here?
2021-03-02 20:51:49,187 : INFO : tokenize_signature : --> do i ever get here?
2021-03-02 20:51:49,188 : INFO : tokenize_signature : --> do i ever get here?
2021-03-02 20:51:49,188 : INFO : tokenize_signature : --> do i ever get here?
2021-03-02 20:51:49,188 : INFO : tokenize_signature : --> do i ever get here?
    def start_completion(
        self,
        select_first: bool = False,
        select_last: bool = False,
        insert_common_part: bool = False,
        complete_event: Optional[CompleteEvent] = None,
    ) -> None:
        """

                Start asynchronous autocompletion of this buffer.
                (This will do nothing if a previous completion was still in progress.)
        
        """
    def _create_completer_coroutine(self) -> Callable[..., Awaitable[None]]:
        """

                Create function for asynchronous autocompletion.

                (This consumes the asynchronous completer generator, which possibly
                runs the completion algorithm in another thread.)
        
        """
        def completion_does_nothing(document: Document, completion: Completion) -> bool:
            """

                        Return `True` if applying this completion doesn't have any effect.
                        (When it doesn't insert any new text.
            
            """
2021-03-02 20:51:49,188 : INFO : tokenize_signature : --> do i ever get here?
2021-03-02 20:51:49,188 : INFO : tokenize_signature : --> do i ever get here?
2021-03-02 20:51:49,189 : INFO : tokenize_signature : --> do i ever get here?
2021-03-02 20:51:49,189 : INFO : tokenize_signature : --> do i ever get here?
2021-03-02 20:51:49,189 : INFO : tokenize_signature : --> do i ever get here?
        async def async_completer(
            select_first: bool = False,
            select_last: bool = False,
            insert_common_part: bool = False,
            complete_event: Optional[CompleteEvent] = None,
        ) -> None:
                """
                 Don't complete when we already have completions.

                """
            def proceed() -> bool:
                """
                Keep retrieving completions. Input text has not yet changed
                                while generating completions.
                """
    def _create_auto_suggest_coroutine(self) -> Callable[[], Awaitable[None]]:
        """

                Create function for asynchronous auto suggestion.
                (This can be in another thread.)
        
        """
        async def async_suggestor() -> None:
                """
                 Don't suggest when we already have a suggestion.

                """
    def _create_auto_validate_coroutine(self) -> Callable[[], Awaitable[None]]:
        """

                Create a function for asynchronous validation while typing.
                (This can be in another thread.)
        
        """
        async def async_validator() -> None:
                """

                        Validate buffer and handle the accept action.
        
                """
def _only_one_at_a_time(coroutine: _T) -> _T:
    """

        Decorator that only starts the coroutine only if the previous call has
        finished. (Used to make sure that we have only one autocompleter, auto
        suggestor and validator running at a time.)

        When the coroutine raises `_Retry`, it is restarted.
    
    """
    async def new_coroutine(*a: Any, **kw: Any) -> Any:
            """
             Don't start a new function, if the previous is still in progress.

            """
def _Retry(Exception):
    """
     Retry in `_only_one_at_a_time`. 
    """
def indent(buffer: Buffer, from_row: int, to_row: int, count: int = 1) -> None:
    """

        Indent text of a :class:`.Buffer` object.
    
    """
def unindent(buffer: Buffer, from_row: int, to_row: int, count: int = 1) -> None:
    """

        Unindent text of a :class:`.Buffer` object.
    
    """
    def transform(text: str) -> str:
        """
    
        """
def reshape_text(buffer: Buffer, from_row: int, to_row: int) -> None:
    """

        Reformat text, taking the width into account.
        `to_row` is included.
        (Vi 'gq' operator.)
    
    """
