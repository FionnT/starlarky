2021-03-02 20:51:35,383 : INFO : tokenize_signature : --> do i ever get here?
2021-03-02 20:51:35,383 : INFO : tokenize_signature : --> do i ever get here?
2021-03-02 20:51:35,383 : INFO : tokenize_signature : --> do i ever get here?
2021-03-02 20:51:35,383 : INFO : tokenize_signature : --> do i ever get here?
2021-03-02 20:51:35,383 : INFO : tokenize_signature : --> do i ever get here?
2021-03-02 20:51:35,383 : INFO : tokenize_signature : --> do i ever get here?
2021-03-02 20:51:35,383 : INFO : tokenize_signature : --> do i ever get here?
2021-03-02 20:51:35,384 : INFO : tokenize_signature : --> do i ever get here?
2021-03-02 20:51:35,384 : INFO : tokenize_signature : --> do i ever get here?
2021-03-02 20:51:35,384 : INFO : tokenize_signature : --> do i ever get here?
2021-03-02 20:51:35,384 : INFO : tokenize_signature : --> do i ever get here?
2021-03-02 20:51:35,384 : INFO : tokenize_signature : --> do i ever get here?
2021-03-02 20:51:35,384 : INFO : tokenize_signature : --> do i ever get here?
2021-03-02 20:51:35,384 : INFO : tokenize_signature : --> do i ever get here?
def _output_screen_diff(
    app: "Application[Any]",
    output: Output,
    screen: Screen,
    current_pos: Point,
    color_depth: ColorDepth,
    previous_screen: Optional[Screen],
    last_style: Optional[str],
    is_done: bool,  # XXX: drop is_done
    full_screen: bool,
    attrs_for_style_string: "_StyleStringToAttrsCache",
    style_string_has_style: "_StyleStringHasStyleCache",
    size: Size,
    previous_width: int,
) -> Tuple[Point, Optional[str]]:
    """

        Render the diff between this screen and the previous screen.

        This takes two `Screen` instances. The one that represents the output like
        it was during the last rendering and one that represents the current
        output raster. Looking at these two `Screen` instances, this function will
        render the difference by calling the appropriate methods of the `Output`
        object that only paint the changes to the terminal.

        This is some performance-critical code which is heavily optimized.
        Don't change things without profiling first.

        :param current_pos: Current cursor position.
        :param last_style: The style string, used for drawing the last drawn
            character.  (Color/attributes.)
        :param attrs_for_style_string: :class:`._StyleStringToAttrsCache` instance.
        :param width: The width of the terminal.
        :param previous_width: The width of the terminal during the last rendering.
    
    """
    def reset_attributes() -> None:
        """
         Wrapper around Output.reset_attributes. 
        """
    def move_cursor(new: Point) -> Point:
        """
         Move cursor to this `new` point. Returns the given Point. 
        """
    def output_char(char: Char) -> None:
        """

                Write the output of this character.
        
        """
    def get_max_column_index(row: Dict[int, Char]) -> int:
        """

                Return max used column index, ignoring whitespace (without style) at
                the end of the line. This is important for people that copy/paste
                terminal output.

                There are two reasons we are sometimes seeing whitespace at the end:
                - `BufferControl` adds a trailing space to each line, because it's a
                  possible cursor position, so that the line wrapping won't change if
                  the cursor position moves around.
                - The `Window` adds a style class to the current line for highlighting
                  (cursor-line).
        
        """
def HeightIsUnknownError(Exception):
    """
     Information unavailable. Did not yet receive the CPR response. 
    """
def _StyleStringToAttrsCache(Dict[str, Attrs]):
    """

        A cache structure that maps style strings to :class:`.Attr`.
        (This is an important speed up.)
    
    """
2021-03-02 20:51:35,389 : INFO : tokenize_signature : --> do i ever get here?
2021-03-02 20:51:35,389 : INFO : tokenize_signature : --> do i ever get here?
2021-03-02 20:51:35,389 : INFO : tokenize_signature : --> do i ever get here?
2021-03-02 20:51:35,389 : INFO : tokenize_signature : --> do i ever get here?
    def __init__(
        self,
        get_attrs_for_style_str: Callable[["str"], Attrs],
        style_transformation: StyleTransformation,
    ) -> None:
        """

            Cache for remember which style strings don't render the default output
            style (default fg/bg, no underline and no reverse and no blink). That way
            we know that we should render these cells, even when they're empty (when
            they contain a space).

            Note: we don't consider bold/italic/hidden because they don't change the
            output if there's no text in the cell.
    
        """
    def __init__(self, style_string_to_attrs: Dict[str, Attrs]) -> None:
        """
         Enum: whether or not CPR is supported. 
        """
def Renderer:
    """

        Typical usage:

        ::

            output = Vt100_Output.from_pty(sys.stdout)
            r = Renderer(style, output)
            r.render(app, layout=...)
    
    """
2021-03-02 20:51:35,390 : INFO : tokenize_signature : --> do i ever get here?
2021-03-02 20:51:35,390 : INFO : tokenize_signature : --> do i ever get here?
2021-03-02 20:51:35,391 : INFO : tokenize_signature : --> do i ever get here?
2021-03-02 20:51:35,391 : INFO : tokenize_signature : --> do i ever get here?
2021-03-02 20:51:35,391 : INFO : tokenize_signature : --> do i ever get here?
2021-03-02 20:51:35,391 : INFO : tokenize_signature : --> do i ever get here?
2021-03-02 20:51:35,391 : INFO : tokenize_signature : --> do i ever get here?
    def __init__(
        self,
        style: BaseStyle,
        output: Output,
        full_screen: bool = False,
        mouse_support: FilterOrBool = False,
        cpr_not_supported_callback: Optional[Callable[[], None]] = None,
    ) -> None:
        """
         Future set when we are waiting for a CPR flag.

        """
    def reset(self, _scroll: bool = False, leave_alternate_screen: bool = True) -> None:
        """
         Reset position

        """
    def last_rendered_screen(self) -> Optional[Screen]:
        """

                The `Screen` class that was generated during the last rendering.
                This can be `None`.
        
        """
    def height_is_known(self) -> bool:
        """

                True when the height from the cursor until the bottom of the terminal
                is known. (It's often nicer to draw bottom toolbars only if the height
                is known, in order to avoid flickering when the CPR response arrives.)
        
        """
    def rows_above_layout(self) -> int:
        """

                Return the number of rows visible in the terminal above the layout.
        
        """
    def request_absolute_cursor_position(self) -> None:
        """

                Get current cursor position.

                We do this to calculate the minimum available height that we can
                consume for rendering the prompt. This is the available space below te
                cursor.

                For vt100: Do CPR request. (answer will arrive later.)
                For win32: Do API call. (Answer comes immediately.)
        
        """
        def do_cpr() -> None:
            """
             Asks for a cursor position report (CPR).

            """
        async def timer() -> None:
                """
                 Not set in the meantime -> not supported.

                """
    def report_absolute_cursor_row(self, row: int) -> None:
        """

                To be called when we know the absolute cursor position.
                (As an answer of a "Cursor Position Request" response.)
        
        """
    def waiting_for_cpr(self) -> bool:
        """

                Waiting for CPR flag. True when we send the request, but didn't got a
                response.
        
        """
    async def wait_for_cpr_responses(self, timeout: int = 1) -> None:
            """

                    Wait for a CPR response.
        
            """
        async def wait_for_responses() -> None:
                """
                 Got timeout, erase queue.

                """
2021-03-02 20:51:35,395 : INFO : tokenize_signature : --> do i ever get here?
2021-03-02 20:51:35,396 : INFO : tokenize_signature : --> do i ever get here?
    def render(
        self, app: "Application[Any]", layout: "Layout", is_done: bool = False
    ) -> None:
        """

                Render the current interface to the output.

                :param is_done: When True, put the cursor at the end of the interface. We
                        won't print any changes to this part.
        
        """
    def erase(self, leave_alternate_screen: bool = True) -> None:
        """

                Hide all output and put the cursor back at the first line. This is for
                instance used for running a system command (while hiding the CLI) and
                later resuming the same CLI.)

                :param leave_alternate_screen: When True, and when inside an alternate
                    screen buffer, quit the alternate screen.
        
        """
    def clear(self) -> None:
        """

                Clear screen and go to 0,0
        
        """
2021-03-02 20:51:35,399 : INFO : tokenize_signature : --> do i ever get here?
2021-03-02 20:51:35,399 : INFO : tokenize_signature : --> do i ever get here?
2021-03-02 20:51:35,399 : INFO : tokenize_signature : --> do i ever get here?
2021-03-02 20:51:35,399 : INFO : tokenize_signature : --> do i ever get here?
2021-03-02 20:51:35,399 : INFO : tokenize_signature : --> do i ever get here?
2021-03-02 20:51:35,399 : INFO : tokenize_signature : --> do i ever get here?
def print_formatted_text(
    output: Output,
    formatted_text: AnyFormattedText,
    style: BaseStyle,
    style_transformation: Optional[StyleTransformation] = None,
    color_depth: Optional[ColorDepth] = None,
) -> None:
    """

        Print a list of (style_str, text) tuples in the given style to the output.
    
    """
