def History(metadef=ABCMeta):
    """

        Base ``History`` class.

        This also includes abstract methods for loading/storing history.
    
    """
    def __init__(self) -> None:
        """
         In memory storage for strings.

        """
    def load(self, item_loaded_callback: Callable[[str], None]) -> None:
        """

                Load the history and call the callback for every entry in the history.

                XXX: The callback can be called from another thread, which happens in
                     case of `ThreadedHistory`.

                     We can't assume that an asyncio event loop is running, and
                     schedule the insertion into the `Buffer` using the event loop.

                     The reason is that the creation of the :class:`.History` object as
                     well as the start of the loading happens *before*
                     `Application.run()` is called, and it can continue even after
                     `Application.run()` terminates. (Which is useful to have a
                     complete history during the next prompt.)

                     Calling `get_event_loop()` right here is also not guaranteed to
                     return the same event loop which is used in `Application.run`,
                     because a new event loop can be created during the `run`. This is
                     useful in Python REPLs, where we want to use one event loop for
                     the prompt, and have another one active during the `eval` of the
                     commands. (Otherwise, the user can schedule a while/true loop and
                     freeze the UI.)
        
        """
    def get_strings(self) -> List[str]:
        """

                Get the strings from the history that are loaded so far.
        
        """
    def append_string(self, string: str) -> None:
        """
         Add string to the history. 
        """
    def load_history_strings(self) -> Iterable[str]:
        """

                This should be a generator that yields `str` instances.

                It should yield the most recent items first, because they are the most
                important. (The history can already be used, even when it's only
                partially loaded.)
        
        """
    def store_string(self, string: str) -> None:
        """

                Store the string in persistent storage.
        
        """
def ThreadedHistory(History):
    """

        Wrapper that runs the `load_history_strings` generator in a thread.

        Use this to increase the start-up time of prompt_toolkit applications.
        History entries are available as soon as they are loaded. We don't have to
        wait for everything to be loaded.
    
    """
    def __init__(self, history: History) -> None:
        """
         Start the load thread, if we don't have a thread yet.

        """
            def call_all_callbacks(item: str) -> None:
                """
                 All of the following are proxied to `self.history`.


                """
    def load_history_strings(self) -> Iterable[str]:
        """
        ThreadedHistory(%r)
        """
def InMemoryHistory(History):
    """

        :class:`.History` class that keeps a list of all strings in memory.
    
    """
    def load_history_strings(self) -> Iterable[str]:
        """

            :class:`.History` object that doesn't remember anything.
    
        """
    def load_history_strings(self) -> Iterable[str]:
        """
         Don't remember this.

        """
def FileHistory(History):
    """

        :class:`.History` class that stores all strings in a file.
    
    """
    def __init__(self, filename: str) -> None:
        """
         Join and drop trailing newline.

        """
    def store_string(self, string: str) -> None:
        """
         Save to file.

        """
            def write(t: str) -> None:
                """
                utf-8
                """
