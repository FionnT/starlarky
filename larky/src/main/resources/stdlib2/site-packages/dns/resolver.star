def NXDOMAIN(dns.exception.DNSException):
    """
    The DNS query name does not exist.
    """
    def _check_kwargs(self, qnames, responses=None):
        """
        qnames must be a list, tuple or set
        """
    def __str__(self):
        """
        'qnames'
        """
    def canonical_name(self):
        """
        'qnames'
        """
    def __add__(self, e_nx):
        """
        Augment by results from another NXDOMAIN exception.
        """
    def qnames(self):
        """
        All of the names that were tried.

                Returns a list of ``dns.name.Name``.
        
        """
    def responses(self):
        """
        A map from queried names to their NXDOMAIN responses.

                Returns a dict mapping a ``dns.name.Name`` to a
                ``dns.message.Message``.
        
        """
    def response(self, qname):
        """
        The response for query *qname*.

                Returns a ``dns.message.Message``.
        
        """
def YXDOMAIN(dns.exception.DNSException):
    """
    The DNS query name is too long after DNAME substitution.
    """
def NoAnswer(dns.exception.DNSException):
    """
    The DNS response does not contain an answer to the question.
    """
    def _fmt_kwargs(self, **kwargs):
        """
        'response'
        """
def NoNameservers(dns.exception.DNSException):
    """
    All nameservers failed to answer the query.

        errors: list of servers and respective errors
        The type of errors is
        [(server IP address, any object convertible to string)].
        Non-empty errors list will add explanatory message ()
    
    """
    def _fmt_kwargs(self, **kwargs):
        """
        'errors'
        """
def NotAbsolute(dns.exception.DNSException):
    """
    An absolute domain name is required but a relative name was provided.
    """
def NoRootSOA(dns.exception.DNSException):
    """
    There is no SOA RR at the DNS root name. This should never happen!
    """
def NoMetaqueries(dns.exception.DNSException):
    """
    DNS metaqueries are not allowed.
    """
def Answer(object):
    """
    DNS stub resolver answer.

        Instances of this class bundle up the result of a successful DNS
        resolution.

        For convenience, the answer object implements much of the sequence
        protocol, forwarding to its ``rrset`` attribute.  E.g.
        ``for a in answer`` is equivalent to ``for a in answer.rrset``.
        ``answer[i]`` is equivalent to ``answer.rrset[i]``, and
        ``answer[i:j]`` is equivalent to ``answer.rrset[i:j]``.

        Note that CNAMEs or DNAMEs in the response may mean that answer
        RRset's name might not be the query name.
    
    """
2021-03-02 20:53:16,161 : INFO : tokenize_signature : --> do i ever get here?
    def __init__(self, qname, rdtype, rdclass, response,
                 raise_on_no_answer=True):
        """
         Look for a SOA RR whose owner name is a superdomain
         of qname.

        """
    def __getattr__(self, attr):
        """
        'name'
        """
    def __len__(self):
        """
        Simple thread-safe DNS answer cache.
        """
    def __init__(self, cleaning_interval=300.0):
        """
        *cleaning_interval*, a ``float`` is the number of seconds between
                periodic cleanings.
        
        """
    def _maybe_clean(self):
        """
        Clean the cache if it's time to do so.
        """
    def get(self, key):
        """
        Get the answer associated with *key*.

                Returns None if no answer is cached for the key.

                *key*, a ``(dns.name.Name, int, int)`` tuple whose values are the
                query name, rdtype, and rdclass respectively.

                Returns a ``dns.resolver.Answer`` or ``None``.
        
        """
    def put(self, key, value):
        """
        Associate key and value in the cache.

                *key*, a ``(dns.name.Name, int, int)`` tuple whose values are the
                query name, rdtype, and rdclass respectively.

                *value*, a ``dns.resolver.Answer``, the answer.
        
        """
    def flush(self, key=None):
        """
        Flush the cache.

                If *key* is not ``None``, only that item is flushed.  Otherwise
                the entire cache is flushed.

                *key*, a ``(dns.name.Name, int, int)`` tuple whose values are the
                query name, rdtype, and rdclass respectively.
        
        """
def LRUCacheNode(object):
    """
    LRUCache node.
    """
    def __init__(self, key, value):
        """
        Thread-safe, bounded, least-recently-used DNS answer cache.

            This cache is better than the simple cache (above) if you're
            running a web crawler or other process that does a lot of
            resolutions.  The LRUCache has a maximum number of nodes, and when
            it is full, the least-recently used node is removed to make space
            for a new one.
    
        """
    def __init__(self, max_size=100000):
        """
        *max_size*, an ``int``, is the maximum number of nodes to cache;
                it must be greater than 0.
        
        """
    def set_max_size(self, max_size):
        """
        Get the answer associated with *key*.

                Returns None if no answer is cached for the key.

                *key*, a ``(dns.name.Name, int, int)`` tuple whose values are the
                query name, rdtype, and rdclass respectively.

                Returns a ``dns.resolver.Answer`` or ``None``.
        
        """
    def put(self, key, value):
        """
        Associate key and value in the cache.

                *key*, a ``(dns.name.Name, int, int)`` tuple whose values are the
                query name, rdtype, and rdclass respectively.

                *value*, a ``dns.resolver.Answer``, the answer.
        
        """
    def flush(self, key=None):
        """
        Flush the cache.

                If *key* is not ``None``, only that item is flushed.  Otherwise
                the entire cache is flushed.

                *key*, a ``(dns.name.Name, int, int)`` tuple whose values are the
                query name, rdtype, and rdclass respectively.
        
        """
def Resolver(object):
    """
    DNS stub resolver.
    """
    def __init__(self, filename='/etc/resolv.conf', configure=True):
        """
        *filename*, a ``text`` or file object, specifying a file
                in standard /etc/resolv.conf format.  This parameter is meaningful
                only when *configure* is true and the platform is POSIX.

                *configure*, a ``bool``.  If True (the default), the resolver
                instance is configured in the normal fashion for the operating
                system the resolver is running on.  (I.e. by reading a
                /etc/resolv.conf file on POSIX systems and from the registry
                on Windows systems.)
        
        """
    def reset(self):
        """
        Reset all resolver configuration to the defaults.
        """
    def read_resolv_conf(self, f):
        """
        Process *f* as a file in the /etc/resolv.conf format.  If f is
                a ``text``, it is used as the name of the file to open; otherwise it
                is treated as the file itself.
        """
    def _determine_split_char(self, entry):
        """

         The windows registry irritatingly changes the list element
         delimiter in between ' ' and ',' (and vice-versa) in various
         versions of windows.


        """
    def _config_win32_nameservers(self, nameservers):
        """
         we call str() on nameservers to convert it from unicode to ascii

        """
    def _config_win32_domain(self, domain):
        """
         we call str() on domain to convert it from unicode to ascii

        """
    def _config_win32_search(self, search):
        """
         we call str() on search to convert it from unicode to ascii

        """
    def _config_win32_fromkey(self, key, always_try_domain):
        """
        'NameServer'
        """
    def read_registry(self):
        """
        Extract resolver configuration from the Windows registry.
        """
    def _win32_is_nic_enabled(self, lm, guid, interface_key):
        """
         Look in the Windows Registry to determine whether the network
         interface corresponding to the given guid is enabled.

         (Code contributed by Paul Marks, thanks!)


        """
    def _compute_timeout(self, start, lifetime=None):
        """
         Time going backwards is bad.  Just give up.

        """
2021-03-02 20:53:16,174 : INFO : tokenize_signature : --> do i ever get here?
2021-03-02 20:53:16,174 : INFO : tokenize_signature : --> do i ever get here?
    def query(self, qname, rdtype=dns.rdatatype.A, rdclass=dns.rdataclass.IN,
              tcp=False, source=None, raise_on_no_answer=True, source_port=0,
              lifetime=None):
        """
        Query nameservers to find the answer to the question.

                The *qname*, *rdtype*, and *rdclass* parameters may be objects
                of the appropriate type, or strings that can be converted into objects
                of the appropriate type.

                *qname*, a ``dns.name.Name`` or ``text``, the query name.

                *rdtype*, an ``int`` or ``text``,  the query type.

                *rdclass*, an ``int`` or ``text``,  the query class.

                *tcp*, a ``bool``.  If ``True``, use TCP to make the query.

                *source*, a ``text`` or ``None``.  If not ``None``, bind to this IP
                address when making queries.

                *raise_on_no_answer*, a ``bool``.  If ``True``, raise
                ``dns.resolver.NoAnswer`` if there's no answer to the question.

                *source_port*, an ``int``, the port from which to send the message.

                *lifetime*, a ``float``, how long query should run before timing out.

                Raises ``dns.exception.Timeout`` if no answers could be found
                in the specified lifetime.

                Raises ``dns.resolver.NXDOMAIN`` if the query name does not exist.

                Raises ``dns.resolver.YXDOMAIN`` if the query name is too long after
                DNAME substitution.

                Raises ``dns.resolver.NoAnswer`` if *raise_on_no_answer* is
                ``True`` and the query name exists but has no RRset of the
                desired type and class.

                Raises ``dns.resolver.NoNameservers`` if no non-broken
                nameservers are available to answer the question.

                Returns a ``dns.resolver.Answer`` instance.
        
        """
2021-03-02 20:53:16,179 : INFO : tokenize_signature : --> do i ever get here?
    def use_tsig(self, keyring, keyname=None,
                 algorithm=dns.tsig.default_algorithm):
        """
        Add a TSIG signature to the query.

                See the documentation of the Message class for a complete
                description of the keyring dictionary.

                *keyring*, a ``dict``, the TSIG keyring to use.  If a
                *keyring* is specified but a *keyname* is not, then the key
                used will be the first key in the *keyring*.  Note that the
                order of keys in a dictionary is not defined, so applications
                should supply a keyname when a keyring is used, unless they
                know the keyring contains only one key.

                *keyname*, a ``dns.name.Name`` or ``None``, the name of the TSIG key
                to use; defaults to ``None``. The key must be defined in the keyring.

                *algorithm*, a ``dns.name.Name``, the TSIG algorithm to use.
        
        """
    def use_edns(self, edns, ednsflags, payload):
        """
        Configure EDNS behavior.

                *edns*, an ``int``, is the EDNS level to use.  Specifying
                ``None``, ``False``, or ``-1`` means "do not use EDNS", and in this case
                the other parameters are ignored.  Specifying ``True`` is
                equivalent to specifying 0, i.e. "use EDNS0".

                *ednsflags*, an ``int``, the EDNS flag values.

                *payload*, an ``int``, is the EDNS sender's payload field, which is the
                maximum size of UDP datagram the sender can handle.  I.e. how big
                a response to this message can be.
        
        """
    def set_flags(self, flags):
        """
        Overrides the default flags with your own.

                *flags*, an ``int``, the message flags to use.
        
        """
def get_default_resolver():
    """
    Get the default resolver, initializing it if necessary.
    """
def reset_default_resolver():
    """
    Re-initialize default resolver.

        Note that the resolver configuration (i.e. /etc/resolv.conf on UNIX
        systems) will be re-read immediately.
    
    """
2021-03-02 20:53:16,180 : INFO : tokenize_signature : --> do i ever get here?
2021-03-02 20:53:16,180 : INFO : tokenize_signature : --> do i ever get here?
def query(qname, rdtype=dns.rdatatype.A, rdclass=dns.rdataclass.IN,
          tcp=False, source=None, raise_on_no_answer=True,
          source_port=0, lifetime=None):
    """
    Query nameservers to find the answer to the question.

        This is a convenience function that uses the default resolver
        object to make the query.

        See ``dns.resolver.Resolver.query`` for more information on the
        parameters.
    
    """
def zone_for_name(name, rdclass=dns.rdataclass.IN, tcp=False, resolver=None):
    """
    Find the name of the zone which contains the specified name.

        *name*, an absolute ``dns.name.Name`` or ``text``, the query name.

        *rdclass*, an ``int``, the query class.

        *tcp*, a ``bool``.  If ``True``, use TCP to make the query.

        *resolver*, a ``dns.resolver.Resolver`` or ``None``, the resolver to use.
        If ``None``, the default resolver is used.

        Raises ``dns.resolver.NoRootSOA`` if there is no SOA RR at the DNS
        root.  (This is only likely to happen if you're using non-default
        root servers in your network and they are misconfigured.)

        Returns a ``dns.name.Name``.
    
    """
2021-03-02 20:53:16,182 : INFO : tokenize_signature : --> do i ever get here?
def _getaddrinfo(host=None, service=None, family=socket.AF_UNSPEC, socktype=0,
                 proto=0, flags=0):
    """
     Is host None or a V6 address literal?

    """
def _getnameinfo(sockaddr, flags=0):
    """
    'sockaddr resolved to multiple addresses'
    """
def _getfqdn(name=None):
    """
     XXX we just ignore aliases

    """
def _gethostbyaddr(ip):
    """
     XXX we just ignore aliases

    """
def override_system_resolver(resolver=None):
    """
    Override the system resolver routines in the socket module with
        versions which use dnspython's resolver.

        This can be useful in testing situations where you want to control
        the resolution behavior of python code without having to change
        the system's resolver settings (e.g. /etc/resolv.conf).

        The resolver to use may be specified; if it's not, the default
        resolver will be used.

        resolver, a ``dns.resolver.Resolver`` or ``None``, the resolver to use.
    
    """
def restore_system_resolver():
    """
    Undo the effects of prior override_system_resolver().
    """
