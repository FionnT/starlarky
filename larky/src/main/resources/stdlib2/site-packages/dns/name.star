def EmptyLabel(dns.exception.SyntaxError):
    """
    A DNS label is empty.
    """
def BadEscape(dns.exception.SyntaxError):
    """
    An escaped code in a text format of DNS name is invalid.
    """
def BadPointer(dns.exception.FormError):
    """
    A DNS compression pointer points forward instead of backward.
    """
def BadLabelType(dns.exception.FormError):
    """
    The label type in DNS name wire format is unknown.
    """
def NeedAbsoluteNameOrOrigin(dns.exception.DNSException):
    """
    An attempt was made to convert a non-absolute name to
        wire when there was also a non-absolute (or missing) origin.
    """
def NameTooLong(dns.exception.FormError):
    """
    A DNS name is > 255 octets long.
    """
def LabelTooLong(dns.exception.SyntaxError):
    """
    A DNS label is > 63 octets long.
    """
def AbsoluteConcatenation(dns.exception.DNSException):
    """
    An attempt was made to append anything other than the
        empty name to an absolute DNS name.
    """
def NoParent(dns.exception.DNSException):
    """
    An attempt was made to get the parent of the root name
        or the empty name.
    """
def NoIDNA2008(dns.exception.DNSException):
    """
    IDNA 2008 processing was requested but the idna module is not
        available.
    """
def IDNAException(dns.exception.DNSException):
    """
    IDNA processing raised an exception.
    """
def IDNACodec(object):
    """
    Abstract base class for IDNA encoder/decoders.
    """
    def __init__(self):
        """
         We do not apply any IDNA policy on decode; we just

        """
def IDNA2003Codec(IDNACodec):
    """
    IDNA 2003 encoder/decoder.
    """
    def __init__(self, strict_decode=False):
        """
        Initialize the IDNA 2003 encoder/decoder.

                *strict_decode* is a ``bool``. If `True`, then IDNA2003 checking
                is done when decoding.  This can cause failures if the name
                was encoded with IDNA2008.  The default is `False`.
        
        """
    def encode(self, label):
        """
        Encode *label*.
        """
    def decode(self, label):
        """
        Decode *label*.
        """
def IDNA2008Codec(IDNACodec):
    """
    IDNA 2008 encoder/decoder.

            *uts_46* is a ``bool``.  If True, apply Unicode IDNA
            compatibility processing as described in Unicode Technical
            Standard #46 (http://unicode.org/reports/tr46/).
            If False, do not apply the mapping.  The default is False.

            *transitional* is a ``bool``: If True, use the
            "transitional" mode described in Unicode Technical Standard
            #46.  The default is False.

            *allow_pure_ascii* is a ``bool``.  If True, then a label which
            consists of only ASCII characters is allowed.  This is less
            strict than regular IDNA 2008, but is also necessary for mixed
            names, e.g. a name with starting with "_sip._tcp." and ending
            in an IDN suffix which would otherwise be disallowed.  The
            default is False.

            *strict_decode* is a ``bool``: If True, then IDNA2008 checking
            is done when decoding.  This can cause failures if the name
            was encoded with IDNA2003.  The default is False.
        
    """
2021-03-02 20:53:17,243 : INFO : tokenize_signature : --> do i ever get here?
    def __init__(self, uts_46=False, transitional=False,
                 allow_pure_ascii=False, strict_decode=False):
        """
        Initialize the IDNA 2008 encoder/decoder.
        """
    def is_all_ascii(self, label):
        """
        ''
        """
    def decode(self, label):
        """
        b''
        """
def _escapify(label, unicode_mode=False):
    """
    Escape the characters in label which need it.
        @param unicode_mode: escapify only special and whitespace (<= 0x20)
        characters
        @returns: the escaped string
        @rtype: string
    """
def _validate_labels(labels):
    """
    Check for empty labels in the middle of a label sequence,
        labels that are too long, and for too many labels.

        Raises ``dns.name.NameTooLong`` if the name as a whole is too long.

        Raises ``dns.name.EmptyLabel`` if a label is empty (i.e. the root
        label) and appears in a position other than the end of the label
        sequence

    
    """
def _maybe_convert_to_binary(label):
    """
    If label is ``text``, convert it to ``binary``.  If it is already
        ``binary`` just return it.

    
    """
def Name(object):
    """
    A DNS name.

        The dns.name.Name class represents a DNS name as a tuple of
        labels.  Each label is a `binary` in DNS wire format.  Instances
        of the class are immutable.
    
    """
    def __init__(self, labels):
        """
        *labels* is any iterable whose values are ``text`` or ``binary``.
        
        """
    def __setattr__(self, name, value):
        """
         Names are immutable

        """
    def __copy__(self):
        """
         Names can be pickled

        """
    def __setstate__(self, state):
        """
        'labels'
        """
    def is_absolute(self):
        """
        Is the most significant label of this name the root label?

                Returns a ``bool``.
        
        """
    def is_wild(self):
        """
        Is this name wild?  (I.e. Is the least significant label '*'?)

                Returns a ``bool``.
        
        """
    def __hash__(self):
        """
        Return a case-insensitive hash of the name.

                Returns an ``int``.
        
        """
    def fullcompare(self, other):
        """
        Compare two names, returning a 3-tuple
                ``(relation, order, nlabels)``.

                *relation* describes the relation ship between the names,
                and is one of: ``dns.name.NAMERELN_NONE``,
                ``dns.name.NAMERELN_SUPERDOMAIN``, ``dns.name.NAMERELN_SUBDOMAIN``,
                ``dns.name.NAMERELN_EQUAL``, or ``dns.name.NAMERELN_COMMONANCESTOR``.

                *order* is < 0 if *self* < *other*, > 0 if *self* > *other*, and ==
                0 if *self* == *other*.  A relative name is always less than an
                absolute name.  If both names have the same relativity, then
                the DNSSEC order relation is used to order them.

                *nlabels* is the number of significant labels that the two names
                have in common.

                Here are some examples.  Names ending in "." are absolute names,
                those not ending in "." are relative names.

                =============  =============  ===========  =====  =======
                self           other          relation     order  nlabels
                =============  =============  ===========  =====  =======
                www.example.   www.example.   equal        0      3
                www.example.   example.       subdomain    > 0    2
                example.       www.example.   superdomain  < 0    2
                example1.com.  example2.com.  common anc.  < 0    2
                example1       example2.      none         < 0    0
                example1.      example2       none         > 0    0
                =============  =============  ===========  =====  =======
        
        """
    def is_subdomain(self, other):
        """
        Is self a subdomain of other?

                Note that the notion of subdomain includes equality, e.g.
                "dnpython.org" is a subdomain of itself.

                Returns a ``bool``.
        
        """
    def is_superdomain(self, other):
        """
        Is self a superdomain of other?

                Note that the notion of superdomain includes equality, e.g.
                "dnpython.org" is a superdomain of itself.

                Returns a ``bool``.
        
        """
    def canonicalize(self):
        """
        Return a name which is equal to the current name, but is in
                DNSSEC canonical form.
        
        """
    def __eq__(self, other):
        """
        '<DNS name '
        """
    def __str__(self):
        """
        Convert name to DNS text format.

                *omit_final_dot* is a ``bool``.  If True, don't emit the final
                dot (denoting the root label) for absolute names.  The default
                is False.

                Returns a ``text``.
        
        """
    def to_unicode(self, omit_final_dot=False, idna_codec=None):
        """
        Convert name to Unicode text format.

                IDN ACE labels are converted to Unicode.

                *omit_final_dot* is a ``bool``.  If True, don't emit the final
                dot (denoting the root label) for absolute names.  The default
                is False.
                *idna_codec* specifies the IDNA encoder/decoder.  If None, the
                dns.name.IDNA_2003_Practical encoder/decoder is used.
                The IDNA_2003_Practical decoder does
                not impose any policy, it just decodes punycode, so if you
                don't want checking for compliance, you can use this decoder
                for IDNA2008 as well.

                Returns a ``text``.
        
        """
    def to_digestable(self, origin=None):
        """
        Convert name to a format suitable for digesting in hashes.

                The name is canonicalized and converted to uncompressed wire
                format.  All names in wire format are absolute.  If the name
                is a relative name, then an origin must be supplied.

                *origin* is a ``dns.name.Name`` or ``None``.  If the name is
                relative and origin is not ``None``, then origin will be appended
                to the name.

                Raises ``dns.name.NeedAbsoluteNameOrOrigin`` if the name is
                relative and no origin was provided.

                Returns a ``binary``.
        
        """
    def to_wire(self, file=None, compress=None, origin=None):
        """
        Convert name to wire format, possibly compressing it.

                *file* is the file where the name is emitted (typically a
                BytesIO file).  If ``None`` (the default), a ``binary``
                containing the wire name will be returned.

                *compress*, a ``dict``, is the compression table to use.  If
                ``None`` (the default), names will not be compressed.

                *origin* is a ``dns.name.Name`` or ``None``.  If the name is
                relative and origin is not ``None``, then *origin* will be appended
                to it.

                Raises ``dns.name.NeedAbsoluteNameOrOrigin`` if the name is
                relative and no origin was provided.

                Returns a ``binary`` or ``None``.
        
        """
    def __len__(self):
        """
        The length of the name (in labels).

                Returns an ``int``.
        
        """
    def __getitem__(self, index):
        """
        Split a name into a prefix and suffix names at the specified depth.

                *depth* is an ``int`` specifying the number of labels in the suffix

                Raises ``ValueError`` if *depth* was not >= 0 and <= the length of the
                name.

                Returns the tuple ``(prefix, suffix)``.
        
        """
    def concatenate(self, other):
        """
        Return a new name which is the concatenation of self and other.

                Raises ``dns.name.AbsoluteConcatenation`` if the name is
                absolute and *other* is not the empty name.

                Returns a ``dns.name.Name``.
        
        """
    def relativize(self, origin):
        """
        If the name is a subdomain of *origin*, return a new name which is
                the name relative to origin.  Otherwise return the name.

                For example, relativizing ``www.dnspython.org.`` to origin
                ``dnspython.org.`` returns the name ``www``.  Relativizing ``example.``
                to origin ``dnspython.org.`` returns ``example.``.

                Returns a ``dns.name.Name``.
        
        """
    def derelativize(self, origin):
        """
        If the name is a relative name, return a new name which is the
                concatenation of the name and origin.  Otherwise return the name.

                For example, derelativizing ``www`` to origin ``dnspython.org.``
                returns the name ``www.dnspython.org.``.  Derelativizing ``example.``
                to origin ``dnspython.org.`` returns ``example.``.

                Returns a ``dns.name.Name``.
        
        """
    def choose_relativity(self, origin=None, relativize=True):
        """
        Return a name with the relativity desired by the caller.

                If *origin* is ``None``, then the name is returned.
                Otherwise, if *relativize* is ``True`` the name is
                relativized, and if *relativize* is ``False`` the name is
                derelativized.

                Returns a ``dns.name.Name``.
        
        """
    def parent(self):
        """
        Return the parent of the name.

                For example, the parent of ``www.dnspython.org.`` is ``dnspython.org``.

                Raises ``dns.name.NoParent`` if the name is either the root name or the
                empty name, and thus has no parent.

                Returns a ``dns.name.Name``.
        
        """
def from_unicode(text, origin=root, idna_codec=None):
    """
    Convert unicode text into a Name object.

        Labels are encoded in IDN ACE form according to rules specified by
        the IDNA codec.

        *text*, a ``text``, is the text to convert into a name.

        *origin*, a ``dns.name.Name``, specifies the origin to
        append to non-absolute names.  The default is the root name.

        *idna_codec*, a ``dns.name.IDNACodec``, specifies the IDNA
        encoder/decoder.  If ``None``, the default IDNA 2003 encoder/decoder
        is used.

        Returns a ``dns.name.Name``.
    
    """
def from_text(text, origin=root, idna_codec=None):
    """
    Convert text into a Name object.

        *text*, a ``text``, is the text to convert into a name.

        *origin*, a ``dns.name.Name``, specifies the origin to
        append to non-absolute names.  The default is the root name.

        *idna_codec*, a ``dns.name.IDNACodec``, specifies the IDNA
        encoder/decoder.  If ``None``, the default IDNA 2003 encoder/decoder
        is used.

        Returns a ``dns.name.Name``.
    
    """
def from_wire(message, current):
    """
    Convert possibly compressed wire format into a Name.

        *message* is a ``binary`` containing an entire DNS message in DNS
        wire form.

        *current*, an ``int``, is the offset of the beginning of the name
        from the start of the message

        Raises ``dns.name.BadPointer`` if a compression pointer did not
        point backwards in the message.

        Raises ``dns.name.BadLabelType`` if an invalid label type was encountered.

        Returns a ``(dns.name.Name, int)`` tuple consisting of the name
        that was read and the number of bytes of the wire format message
        which were consumed reading it.
    
    """
