def ShortHeader(dns.exception.FormError):
    """
    The DNS packet passed to from_wire() is too short.
    """
def TrailingJunk(dns.exception.FormError):
    """
    The DNS packet passed to from_wire() has extra junk at the end of it.
    """
def UnknownHeaderField(dns.exception.DNSException):
    """
    The header field name was not recognized when converting from text
        into a message.
    """
def BadEDNS(dns.exception.FormError):
    """
    An OPT record occurred somewhere other than the start of
        the additional data section.
    """
def BadTSIG(dns.exception.FormError):
    """
    A TSIG record occurred somewhere other than the end of
        the additional data section.
    """
def UnknownTSIGKey(dns.exception.DNSException):
    """
    A TSIG with an unknown key was received.
    """
def Message(object):
    """
    A DNS message.
    """
    def __init__(self, id=None):
        """
        b''
        """
    def __repr__(self):
        """
        '<DNS message, ID '
        """
    def __str__(self):
        """
        Convert the message to text.

                The *origin*, *relativize*, and any other keyword
                arguments are passed to the RRset ``to_wire()`` method.

                Returns a ``text``.
        
        """
    def __eq__(self, other):
        """
        Two messages are equal if they have the same content in the
                header, question, answer, and authority sections.

                Returns a ``bool``.
        
        """
    def __ne__(self, other):
        """
        Is this message a response to *other*?

                Returns a ``bool``.
        
        """
    def section_number(self, section):
        """
        Return the "section number" of the specified section for use
                in indexing.  The question section is 0, the answer section is 1,
                the authority section is 2, and the additional section is 3.

                *section* is one of the section attributes of this message.

                Raises ``ValueError`` if the section isn't known.

                Returns an ``int``.
        
        """
    def section_from_number(self, number):
        """
        Return the "section number" of the specified section for use
                in indexing.  The question section is 0, the answer section is 1,
                the authority section is 2, and the additional section is 3.

                *section* is one of the section attributes of this message.

                Raises ``ValueError`` if the section isn't known.

                Returns an ``int``.
        
        """
2021-03-02 20:53:15,081 : INFO : tokenize_signature : --> do i ever get here?
2021-03-02 20:53:15,081 : INFO : tokenize_signature : --> do i ever get here?
    def find_rrset(self, section, name, rdclass, rdtype,
                   covers=dns.rdatatype.NONE, deleting=None, create=False,
                   force_unique=False):
        """
        Find the RRset with the given attributes in the specified section.

                *section*, an ``int`` section number, or one of the section
                attributes of this message.  This specifies the
                the section of the message to search.  For example::

                    my_message.find_rrset(my_message.answer, name, rdclass, rdtype)
                    my_message.find_rrset(dns.message.ANSWER, name, rdclass, rdtype)

                *name*, a ``dns.name.Name``, the name of the RRset.

                *rdclass*, an ``int``, the class of the RRset.

                *rdtype*, an ``int``, the type of the RRset.

                *covers*, an ``int`` or ``None``, the covers value of the RRset.
                The default is ``None``.

                *deleting*, an ``int`` or ``None``, the deleting value of the RRset.
                The default is ``None``.

                *create*, a ``bool``.  If ``True``, create the RRset if it is not found.
                The created RRset is appended to *section*.

                *force_unique*, a ``bool``.  If ``True`` and *create* is also ``True``,
                create a new RRset regardless of whether a matching RRset exists
                already.  The default is ``False``.  This is useful when creating
                DDNS Update messages, as order matters for them.

                Raises ``KeyError`` if the RRset was not found and create was
                ``False``.

                Returns a ``dns.rrset.RRset object``.
        
        """
2021-03-02 20:53:15,082 : INFO : tokenize_signature : --> do i ever get here?
2021-03-02 20:53:15,082 : INFO : tokenize_signature : --> do i ever get here?
    def get_rrset(self, section, name, rdclass, rdtype,
                  covers=dns.rdatatype.NONE, deleting=None, create=False,
                  force_unique=False):
        """
        Get the RRset with the given attributes in the specified section.

                If the RRset is not found, None is returned.

                *section*, an ``int`` section number, or one of the section
                attributes of this message.  This specifies the
                the section of the message to search.  For example::

                    my_message.get_rrset(my_message.answer, name, rdclass, rdtype)
                    my_message.get_rrset(dns.message.ANSWER, name, rdclass, rdtype)

                *name*, a ``dns.name.Name``, the name of the RRset.

                *rdclass*, an ``int``, the class of the RRset.

                *rdtype*, an ``int``, the type of the RRset.

                *covers*, an ``int`` or ``None``, the covers value of the RRset.
                The default is ``None``.

                *deleting*, an ``int`` or ``None``, the deleting value of the RRset.
                The default is ``None``.

                *create*, a ``bool``.  If ``True``, create the RRset if it is not found.
                The created RRset is appended to *section*.

                *force_unique*, a ``bool``.  If ``True`` and *create* is also ``True``,
                create a new RRset regardless of whether a matching RRset exists
                already.  The default is ``False``.  This is useful when creating
                DDNS Update messages, as order matters for them.

                Returns a ``dns.rrset.RRset object`` or ``None``.
        
        """
    def to_wire(self, origin=None, max_size=0, **kw):
        """
        Return a string containing the message in DNS compressed wire
                format.

                Additional keyword arguments are passed to the RRset ``to_wire()``
                method.

                *origin*, a ``dns.name.Name`` or ``None``, the origin to be appended
                to any relative names.

                *max_size*, an ``int``, the maximum size of the wire format
                output; default is 0, which means "the message's request
                payload, if nonzero, or 65535".

                Raises ``dns.exception.TooBig`` if *max_size* was exceeded.

                Returns a ``binary``.
        
        """
2021-03-02 20:53:15,084 : INFO : tokenize_signature : --> do i ever get here?
2021-03-02 20:53:15,084 : INFO : tokenize_signature : --> do i ever get here?
    def use_tsig(self, keyring, keyname=None, fudge=300,
                 original_id=None, tsig_error=0, other_data=b'',
                 algorithm=dns.tsig.default_algorithm):
        """
        When sending, a TSIG signature using the specified keyring
                and keyname should be added.

                See the documentation of the Message class for a complete
                description of the keyring dictionary.

                *keyring*, a ``dict``, the TSIG keyring to use.  If a
                *keyring* is specified but a *keyname* is not, then the key
                used will be the first key in the *keyring*.  Note that the
                order of keys in a dictionary is not defined, so applications
                should supply a keyname when a keyring is used, unless they
                know the keyring contains only one key.

                *keyname*, a ``dns.name.Name`` or ``None``, the name of the TSIG key
                to use; defaults to ``None``. The key must be defined in the keyring.

                *fudge*, an ``int``, the TSIG time fudge.

                *original_id*, an ``int``, the TSIG original id.  If ``None``,
                the message's id is used.

                *tsig_error*, an ``int``, the TSIG error code.

                *other_data*, a ``binary``, the TSIG other data.

                *algorithm*, a ``dns.name.Name``, the TSIG algorithm to use.
        
        """
2021-03-02 20:53:15,084 : INFO : tokenize_signature : --> do i ever get here?
    def use_edns(self, edns=0, ednsflags=0, payload=1280, request_payload=None,
                 options=None):
        """
        Configure EDNS behavior.

                *edns*, an ``int``, is the EDNS level to use.  Specifying
                ``None``, ``False``, or ``-1`` means "do not use EDNS", and in this case
                the other parameters are ignored.  Specifying ``True`` is
                equivalent to specifying 0, i.e. "use EDNS0".

                *ednsflags*, an ``int``, the EDNS flag values.

                *payload*, an ``int``, is the EDNS sender's payload field, which is the
                maximum size of UDP datagram the sender can handle.  I.e. how big
                a response to this message can be.

                *request_payload*, an ``int``, is the EDNS payload size to use when
                sending this message.  If not specified, defaults to the value of
                *payload*.

                *options*, a list of ``dns.edns.Option`` objects or ``None``, the EDNS
                options.
        
        """
    def want_dnssec(self, wanted=True):
        """
        Enable or disable 'DNSSEC desired' flag in requests.

                *wanted*, a ``bool``.  If ``True``, then DNSSEC data is
                desired in the response, EDNS is enabled if required, and then
                the DO bit is set.  If ``False``, the DO bit is cleared if
                EDNS is enabled.
        
        """
    def rcode(self):
        """
        Return the rcode.

                Returns an ``int``.
        
        """
    def set_rcode(self, rcode):
        """
        Set the rcode.

                *rcode*, an ``int``, is the rcode to set.
        
        """
    def opcode(self):
        """
        Return the opcode.

                Returns an ``int``.
        
        """
    def set_opcode(self, opcode):
        """
        Set the opcode.

                *opcode*, an ``int``, is the opcode to set.
        
        """
def _WireReader(object):
    """
    Wire format reader.

        wire: a binary, is the wire-format message.
        message: The message object being built
        current: When building a message object from wire format, this
        variable contains the offset from the beginning of wire of the next octet
        to be read.
        updating: Is the message a dynamic update?
        one_rr_per_rrset: Put each RR into its own RRset?
        ignore_trailing: Ignore trailing junk at end of request?
        zone_rdclass: The class of the zone in messages which are
        DNS dynamic updates.
    
    """
2021-03-02 20:53:15,087 : INFO : tokenize_signature : --> do i ever get here?
    def __init__(self, wire, message, question_only=False,
                 one_rr_per_rrset=False, ignore_trailing=False):
        """
        Read the next *qcount* records from the wire data and add them to
                the question section.
        
        """
    def _get_section(self, section, count):
        """
        Read the next I{count} records from the wire data and add them to
                the specified section.

                section: the section of the message to which to add records
                count: the number of records to read
        
        """
    def read(self):
        """
        Read a wire format DNS message and build a dns.message.Message
                object.
        """
2021-03-02 20:53:15,092 : INFO : tokenize_signature : --> do i ever get here?
2021-03-02 20:53:15,092 : INFO : tokenize_signature : --> do i ever get here?
2021-03-02 20:53:15,092 : INFO : tokenize_signature : --> do i ever get here?
def from_wire(wire, keyring=None, request_mac=b'', xfr=False, origin=None,
              tsig_ctx=None, multi=False, first=True,
              question_only=False, one_rr_per_rrset=False,
              ignore_trailing=False):
    """
    Convert a DNS wire format message into a message
        object.

        *keyring*, a ``dict``, the keyring to use if the message is signed.

        *request_mac*, a ``binary``.  If the message is a response to a
        TSIG-signed request, *request_mac* should be set to the MAC of
        that request.

        *xfr*, a ``bool``, should be set to ``True`` if this message is part of
        a zone transfer.

        *origin*, a ``dns.name.Name`` or ``None``.  If the message is part
        of a zone transfer, *origin* should be the origin name of the
        zone.

        *tsig_ctx*, a ``hmac.HMAC`` objext, the ongoing TSIG context, used
        when validating zone transfers.

        *multi*, a ``bool``, should be set to ``True`` if this message
        part of a multiple message sequence.

        *first*, a ``bool``, should be set to ``True`` if this message is
        stand-alone, or the first message in a multi-message sequence.

        *question_only*, a ``bool``.  If ``True``, read only up to
        the end of the question section.

        *one_rr_per_rrset*, a ``bool``.  If ``True``, put each RR into its
        own RRset.

        *ignore_trailing*, a ``bool``.  If ``True``, ignore trailing
        junk at end of the message.

        Raises ``dns.message.ShortHeader`` if the message is less than 12 octets
        long.

        Raises ``dns.messaage.TrailingJunk`` if there were octets in the message
        past the end of the proper DNS message, and *ignore_trailing* is ``False``.

        Raises ``dns.message.BadEDNS`` if an OPT record was in the
        wrong section, or occurred more than once.

        Raises ``dns.message.BadTSIG`` if a TSIG record was not the last
        record of the additional data section.

        Returns a ``dns.message.Message``.
    
    """
def _TextReader(object):
    """
    Text format reader.

        tok: the tokenizer.
        message: The message object being built.
        updating: Is the message a dynamic update?
        zone_rdclass: The class of the zone in messages which are
        DNS dynamic updates.
        last_name: The most recently read name when building a message object.
    
    """
    def __init__(self, text, message):
        """
        Process one line from the text format header section.
        """
    def _question_line(self, section):
        """
        Process one line from the text format question section.
        """
    def _rr_line(self, section):
        """
        Process one line from the text format answer, authority, or
                additional data sections.
        
        """
    def read(self):
        """
        Read a text format DNS message and build a dns.message.Message
                object.
        """
def from_text(text):
    """
    Convert the text format message into a message object.

        *text*, a ``text``, the text format message.

        Raises ``dns.message.UnknownHeaderField`` if a header is unknown.

        Raises ``dns.exception.SyntaxError`` if the text is badly formed.

        Returns a ``dns.message.Message object``
    
    """
def from_file(f):
    """
    Read the next text format message from the specified file.

        *f*, a ``file`` or ``text``.  If *f* is text, it is treated as the
        pathname of a file to open.

        Raises ``dns.message.UnknownHeaderField`` if a header is unknown.

        Raises ``dns.exception.SyntaxError`` if the text is badly formed.

        Returns a ``dns.message.Message object``
    
    """
2021-03-02 20:53:15,098 : INFO : tokenize_signature : --> do i ever get here?
2021-03-02 20:53:15,098 : INFO : tokenize_signature : --> do i ever get here?
def make_query(qname, rdtype, rdclass=dns.rdataclass.IN, use_edns=None,
               want_dnssec=False, ednsflags=None, payload=None,
               request_payload=None, options=None):
    """
    Make a query message.

        The query name, type, and class may all be specified either
        as objects of the appropriate type, or as strings.

        The query will have a randomly chosen query id, and its DNS flags
        will be set to dns.flags.RD.

        qname, a ``dns.name.Name`` or ``text``, the query name.

        *rdtype*, an ``int`` or ``text``, the desired rdata type.

        *rdclass*, an ``int`` or ``text``,  the desired rdata class; the default
        is class IN.

        *use_edns*, an ``int``, ``bool`` or ``None``.  The EDNS level to use; the
        default is None (no EDNS).
        See the description of dns.message.Message.use_edns() for the possible
        values for use_edns and their meanings.

        *want_dnssec*, a ``bool``.  If ``True``, DNSSEC data is desired.

        *ednsflags*, an ``int``, the EDNS flag values.

        *payload*, an ``int``, is the EDNS sender's payload field, which is the
        maximum size of UDP datagram the sender can handle.  I.e. how big
        a response to this message can be.

        *request_payload*, an ``int``, is the EDNS payload size to use when
        sending this message.  If not specified, defaults to the value of
        *payload*.

        *options*, a list of ``dns.edns.Option`` objects or ``None``, the EDNS
        options.

        Returns a ``dns.message.Message``
    
    """
2021-03-02 20:53:15,100 : INFO : tokenize_signature : --> do i ever get here?
def make_response(query, recursion_available=False, our_payload=8192,
                  fudge=300):
    """
    Make a message which is a response for the specified query.
        The message returned is really a response skeleton; it has all
        of the infrastructure required of a response, but none of the
        content.

        The response's question section is a shallow copy of the query's
        question section, so the query's question RRsets should not be
        changed.

        *query*, a ``dns.message.Message``, the query to respond to.

        *recursion_available*, a ``bool``, should RA be set in the response?

        *our_payload*, an ``int``, the payload size to advertise in EDNS
        responses.

        *fudge*, an ``int``, the TSIG time fudge.

        Returns a ``dns.message.Message`` object.
    
    """
