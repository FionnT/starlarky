def UnexpectedSource(dns.exception.DNSException):
    """
    A DNS query response came from an unexpected address or port.
    """
def BadResponse(dns.exception.FormError):
    """
    A DNS query response does not respond to the question asked.
    """
def TransferError(dns.exception.DNSException):
    """
    A zone transfer response got a non-zero rcode.
    """
    def __init__(self, rcode):
        """
        'Zone transfer error: %s'
        """
def _compute_expiration(timeout):
    """
     This module can use either poll() or select() as the "polling backend".

     A backend function takes an fd, bools for readability, writablity, and
     error detection, and a timeout.


    """
def _poll_for(fd, readable, writable, error, timeout):
    """
    Poll polling backend.
    """
def _select_for(fd, readable, writable, error, timeout):
    """
    Select polling backend.
    """
def _wait_for(fd, readable, writable, error, expiration):
    """
     Use the selected polling backend to wait for any of the specified
     events.  An "expiration" absolute time is converted into a relative
     timeout.


    """
def _set_polling_backend(fn):
    """
     Internal API. Do not use.


    """
def _wait_for_readable(s, expiration):
    """
     Convert the first value of the tuple, which is a textual format
     address into binary form, so that we are not confused by different
     textual representations of the same address

    """
def _destination_and_source(af, where, port, source, source_port):
    """
     Apply defaults and compute destination and source tuples
     suitable for use in connect(), sendto(), or bind().

    """
def send_udp(sock, what, destination, expiration=None):
    """
    Send a DNS message to the specified UDP socket.

        *sock*, a ``socket``.

        *what*, a ``binary`` or ``dns.message.Message``, the message to send.

        *destination*, a destination tuple appropriate for the address family
        of the socket, specifying where to send the query.

        *expiration*, a ``float`` or ``None``, the absolute time at which
        a timeout exception should be raised.  If ``None``, no timeout will
        occur.

        Returns an ``(int, float)`` tuple of bytes sent and the sent time.
    
    """
2021-03-02 20:53:13,690 : INFO : tokenize_signature : --> do i ever get here?
2021-03-02 20:53:13,690 : INFO : tokenize_signature : --> do i ever get here?
def receive_udp(sock, destination, expiration=None,
                ignore_unexpected=False, one_rr_per_rrset=False,
                keyring=None, request_mac=b'', ignore_trailing=False):
    """
    Read a DNS message from a UDP socket.

        *sock*, a ``socket``.

        *destination*, a destination tuple appropriate for the address family
        of the socket, specifying where the associated query was sent.

        *expiration*, a ``float`` or ``None``, the absolute time at which
        a timeout exception should be raised.  If ``None``, no timeout will
        occur.

        *ignore_unexpected*, a ``bool``.  If ``True``, ignore responses from
        unexpected sources.

        *one_rr_per_rrset*, a ``bool``.  If ``True``, put each RR into its own
        RRset.

        *keyring*, a ``dict``, the keyring to use for TSIG.

        *request_mac*, a ``binary``, the MAC of the request (for TSIG).

        *ignore_trailing*, a ``bool``.  If ``True``, ignore trailing
        junk at end of the received message.

        Raises if the message is malformed, if network errors occur, of if
        there is a timeout.

        Returns a ``dns.message.Message`` object.
    
    """
2021-03-02 20:53:13,691 : INFO : tokenize_signature : --> do i ever get here?
def udp(q, where, timeout=None, port=53, af=None, source=None, source_port=0,
        ignore_unexpected=False, one_rr_per_rrset=False, ignore_trailing=False):
    """
    Return the response obtained after sending a query via UDP.

        *q*, a ``dns.message.Message``, the query to send

        *where*, a ``text`` containing an IPv4 or IPv6 address,  where
        to send the message.

        *timeout*, a ``float`` or ``None``, the number of seconds to wait before the
        query times out.  If ``None``, the default, wait forever.

        *port*, an ``int``, the port send the message to.  The default is 53.

        *af*, an ``int``, the address family to use.  The default is ``None``,
        which causes the address family to use to be inferred from the form of
        *where*.  If the inference attempt fails, AF_INET is used.  This
        parameter is historical; you need never set it.

        *source*, a ``text`` containing an IPv4 or IPv6 address, specifying
        the source address.  The default is the wildcard address.

        *source_port*, an ``int``, the port from which to send the message.
        The default is 0.

        *ignore_unexpected*, a ``bool``.  If ``True``, ignore responses from
        unexpected sources.

        *one_rr_per_rrset*, a ``bool``.  If ``True``, put each RR into its own
        RRset.

        *ignore_trailing*, a ``bool``.  If ``True``, ignore trailing
        junk at end of the received message.

        Returns a ``dns.message.Message``.
    
    """
def _net_read(sock, count, expiration):
    """
    Read the specified number of bytes from sock.  Keep trying until we
        either get the desired amount, or we hit EOF.
        A Timeout exception will be raised if the operation is not completed
        by the expiration time.
    
    """
def _net_write(sock, data, expiration):
    """
    Write the specified data to the socket.
        A Timeout exception will be raised if the operation is not completed
        by the expiration time.
    
    """
def send_tcp(sock, what, expiration=None):
    """
    Send a DNS message to the specified TCP socket.

        *sock*, a ``socket``.

        *what*, a ``binary`` or ``dns.message.Message``, the message to send.

        *expiration*, a ``float`` or ``None``, the absolute time at which
        a timeout exception should be raised.  If ``None``, no timeout will
        occur.

        Returns an ``(int, float)`` tuple of bytes sent and the sent time.
    
    """
2021-03-02 20:53:13,693 : INFO : tokenize_signature : --> do i ever get here?
def receive_tcp(sock, expiration=None, one_rr_per_rrset=False,
                keyring=None, request_mac=b'', ignore_trailing=False):
    """
    Read a DNS message from a TCP socket.

        *sock*, a ``socket``.

        *expiration*, a ``float`` or ``None``, the absolute time at which
        a timeout exception should be raised.  If ``None``, no timeout will
        occur.

        *one_rr_per_rrset*, a ``bool``.  If ``True``, put each RR into its own
        RRset.

        *keyring*, a ``dict``, the keyring to use for TSIG.

        *request_mac*, a ``binary``, the MAC of the request (for TSIG).

        *ignore_trailing*, a ``bool``.  If ``True``, ignore trailing
        junk at end of the received message.

        Raises if the message is malformed, if network errors occur, of if
        there is a timeout.

        Returns a ``dns.message.Message`` object.
    
    """
def _connect(s, address):
    """
    'errno'
    """
2021-03-02 20:53:13,694 : INFO : tokenize_signature : --> do i ever get here?
def tcp(q, where, timeout=None, port=53, af=None, source=None, source_port=0,
        one_rr_per_rrset=False, ignore_trailing=False):
    """
    Return the response obtained after sending a query via TCP.

        *q*, a ``dns.message.Message``, the query to send

        *where*, a ``text`` containing an IPv4 or IPv6 address,  where
        to send the message.

        *timeout*, a ``float`` or ``None``, the number of seconds to wait before the
        query times out.  If ``None``, the default, wait forever.

        *port*, an ``int``, the port send the message to.  The default is 53.

        *af*, an ``int``, the address family to use.  The default is ``None``,
        which causes the address family to use to be inferred from the form of
        *where*.  If the inference attempt fails, AF_INET is used.  This
        parameter is historical; you need never set it.

        *source*, a ``text`` containing an IPv4 or IPv6 address, specifying
        the source address.  The default is the wildcard address.

        *source_port*, an ``int``, the port from which to send the message.
        The default is 0.

        *one_rr_per_rrset*, a ``bool``.  If ``True``, put each RR into its own
        RRset.

        *ignore_trailing*, a ``bool``.  If ``True``, ignore trailing
        junk at end of the received message.

        Returns a ``dns.message.Message``.
    
    """
2021-03-02 20:53:13,695 : INFO : tokenize_signature : --> do i ever get here?
2021-03-02 20:53:13,696 : INFO : tokenize_signature : --> do i ever get here?
2021-03-02 20:53:13,696 : INFO : tokenize_signature : --> do i ever get here?
def xfr(where, zone, rdtype=dns.rdatatype.AXFR, rdclass=dns.rdataclass.IN,
        timeout=None, port=53, keyring=None, keyname=None, relativize=True,
        af=None, lifetime=None, source=None, source_port=0, serial=0,
        use_udp=False, keyalgorithm=dns.tsig.default_algorithm):
    """
    Return a generator for the responses to a zone transfer.

        *where*.  If the inference attempt fails, AF_INET is used.  This
        parameter is historical; you need never set it.

        *zone*, a ``dns.name.Name`` or ``text``, the name of the zone to transfer.

        *rdtype*, an ``int`` or ``text``, the type of zone transfer.  The
        default is ``dns.rdatatype.AXFR``.  ``dns.rdatatype.IXFR`` can be
        used to do an incremental transfer instead.

        *rdclass*, an ``int`` or ``text``, the class of the zone transfer.
        The default is ``dns.rdataclass.IN``.

        *timeout*, a ``float``, the number of seconds to wait for each
        response message.  If None, the default, wait forever.

        *port*, an ``int``, the port send the message to.  The default is 53.

        *keyring*, a ``dict``, the keyring to use for TSIG.

        *keyname*, a ``dns.name.Name`` or ``text``, the name of the TSIG
        key to use.

        *relativize*, a ``bool``.  If ``True``, all names in the zone will be
        relativized to the zone origin.  It is essential that the
        relativize setting matches the one specified to
        ``dns.zone.from_xfr()`` if using this generator to make a zone.

        *af*, an ``int``, the address family to use.  The default is ``None``,
        which causes the address family to use to be inferred from the form of
        *where*.  If the inference attempt fails, AF_INET is used.  This
        parameter is historical; you need never set it.

        *lifetime*, a ``float``, the total number of seconds to spend
        doing the transfer.  If ``None``, the default, then there is no
        limit on the time the transfer may take.

        *source*, a ``text`` containing an IPv4 or IPv6 address, specifying
        the source address.  The default is the wildcard address.

        *source_port*, an ``int``, the port from which to send the message.
        The default is 0.

        *serial*, an ``int``, the SOA serial number to use as the base for
        an IXFR diff sequence (only meaningful if *rdtype* is
        ``dns.rdatatype.IXFR``).

        *use_udp*, a ``bool``.  If ``True``, use UDP (only meaningful for IXFR).

        *keyalgorithm*, a ``dns.name.Name`` or ``text``, the TSIG algorithm to use.

        Raises on errors, and so does the generator.

        Returns a generator of ``dns.message.Message`` objects.
    
    """
