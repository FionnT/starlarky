def BadZone(dns.exception.DNSException):
    """
    The DNS zone is malformed.
    """
def NoSOA(BadZone):
    """
    The DNS zone has no SOA RR at its origin.
    """
def NoNS(BadZone):
    """
    The DNS zone has no NS RRset at its origin.
    """
def UnknownOrigin(BadZone):
    """
    The DNS zone's origin is unknown.
    """
def Zone(object):
    """
    A DNS zone.

        A Zone is a mapping from names to nodes.  The zone object may be
        treated like a Python dictionary, e.g. zone[name] will retrieve
        the node associated with that name.  The I{name} may be a
        dns.name.Name object, or it may be a string.  In the either case,
        if the name is relative it is treated as relative to the origin of
        the zone.

        @ivar rdclass: The zone's rdata class; the default is class IN.
        @type rdclass: int
        @ivar origin: The origin of the zone.
        @type origin: dns.name.Name object
        @ivar nodes: A dictionary mapping the names of nodes in the zone to the
        nodes themselves.
        @type nodes: dict
        @ivar relativize: should names in the zone be relativized?
        @type relativize: bool
        @cvar node_factory: the factory used to create a new node
        @type node_factory: class or callable
    
    """
    def __init__(self, origin, rdclass=dns.rdataclass.IN, relativize=True):
        """
        Initialize a zone object.

                @param origin: The origin of the zone.
                @type origin: dns.name.Name object
                @param rdclass: The zone's rdata class; the default is class IN.
                @type rdclass: int
        """
    def __eq__(self, other):
        """
        Two zones are equal if they have the same origin, class, and
                nodes.
                @rtype: bool
        
        """
    def __ne__(self, other):
        """
        Are two zones not equal?
                @rtype: bool
        
        """
    def _validate_name(self, name):
        """
        name parameter must be convertible to a DNS name
        """
    def __getitem__(self, key):
        """
         pylint: disable=dict-keys-not-iterating
        """
    def keys(self):
        """
         pylint: disable=dict-keys-not-iterating
        """
    def itervalues(self):
        """
         pylint: disable=dict-values-not-iterating
        """
    def values(self):
        """
         pylint: disable=dict-values-not-iterating
        """
    def items(self):
        """
         pylint: disable=dict-items-not-iterating
        """
    def get(self, key):
        """
        Find a node in the zone, possibly creating it.

                @param name: the name of the node to find
                @type name: dns.name.Name object or string
                @param create: should the node be created if it doesn't exist?
                @type create: bool
                @raises KeyError: the name is not known and create was not specified.
                @rtype: dns.node.Node object
        
        """
    def get_node(self, name, create=False):
        """
        Get a node in the zone, possibly creating it.

                This method is like L{find_node}, except it returns None instead
                of raising an exception if the node does not exist and creation
                has not been requested.

                @param name: the name of the node to find
                @type name: dns.name.Name object or string
                @param create: should the node be created if it doesn't exist?
                @type create: bool
                @rtype: dns.node.Node object or None
        
        """
    def delete_node(self, name):
        """
        Delete the specified node if it exists.

                It is not an error if the node does not exist.
        
        """
2021-03-02 20:53:16,366 : INFO : tokenize_signature : --> do i ever get here?
    def find_rdataset(self, name, rdtype, covers=dns.rdatatype.NONE,
                      create=False):
        """
        Look for rdata with the specified name and type in the zone,
                and return an rdataset encapsulating it.

                The I{name}, I{rdtype}, and I{covers} parameters may be
                strings, in which case they will be converted to their proper
                type.

                The rdataset returned is not a copy; changes to it will change
                the zone.

                KeyError is raised if the name or type are not found.
                Use L{get_rdataset} if you want to have None returned instead.

                @param name: the owner name to look for
                @type name: DNS.name.Name object or string
                @param rdtype: the rdata type desired
                @type rdtype: int or string
                @param covers: the covered type (defaults to None)
                @type covers: int or string
                @param create: should the node and rdataset be created if they do not
                exist?
                @type create: bool
                @raises KeyError: the node or rdata could not be found
                @rtype: dns.rdataset.Rdataset object
        
        """
2021-03-02 20:53:16,367 : INFO : tokenize_signature : --> do i ever get here?
    def get_rdataset(self, name, rdtype, covers=dns.rdatatype.NONE,
                     create=False):
        """
        Look for rdata with the specified name and type in the zone,
                and return an rdataset encapsulating it.

                The I{name}, I{rdtype}, and I{covers} parameters may be
                strings, in which case they will be converted to their proper
                type.

                The rdataset returned is not a copy; changes to it will change
                the zone.

                None is returned if the name or type are not found.
                Use L{find_rdataset} if you want to have KeyError raised instead.

                @param name: the owner name to look for
                @type name: DNS.name.Name object or string
                @param rdtype: the rdata type desired
                @type rdtype: int or string
                @param covers: the covered type (defaults to None)
                @type covers: int or string
                @param create: should the node and rdataset be created if they do not
                exist?
                @type create: bool
                @rtype: dns.rdataset.Rdataset object or None
        
        """
    def delete_rdataset(self, name, rdtype, covers=dns.rdatatype.NONE):
        """
        Delete the rdataset matching I{rdtype} and I{covers}, if it
                exists at the node specified by I{name}.

                The I{name}, I{rdtype}, and I{covers} parameters may be
                strings, in which case they will be converted to their proper
                type.

                It is not an error if the node does not exist, or if there is no
                matching rdataset at the node.

                If the node has no rdatasets after the deletion, it will itself
                be deleted.

                @param name: the owner name to look for
                @type name: DNS.name.Name object or string
                @param rdtype: the rdata type desired
                @type rdtype: int or string
                @param covers: the covered type (defaults to None)
                @type covers: int or string
        
        """
    def replace_rdataset(self, name, replacement):
        """
        Replace an rdataset at name.

                It is not an error if there is no rdataset matching I{replacement}.

                Ownership of the I{replacement} object is transferred to the zone;
                in other words, this method does not store a copy of I{replacement}
                at the node, it stores I{replacement} itself.

                If the I{name} node does not exist, it is created.

                @param name: the owner name
                @type name: DNS.name.Name object or string
                @param replacement: the replacement rdataset
                @type replacement: dns.rdataset.Rdataset
        
        """
    def find_rrset(self, name, rdtype, covers=dns.rdatatype.NONE):
        """
        Look for rdata with the specified name and type in the zone,
                and return an RRset encapsulating it.

                The I{name}, I{rdtype}, and I{covers} parameters may be
                strings, in which case they will be converted to their proper
                type.

                This method is less efficient than the similar
                L{find_rdataset} because it creates an RRset instead of
                returning the matching rdataset.  It may be more convenient
                for some uses since it returns an object which binds the owner
                name to the rdata.

                This method may not be used to create new nodes or rdatasets;
                use L{find_rdataset} instead.

                KeyError is raised if the name or type are not found.
                Use L{get_rrset} if you want to have None returned instead.

                @param name: the owner name to look for
                @type name: DNS.name.Name object or string
                @param rdtype: the rdata type desired
                @type rdtype: int or string
                @param covers: the covered type (defaults to None)
                @type covers: int or string
                @raises KeyError: the node or rdata could not be found
                @rtype: dns.rrset.RRset object
        
        """
    def get_rrset(self, name, rdtype, covers=dns.rdatatype.NONE):
        """
        Look for rdata with the specified name and type in the zone,
                and return an RRset encapsulating it.

                The I{name}, I{rdtype}, and I{covers} parameters may be
                strings, in which case they will be converted to their proper
                type.

                This method is less efficient than the similar L{get_rdataset}
                because it creates an RRset instead of returning the matching
                rdataset.  It may be more convenient for some uses since it
                returns an object which binds the owner name to the rdata.

                This method may not be used to create new nodes or rdatasets;
                use L{find_rdataset} instead.

                None is returned if the name or type are not found.
                Use L{find_rrset} if you want to have KeyError raised instead.

                @param name: the owner name to look for
                @type name: DNS.name.Name object or string
                @param rdtype: the rdata type desired
                @type rdtype: int or string
                @param covers: the covered type (defaults to None)
                @type covers: int or string
                @rtype: dns.rrset.RRset object
        
        """
2021-03-02 20:53:16,369 : INFO : tokenize_signature : --> do i ever get here?
    def iterate_rdatasets(self, rdtype=dns.rdatatype.ANY,
                          covers=dns.rdatatype.NONE):
        """
        Return a generator which yields (name, rdataset) tuples for
                all rdatasets in the zone which have the specified I{rdtype}
                and I{covers}.  If I{rdtype} is dns.rdatatype.ANY, the default,
                then all rdatasets will be matched.

                @param rdtype: int or string
                @type rdtype: int or string
                @param covers: the covered type (defaults to None)
                @type covers: int or string
        
        """
2021-03-02 20:53:16,371 : INFO : tokenize_signature : --> do i ever get here?
    def iterate_rdatas(self, rdtype=dns.rdatatype.ANY,
                       covers=dns.rdatatype.NONE):
        """
        Return a generator which yields (name, ttl, rdata) tuples for
                all rdatas in the zone which have the specified I{rdtype}
                and I{covers}.  If I{rdtype} is dns.rdatatype.ANY, the default,
                then all rdatas will be matched.

                @param rdtype: int or string
                @type rdtype: int or string
                @param covers: the covered type (defaults to None)
                @type covers: int or string
        
        """
    def to_file(self, f, sorted=True, relativize=True, nl=None):
        """
        Write a zone to a file.

                @param f: file or string.  If I{f} is a string, it is treated
                as the name of a file to open.
                @param sorted: if True, the file will be written with the
                names sorted in DNSSEC order from least to greatest.  Otherwise
                the names will be written in whatever order they happen to have
                in the zone's dictionary.
                @param relativize: if True, domain names in the output will be
                relativized to the zone's origin (if possible).
                @type relativize: bool
                @param nl: The end of line string.  If not specified, the
                output will use the platform's native end-of-line marker (i.e.
                LF on POSIX, CRLF on Windows, CR on Macintosh).
                @type nl: string or None
        
        """
    def to_text(self, sorted=True, relativize=True, nl=None):
        """
        Return a zone's text as though it were written to a file.

                @param sorted: if True, the file will be written with the
                names sorted in DNSSEC order from least to greatest.  Otherwise
                the names will be written in whatever order they happen to have
                in the zone's dictionary.
                @param relativize: if True, domain names in the output will be
                relativized to the zone's origin (if possible).
                @type relativize: bool
                @param nl: The end of line string.  If not specified, the
                output will use the platform's native end-of-line marker (i.e.
                LF on POSIX, CRLF on Windows, CR on Macintosh).
                @type nl: string or None
        
        """
    def check_origin(self):
        """
        Do some simple checking of the zone's origin.

                @raises dns.zone.NoSOA: there is no SOA RR
                @raises dns.zone.NoNS: there is no NS RRset
                @raises KeyError: there is no origin node
        
        """
def _MasterReader(object):
    """
    Read a DNS master file

        @ivar tok: The tokenizer
        @type tok: dns.tokenizer.Tokenizer object
        @ivar last_ttl: The last seen explicit TTL for an RR
        @type last_ttl: int
        @ivar last_ttl_known: Has last TTL been detected
        @type last_ttl_known: bool
        @ivar default_ttl: The default TTL from a $TTL directive or SOA RR
        @type default_ttl: int
        @ivar default_ttl_known: Has default TTL been detected
        @type default_ttl_known: bool
        @ivar last_name: The last name read
        @type last_name: dns.name.Name object
        @ivar current_origin: The current origin
        @type current_origin: dns.name.Name object
        @ivar relativize: should names in the zone be relativized?
        @type relativize: bool
        @ivar zone: the zone
        @type zone: dns.zone.Zone object
        @ivar saved_state: saved reader state (used when processing $INCLUDE)
        @type saved_state: list of (tokenizer, current_origin, last_name, file,
        last_ttl, last_ttl_known, default_ttl, default_ttl_known) tuples.
        @ivar current_file: the file object of the $INCLUDed file being parsed
        (None if no $INCLUDE is active).
        @ivar allow_include: is $INCLUDE allowed?
        @type allow_include: bool
        @ivar check_origin: should sanity checks of the origin node be done?
        The default is True.
        @type check_origin: bool
    
    """
2021-03-02 20:53:16,373 : INFO : tokenize_signature : --> do i ever get here?
    def __init__(self, tok, origin, rdclass, relativize, zone_factory=Zone,
                 allow_include=False, check_origin=True):
        """
        Process one line from a DNS master file.
        """
    def _parse_modify(self, side):
        """
         Here we catch everything in '{' '}' in a group so we can replace it
         with ''.

        """
    def _generate_line(self):
        """
         range lhs [ttl] [class] type rhs [ comment ]

        """
    def read(self):
        """
        Read a DNS master file and build a zone object.

                @raises dns.zone.NoSOA: No SOA RR was found at the zone origin
                @raises dns.zone.NoNS: No NS RRset was found at the zone origin
        
        """
2021-03-02 20:53:16,383 : INFO : tokenize_signature : --> do i ever get here?
2021-03-02 20:53:16,383 : INFO : tokenize_signature : --> do i ever get here?
def from_text(text, origin=None, rdclass=dns.rdataclass.IN,
              relativize=True, zone_factory=Zone, filename=None,
              allow_include=False, check_origin=True):
    """
    Build a zone object from a master file format string.

        @param text: the master file format input
        @type text: string.
        @param origin: The origin of the zone; if not specified, the first
        $ORIGIN statement in the master file will determine the origin of the
        zone.
        @type origin: dns.name.Name object or string
        @param rdclass: The zone's rdata class; the default is class IN.
        @type rdclass: int
        @param relativize: should names be relativized?  The default is True
        @type relativize: bool
        @param zone_factory: The zone factory to use
        @type zone_factory: function returning a Zone
        @param filename: The filename to emit when describing where an error
        occurred; the default is '<string>'.
        @type filename: string
        @param allow_include: is $INCLUDE allowed?
        @type allow_include: bool
        @param check_origin: should sanity checks of the origin node be done?
        The default is True.
        @type check_origin: bool
        @raises dns.zone.NoSOA: No SOA RR was found at the zone origin
        @raises dns.zone.NoNS: No NS RRset was found at the zone origin
        @rtype: dns.zone.Zone object
    
    """
2021-03-02 20:53:16,384 : INFO : tokenize_signature : --> do i ever get here?
2021-03-02 20:53:16,384 : INFO : tokenize_signature : --> do i ever get here?
def from_file(f, origin=None, rdclass=dns.rdataclass.IN,
              relativize=True, zone_factory=Zone, filename=None,
              allow_include=True, check_origin=True):
    """
    Read a master file and build a zone object.

        @param f: file or string.  If I{f} is a string, it is treated
        as the name of a file to open.
        @param origin: The origin of the zone; if not specified, the first
        $ORIGIN statement in the master file will determine the origin of the
        zone.
        @type origin: dns.name.Name object or string
        @param rdclass: The zone's rdata class; the default is class IN.
        @type rdclass: int
        @param relativize: should names be relativized?  The default is True
        @type relativize: bool
        @param zone_factory: The zone factory to use
        @type zone_factory: function returning a Zone
        @param filename: The filename to emit when describing where an error
        occurred; the default is '<file>', or the value of I{f} if I{f} is a
        string.
        @type filename: string
        @param allow_include: is $INCLUDE allowed?
        @type allow_include: bool
        @param check_origin: should sanity checks of the origin node be done?
        The default is True.
        @type check_origin: bool
        @raises dns.zone.NoSOA: No SOA RR was found at the zone origin
        @raises dns.zone.NoNS: No NS RRset was found at the zone origin
        @rtype: dns.zone.Zone object
    
    """
def from_xfr(xfr, zone_factory=Zone, relativize=True, check_origin=True):
    """
    Convert the output of a zone transfer generator into a zone object.

        @param xfr: The xfr generator
        @type xfr: generator of dns.message.Message objects
        @param relativize: should names be relativized?  The default is True.
        It is essential that the relativize setting matches the one specified
        to dns.query.xfr().
        @type relativize: bool
        @param check_origin: should sanity checks of the origin node be done?
        The default is True.
        @type check_origin: bool
        @raises dns.zone.NoSOA: No SOA RR was found at the zone origin
        @raises dns.zone.NoNS: No NS RRset was found at the zone origin
        @rtype: dns.zone.Zone object
    
    """
