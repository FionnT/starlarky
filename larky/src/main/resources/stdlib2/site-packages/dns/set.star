def Set(object):
    """
    A simple set class.

        This class was originally used to deal with sets being missing in
        ancient versions of python, but dnspython will continue to use it
        as these sets are based on lists and are thus indexable, and this
        ability is widely used in dnspython applications.
    
    """
    def __init__(self, items=None):
        """
        Initialize the set.

                *items*, an iterable or ``None``, the initial set of items.
        
        """
    def __repr__(self):
        """
        dns.simpleset.Set(%s)
        """
    def add(self, item):
        """
        Add an item to the set.
        
        """
    def remove(self, item):
        """
        Remove an item from the set.
        
        """
    def discard(self, item):
        """
        Remove an item from the set if present.
        
        """
    def _clone(self):
        """
        Make a (shallow) copy of the set.

                There is a 'clone protocol' that subclasses of this class
                should use.  To make a copy, first call your super's _clone()
                method, and use the object returned as the new instance.  Then
                make shallow copies of the attributes defined in the subclass.

                This protocol allows us to write the set algorithms that
                return new instances (e.g. union) once, and keep using them in
                subclasses.
        
        """
    def __copy__(self):
        """
        Make a (shallow) copy of the set.
        
        """
    def copy(self):
        """
        Make a (shallow) copy of the set.
        
        """
    def union_update(self, other):
        """
        Update the set, adding any elements from other which are not
                already in the set.
        
        """
    def intersection_update(self, other):
        """
        Update the set, removing any elements from other which are not
                in both sets.
        
        """
    def difference_update(self, other):
        """
        Update the set, removing any elements from other which are in
                the set.
        
        """
    def union(self, other):
        """
        Return a new set which is the union of ``self`` and ``other``.

                Returns the same Set type as this set.
        
        """
    def intersection(self, other):
        """
        Return a new set which is the intersection of ``self`` and
                ``other``.

                Returns the same Set type as this set.
        
        """
    def difference(self, other):
        """
        Return a new set which ``self`` - ``other``, i.e. the items
                in ``self`` which are not also in ``other``.

                Returns the same Set type as this set.
        
        """
    def __or__(self, other):
        """
        Update the set, adding any elements from other which are not
                already in the set.

                *other*, the collection of items with which to update the set, which
                may be any iterable type.
        
        """
    def clear(self):
        """
        Make the set empty.
        """
    def __eq__(self, other):
        """
         Yes, this is inefficient but the sets we're dealing with are
         usually quite small, so it shouldn't hurt too much.

        """
    def __ne__(self, other):
        """
        Is this set a subset of *other*?

                Returns a ``bool``.
        
        """
    def issuperset(self, other):
        """
        Is this set a superset of *other*?

                Returns a ``bool``.
        
        """
