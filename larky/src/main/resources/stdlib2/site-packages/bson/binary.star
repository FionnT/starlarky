def UuidRepresentation:
    """
    An unspecified UUID representation.

        When configured, :class:`uuid.UUID` instances will **not** be
        automatically encoded to or decoded from :class:`~bson.binary.Binary`.
        When encoding a :class:`uuid.UUID` instance, an error will be raised.
        To encode a :class:`uuid.UUID` instance with this configuration, it must
        be wrapped in the :class:`~bson.binary.Binary` class by the application
        code. When decoding a BSON binary field with a UUID subtype, a
        :class:`~bson.binary.Binary` instance will be returned instead of a
        :class:`uuid.UUID` instance.
    
        See :ref:`unspecified-representation-details` for details.

        .. versionadded:: 3.11
    
    """
def Binary(bytes):
    """
    Representation of BSON binary data.

        This is necessary because we want to represent Python strings as
        the BSON string type. We need to wrap binary data so we can tell
        the difference between what should be considered binary data and
        what should be considered a string when we encode to BSON.

        Raises TypeError if `data` is not an instance of :class:`bytes`
        (:class:`str` in python 2) or `subtype` is not an instance of
        :class:`int`. Raises ValueError if `subtype` is not in [0, 256).

        .. note::
          In python 3 instances of Binary with subtype 0 will be decoded
          directly to :class:`bytes`.

        :Parameters:
          - `data`: the binary data to represent. Can be any bytes-like type
            that implements the buffer protocol.
          - `subtype` (optional): the `binary subtype
            <http://bsonspec.org/#/specification>`_
            to use

        .. versionchanged:: 3.9
          Support any bytes-like type that implements the buffer protocol.
    
    """
    def __new__(cls, data, subtype=BINARY_SUBTYPE):
        """
        subtype must be an instance of int
        """
    def from_uuid(cls, uuid, uuid_representation=UuidRepresentation.STANDARD):
        """
        Create a BSON Binary object from a Python UUID.

                Creates a :class:`~bson.binary.Binary` object from a
                :class:`uuid.UUID` instance. Assumes that the native
                :class:`uuid.UUID` instance uses the byte-order implied by the
                provided ``uuid_representation``.

                Raises :exc:`TypeError` if `uuid` is not an instance of
                :class:`~uuid.UUID`.

                :Parameters:
                  - `uuid`: A :class:`uuid.UUID` instance.
                  - `uuid_representation`: A member of
                    :class:`~bson.binary.UuidRepresentation`. Default:
                    :const:`~bson.binary.UuidRepresentation.STANDARD`.
                    See :ref:`handling-uuid-data-example` for details.

                .. versionadded:: 3.11
        
        """
    def as_uuid(self, uuid_representation=UuidRepresentation.STANDARD):
        """
        Create a Python UUID from this BSON Binary object.

                Decodes this binary object as a native :class:`uuid.UUID` instance
                with the provided ``uuid_representation``.

                Raises :exc:`ValueError` if this :class:`~bson.binary.Binary` instance
                does not contain a UUID.

                :Parameters:
                  - `uuid_representation`: A member of
                    :class:`~bson.binary.UuidRepresentation`. Default:
                    :const:`~bson.binary.UuidRepresentation.STANDARD`.
                    See :ref:`handling-uuid-data-example` for details.

                .. versionadded:: 3.11
        
        """
    def subtype(self):
        """
        Subtype of this binary data.
        
        """
    def __getnewargs__(self):
        """
         Work around http://bugs.python.org/issue7382

        """
    def __eq__(self, other):
        """
         We don't return NotImplemented here because if we did then
         Binary("foo") == "foo" would return True, since Binary is a
         subclass of str...

        """
    def __hash__(self):
        """
        Binary(%s, %s)
        """
def UUIDLegacy(Binary):
    """
    **DEPRECATED** - UUID wrapper to support working with UUIDs stored as
        PYTHON_LEGACY.

        .. note:: This class has been deprecated and will be removed in
           PyMongo 4.0. Use :meth:`~bson.binary.Binary.from_uuid` and
           :meth:`~bson.binary.Binary.as_uuid` with the appropriate
           :class:`~bson.binary.UuidRepresentation` to handle legacy-formatted
           UUIDs instead.::

                from bson import Binary, UUIDLegacy, UuidRepresentation
                import uuid

                my_uuid = uuid.uuid4()
                legacy_uuid = UUIDLegacy(my_uuid)
                binary_uuid = Binary.from_uuid(
                    my_uuid, UuidRepresentation.PYTHON_LEGACY)

                assert legacy_uuid == binary_uuid
                assert legacy_uuid.uuid == binary_uuid.as_uuid(
                    UuidRepresentation.PYTHON_LEGACY)

        .. doctest::

          >>> import uuid
          >>> from bson.binary import Binary, UUIDLegacy, STANDARD
          >>> from bson.codec_options import CodecOptions
          >>> my_uuid = uuid.uuid4()
          >>> coll = db.get_collection('test',
          ...                          CodecOptions(uuid_representation=STANDARD))
          >>> coll.insert_one({'uuid': Binary(my_uuid.bytes, 3)}).inserted_id
          ObjectId('...')
          >>> coll.count_documents({'uuid': my_uuid})
          0
          >>> coll.count_documents({'uuid': UUIDLegacy(my_uuid)})
          1
          >>> coll.find({'uuid': UUIDLegacy(my_uuid)})[0]['uuid']
          UUID('...')
          >>>
          >>> # Convert from subtype 3 to subtype 4
          >>> doc = coll.find_one({'uuid': UUIDLegacy(my_uuid)})
          >>> coll.replace_one({"_id": doc["_id"]}, doc).matched_count
          1
          >>> coll.count_documents({'uuid': UUIDLegacy(my_uuid)})
          0
          >>> coll.count_documents({'uuid': {'$in': [UUIDLegacy(my_uuid), my_uuid]}})
          1
          >>> coll.find_one({'uuid': my_uuid})['uuid']
          UUID('...')

        Raises :exc:`TypeError` if `obj` is not an instance of :class:`~uuid.UUID`.

        :Parameters:
          - `obj`: An instance of :class:`~uuid.UUID`.

        .. versionchanged:: 3.11
           Deprecated. The same functionality can be replicated using the
           :meth:`~Binary.from_uuid` and :meth:`~Binary.to_uuid` methods with
           :data:`~UuidRepresentation.PYTHON_LEGACY`.
        .. versionadded:: 2.1
    
    """
    def __new__(cls, obj):
        """
        The UUIDLegacy class has been deprecated and will be removed 
        in PyMongo 4.0. Use the Binary.from_uuid() and Binary.to_uuid() 
        with the appropriate UuidRepresentation to handle 
        legacy-formatted UUIDs instead.
        """
    def __getnewargs__(self):
        """
         Support copy and deepcopy

        """
    def uuid(self):
        """
        UUID instance wrapped by this UUIDLegacy instance.
        
        """
    def __repr__(self):
        """
        UUIDLegacy('%s')
        """
