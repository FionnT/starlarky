    def sphinxify(doc):
        """
        'text/html'
        """
def ProvisionalWarning(DeprecationWarning):
    """

        Warning class for unstable features
    
    """
def removed_co_newlocals(function:types.FunctionType) -> types.FunctionType:
    """
    Return a function that do not create a new local scope. 

        Given a function, create a clone of this function where the co_newlocal flag
        has been removed, making this function code actually run in the sourounding
        scope. 

        We need this in order to run asynchronous code in user level namespace.
    
    """
def _ast_asyncify(cell:str, wrapper_name:str) -> ast.Module:
    """

        Parse a cell with top-level await and modify the AST to be able to run it later.

        Parameter
        ---------

        cell: str
            The code cell to asyncronify
        wrapper_name: str
            The name of the function to be used to wrap the passed `cell`. It is
            advised to **not** use a python identifier in order to not pollute the
            global namespace in which the function will be ran.

        Return
        ------

        A module object AST containing **one** function named `wrapper_name`.

        The given code is wrapped in a async-def function, parsed into an AST, and
        the resulting function definition AST is modified to return the last
        expression.

        The last expression or await node is moved into a return statement at the
        end of the function, and removed from its original location. If the last
        node is not Expr or Await nothing is done.

        The function `__code__` will need to be later modified  (by
        ``removed_co_newlocals``) in a subsequent step to not create new `locals()`
        meaning that the local and global scope are the same, ie as if the body of
        the function was at module level.

        Lastly a call to `locals()` is made just before the last expression of the
        function, or just after the last assignment or statement to make sure the
        global dict is updated as python function work with a local fast cache which
        is updated only on `local()` calls.
    
    """
def softspace(file, newvalue):
    """
    Copied from code.py, to remove the dependency
    """
def no_op(*a, **kw):
    """
    DEPRECATED
    """
def SeparateUnicode(Unicode):
    """
    r"""A Unicode subclass to validate separate_in, separate_out, etc.

        This is a Unicode based trait that converts '0'->'' and ``'\\n'->'\n'``.
    
    """
    def validate(self, obj, value):
        """
        '0'
        """
def DummyMod(object):
    """
    A dummy module used for IPython's interactive module when
        a namespace must be assigned to the module's __dict__.
    """
def ExecutionInfo(object):
    """
    The arguments used for a call to :meth:`InteractiveShell.run_cell`

        Stores information about what is going to happen.
    
    """
    def __init__(self, raw_cell, store_history, silent, shell_futures):
        """
        '..'
        """
def ExecutionResult(object):
    """
    The result of a call to :meth:`InteractiveShell.run_cell`

        Stores information about what took place.
    
    """
    def __init__(self, info):
        """
        Reraises error if `success` is `False`, otherwise does nothing
        """
    def __repr__(self):
        """
        '<%s object at %x, execution_count=%s error_before_exec=%s error_in_exec=%s info=%s result=%s>'
        """
def InteractiveShell(SingletonConfigurable):
    """
    An enhanced, interactive shell for Python.
    """
    def _default_loop_runner(self):
        """
        IPython.core.interactiveshell._asyncio_runner
        """
    def _import_runner(self, proposal):
        """
        'loop_runner must be callable'
        """
    def _sphinxify_docstring_changed(self, change):
        """
        'new'
        """
    def _enable_html_pager_changed(self, change):
        """
        'new'
        """
    def _exiter_default(self):
        """
         Monotonically increasing execution counter

        """
    def input_transformers_cleanup(self):
        """
        A list of string input transformers, to be applied after IPython's 
        own input transformations.

        """
    def input_splitter(self):
        """
        Make this available for backward compatibility (pre-7.0 release) with existing code.

                For example, ipykernel ipykernel currently uses
                `shell.input_splitter.check_complete`
        
        """
    def _prompt_trait_changed(self, change):
        """
        'name'
        """
    def profile(self):
        """
        'profile_'
        """
2021-03-02 20:49:18,891 : INFO : tokenize_signature : --> do i ever get here?
2021-03-02 20:49:18,892 : INFO : tokenize_signature : --> do i ever get here?
    def __init__(self, ipython_dir=None, profile_dir=None,
                 user_module=None, user_ns=None,
                 custom_exceptions=((), None), **kwargs):
        """
         This is where traits with a config_key argument are updated
         from the values on config.

        """
    def get_ipython(self):
        """
        Return the currently running IPython instance.
        """
    def _ipython_dir_changed(self, change):
        """
        'new'
        """
    def set_autoindent(self,value=None):
        """
        Set the autoindent flag.

                If called with no arguments, it acts as a toggle.
        """
    def set_trio_runner(self, tr):
        """
        -------------------------------------------------------------------------
         init_* methods called by __init__
        -------------------------------------------------------------------------


        """
    def init_ipython_dir(self, ipython_dir):
        """
        'default'
        """
    def init_instance_attrs(self):
        """
         command compiler

        """
    def init_environment(self):
        """
        Any changes we need to make to the user's environment.
        """
    def init_encoding(self):
        """
         Get system encoding at startup time.  Certain terminals (like Emacs
         under Win32 have it set to None, and we need to have a known valid
         encoding to use in the raw_input() method

        """
    def init_syntax_highlighting(self, changes=None):
        """
         Python source parser/formatter for syntax highlighting

        """
    def refresh_style(self):
        """
         No-op here, used in subclass

        """
    def init_pushd_popd_magic(self):
        """
         for pushd/popd management

        """
    def init_logger(self):
        """
        'ipython_log.py'
        """
    def init_logstart(self):
        """
        Initialize logging in case it was requested at the command line.
        
        """
    def init_deprecation_warnings(self):
        """

                register default filter for deprecation warning.

                This will allow deprecation warning of function used interactively to show
                warning to users, and still hide deprecation warning from libraries import.
        
        """
    def init_builtins(self):
        """
         A single, static flag that we set to True.  Its presence indicates
         that an IPython shell has been created, and we make no attempts at
         removing on exit or representing the existence of more than one
         IPython at a time.

        """
    def init_inspector(self, changes=None):
        """
         Object inspector

        """
    def init_io(self):
        """
         This will just use sys.stdout and sys.stderr. If you want to
         override sys.stdout and sys.stderr themselves, you need to do that
         *before* instantiating this class, because io holds onto
         references to the underlying streams.
         io.std* are deprecated, but don't show our own deprecation warnings
         during initialization of the deprecated API.

        """
    def init_prompts(self):
        """
         Set system prompts, so that scripts can decide if they are running
         interactively.

        """
    def init_display_formatter(self):
        """
         Initialize displayhook, set in/out prompts and printing system

        """
    def init_virtualenv(self):
        """
        Add a virtualenv to sys.path so the user can import modules from it.
                This isn't perfect: it doesn't use the Python interpreter with which the
                virtualenv was built, and it ignores the --no-site-packages option. A
                warning will appear suggesting the user installs IPython in the
                virtualenv, but for many cases, it probably works well enough.
        
                Adapted from code snippets online.
        
                http://blog.ufsoft.org/2009/1/29/ipython-and-virtualenv
        
        """
    def save_sys_module_state(self):
        """
        Save the state of hooks in the sys module.

                This has to be called after self.user_module is created.
        
        """
    def restore_sys_module_state(self):
        """
        Restore the state of the sys module.
        """
    def banner(self):
        """
        'default'
        """
    def show_banner(self, banner=None):
        """
        -------------------------------------------------------------------------
         Things related to hooks
        -------------------------------------------------------------------------


        """
    def init_hooks(self):
        """
         hooks holds pointers used for user-side customizations

        """
2021-03-02 20:49:18,901 : INFO : tokenize_signature : --> do i ever get here?
    def set_hook(self,name,hook, priority=50, str_key=None, re_key=None,
                 _warn_deprecated=True):
        """
        set_hook(name,hook) -> sets an internal IPython hook.

                IPython exposes some of its internal API as user-modifiable hooks.  By
                adding your function to one of these hooks, you can modify IPython's
                behavior to call at runtime your own routines.
        """
    def init_events(self):
        """
        pre_execute
        """
    def register_post_execute(self, func):
        """
        DEPRECATED: Use ip.events.register('post_run_cell', func)
        
                Register a function for calling after code execution.
        
        """
    def _clear_warning_registry(self):
        """
         clear the warning registry, so that different code blocks with
         overlapping line number ranges don't cause spurious suppression of
         warnings (see gh-6611 for details)

        """
    def new_main_mod(self, filename, modname):
        """
        Return a new 'main' module object for user code execution.
        
                ``filename`` should be the path of the script which will be run in the
                module. Requests with the same filename will get the same module, with
                its namespace cleared.
        
                ``modname`` should be the module name - normally either '__main__' or
                the basename of the file without the extension.
        
                When scripts are executed via %run, we must keep a reference to their
                __main__ module around so that Python doesn't
                clear it, rendering references to module globals useless.

                This method keeps said reference in a private dict, keyed by the
                absolute path of the script. This way, for multiple executions of the
                same script we only keep one copy of the namespace (the last one),
                thus preventing memory leaks from old references while allowing the
                objects from the last execution to be accessible.
        
        """
    def clear_main_mod_cache(self):
        """
        Clear the cache of main modules.

                Mainly for use by utilities like %reset.

                Examples
                --------

                In [15]: import IPython

                In [16]: m = _ip.new_main_mod(IPython.__file__, 'IPython')

                In [17]: len(_ip._main_mod_cache) > 0
                Out[17]: True

                In [18]: _ip.clear_main_mod_cache()

                In [19]: len(_ip._main_mod_cache) == 0
                Out[19]: True
        
        """
    def init_pdb(self):
        """
         Set calling of pdb on exceptions
         self.call_pdb is a property

        """
    def _get_call_pdb(self):
        """
        'new call_pdb value must be boolean'
        """
    def debugger(self,force=False):
        """
        Call the pdb debugger.

                Keywords:

                  - force(False): by default, this routine checks the instance call_pdb
                    flag and does not actually invoke the debugger if the flag is false.
                    The 'force' option forces the debugger to activate even if the flag
                    is false.
        
        """
    def init_create_namespaces(self, user_module=None, user_ns=None):
        """
         Create the namespace where the user will operate.  user_ns is
         normally the only one used, and it is passed to the exec calls as
         the locals argument.  But we do carry a user_global_ns namespace
         given as the exec 'globals' argument,  This is useful in embedding
         situations where the ipython shell opens in a context where the
         distinction between locals and globals is meaningful.  For
         non-embedded contexts, it is just the same object as the user_ns dict.

         FIXME. For some strange reason, __builtins__ is showing up at user
         level as a dict instead of a module. This is a manual fix, but I
         should really track down where the problem is coming from. Alex
         Schmolck reported this problem first.

         A useful post by Alex Martelli on this topic:
         Re: inconsistent value from __builtins__
         Von: Alex Martelli <aleaxit@yahoo.com>
         Datum: Freitag 01 Oktober 2004 04:45:34 nachmittags/abends
         Gruppen: comp.lang.python

         Michael Hohn <hohn@hooknose.lbl.gov> wrote:
         > >>> print type(builtin_check.get_global_binding('__builtins__'))
         > <type 'dict'>
         > >>> print type(__builtins__)
         > <type 'module'>
         > Is this difference in return value intentional?

         Well, it's documented that '__builtins__' can be either a dictionary
         or a module, and it's been that way for a long time. Whether it's
         intentional (or sensible), I don't know. In any case, the idea is
         that if you need to access the built-in namespace directly, you
         should start with "import __builtin__" (note, no 's') which will
         definitely give you a module. Yeah, it's somewhat confusing:-(.

         These routines return a properly built module and dict as needed by
         the rest of the code, and can also be used by extension writers to
         generate properly initialized namespaces.

        """
    def user_global_ns(self):
        """
        Prepare the module and namespace in which user code will be run.
        
                When IPython is started normally, both parameters are None: a new module
                is created automatically, and its __dict__ used as the namespace.
        
                If only user_module is provided, its __dict__ is used as the namespace.
                If only user_ns is provided, a dummy module is created, and user_ns
                becomes the global namespace. If both are provided (as they may be
                when embedding), user_ns is the local namespace, and user_module
                provides the global namespace.

                Parameters
                ----------
                user_module : module, optional
                    The current user module in which IPython is being run. If None,
                    a clean module will be created.
                user_ns : dict, optional
                    A namespace in which to run interactive commands.

                Returns
                -------
                A tuple of user_module and user_ns, each properly initialised.
        
        """
    def init_sys_modules(self):
        """
         We need to insert into sys.modules something that looks like a
         module but which accesses the IPython namespace, for shelve and
         pickle to work interactively. Normally they rely on getting
         everything out of __main__, but for embedding purposes each IPython
         instance has its own private namespace, so we can't go shoving
         everything into __main__.

         note, however, that we should only do this for non-embedded
         ipythons, which really mimic the __main__.__dict__ with their own
         namespace.  Embedded instances, on the other hand, should not do
         this because they need to manage the user local/global namespaces
         only, but they live within a 'normal' __main__ (meaning, they
         shouldn't overtake the execution environment of the script they're
         embedded in).

         This is overridden in the InteractiveShellEmbed subclass to a no-op.

        """
    def init_user_ns(self):
        """
        Initialize all user-visible namespaces to their minimum defaults.

                Certain history lists are also initialized here, as they effectively
                act as user namespaces.

                Notes
                -----
                All data structures here are only filled in, they are NOT reset by this
                method.  If they were not empty before, data will simply be added to
                them.
        
        """
    def all_ns_refs(self):
        """
        Get a list of references to all the namespace dictionaries in which
                IPython might store a user-created object.
        
                Note that this does not include the displayhook, which also caches
                objects from the output.
        """
    def reset(self, new_session=True):
        """
        Clear all internal namespaces, and attempt to release references to
                user objects.

                If new_session is True, a new history session will be opened.
        
        """
    def del_var(self, varname, by_name=False):
        """
        Delete a variable from the various namespaces, so that, as
                far as possible, we're not keeping any hidden references to it.

                Parameters
                ----------
                varname : str
                    The name of the variable to delete.
                by_name : bool
                    If True, delete variables with the given name in each
                    namespace. If False (default), find the variable in the user
                    namespace, and delete references to it.
        
        """
    def reset_selective(self, regex=None):
        """
        Clear selective variables from internal namespaces based on a
                specified regular expression.

                Parameters
                ----------
                regex : string or compiled pattern, optional
                    A regular expression pattern that will be used in searching
                    variable names in the users namespaces.
        
        """
    def push(self, variables, interactive=True):
        """
        Inject a group of variables into the IPython user namespace.

                Parameters
                ----------
                variables : dict, str or list/tuple of str
                    The variables to inject into the user's namespace.  If a dict, a
                    simple update is done.  If a str, the string is assumed to have
                    variable names separated by spaces.  A list/tuple of str can also
                    be used to give the variable names.  If just the variable names are
                    give (list/tuple/str) then the variable values looked up in the
                    callers frame.
                interactive : bool
                    If True (default), the variables will be listed with the ``who``
                    magic.
        
        """
    def drop_by_id(self, variables):
        """
        Remove a dict of variables from the user namespace, if they are the
                same as the values in the dictionary.
        
                This is intended for use by extensions: variables that they've added can
                be taken back out if they are unloaded, without removing any that the
                user has overwritten.
        
                Parameters
                ----------
                variables : dict
                  A dictionary mapping object names (as strings) to the objects.
        
        """
    def _ofind(self, oname, namespaces=None):
        """
        Find an object in the available namespaces.

                self._ofind(oname) -> dict with keys: found,obj,ospace,ismagic

                Has special code to detect magic functions.
        
        """
    def _getattr_property(obj, attrname):
        """
        Property-aware getattr to use in object finding.

                If attrname represents a property, return it unevaluated (in case it has
                side effects or raises an error.

        
        """
    def _object_find(self, oname, namespaces=None):
        """
        Find an object and return a struct with info about it.
        """
    def _inspect(self, meth, oname, namespaces=None, **kw):
        """
        Generic interface to the inspector system.

                This function is meant to be called by pdef, pdoc & friends.
        
        """
    def object_inspect(self, oname, detail_level=0):
        """
        Get object info about oname
        """
    def object_inspect_text(self, oname, detail_level=0):
        """
        Get object info as formatted text
        """
    def object_inspect_mime(self, oname, detail_level=0):
        """
        Get object info as a mimebundle of formatted representations.

                A mimebundle is a dictionary, keyed by mime-type.
                It must always have the key `'text/plain'`.
        
        """
    def init_history(self):
        """
        Sets up the command history, and starts regular autosaves.
        """
    def init_traceback_handlers(self, custom_exceptions):
        """
         Syntax error handler.

        """
    def set_custom_exc(self, exc_tuple, handler):
        """
        set_custom_exc(exc_tuple, handler)

                Set a custom exception handler, which will be called if any of the
                exceptions in exc_tuple occur in the mainloop (specifically, in the
                run_code() method).

                Parameters
                ----------

                exc_tuple : tuple of exception classes
                    A *tuple* of exception classes, for which to call the defined
                    handler.  It is very important that you use a tuple, and NOT A
                    LIST here, because of the way Python's except statement works.  If
                    you only want to trap a single exception, use a singleton tuple::

                        exc_tuple == (MyCustomException,)

                handler : callable
                    handler must have the following signature::

                        def my_handler(self, etype, value, tb, tb_offset=None):
                            ...
                            return structured_traceback

                    Your handler must return a structured traceback (a list of strings),
                    or None.

                    This will be made into an instance method (via types.MethodType)
                    of IPython itself, and it will be called if any of the exceptions
                    listed in the exc_tuple are caught. If the handler is None, an
                    internal basic one is used, which just prints basic info.

                    To protect IPython from crashes, if your handler ever raises an
                    exception or returns an invalid result, it will be immediately
                    disabled.

                WARNING: by putting in your own exception handler into IPython's main
                execution loop, you run a very good chance of nasty crashes.  This
                facility should only be used if you really know what you are doing.
        """
        def dummy_handler(self, etype, value, tb, tb_offset=None):
            """
            '*** Simple custom exception handler ***'
            """
        def validate_stb(stb):
            """
            validate structured traceback return type
            
                        return type of CustomTB *should* be a list of strings, but allow
                        single strings or None, which are harmless.
            
                        This function will *always* return a list of strings,
                        and will raise a TypeError if stb is inappropriate.
            
            """
            def wrapped(self,etype,value,tb,tb_offset=None):
                """
                wrap CustomTB handler, to protect IPython from user code
                
                                This makes it harder (but not impossible) for custom exception
                                handlers to crash IPython.
                
                """
    def excepthook(self, etype, value, tb):
        """
        One more defense for GUI apps that call sys.excepthook.

                GUI frameworks like wxPython trap exceptions and call
                sys.excepthook themselves.  I guess this is a feature that
                enables them to keep running after exceptions that would
                otherwise kill their mainloop. This is a bother for IPython
                which excepts to catch all of the program exceptions with a try:
                except: statement.

                Normally, IPython sets sys.excepthook to a CrashHandler instance, so if
                any app directly invokes sys.excepthook, it will look to the user like
                IPython crashed.  In order to work around this, we can disable the
                CrashHandler and replace it with this excepthook instead, which prints a
                regular traceback using our InteractiveTB.  In this fashion, apps which
                call sys.excepthook will generate a regular-looking exception from
                IPython, and the CrashHandler will only be triggered by real IPython
                crashes.

                This hook should be used sparingly, only in places which are not likely
                to be true IPython errors.
        
        """
    def _get_exc_info(self, exc_tuple=None):
        """
        get exc_info from a given tuple, sys.exc_info() or sys.last_type etc.
        
                Ensures sys.last_type,value,traceback hold the exc_info we found,
                from whichever source.
        
                raises ValueError if none of these contain any information
        
        """
    def show_usage_error(self, exc):
        """
        Show a short message for UsageErrors
        
                These are special exceptions that shouldn't show a traceback.
        
        """
    def get_exception_only(self, exc_tuple=None):
        """

                Return as a string (ending with a newline) the exception that
                just occurred, without any traceback.
        
        """
2021-03-02 20:49:18,916 : INFO : tokenize_signature : --> do i ever get here?
    def showtraceback(self, exc_tuple=None, filename=None, tb_offset=None,
                      exception_only=False, running_compiled_code=False):
        """
        Display the exception that just occurred.

                If nothing is known about the exception, this is the method which
                should be used throughout the code for presenting user tracebacks,
                rather than directly invoking the InteractiveTB object.

                A specific showsyntaxerror() also exists, but this method can take
                care of calling it if needed, so unless you are explicitly catching a
                SyntaxError exception, don't try to analyze the stack manually and
                simply call this method.
        """
    def _showtraceback(self, etype, evalue, stb):
        """
        Actually show a traceback.

                Subclasses may override this method to put the traceback on a different
                place, like a side channel.
        
        """
    def showsyntaxerror(self, filename=None, running_compiled_code=False):
        """
        Display the syntax error that just occurred.

                This doesn't display a stack trace because there isn't one.

                If a filename is given, it is stuffed in the exception instead
                of what was there before (because Python's parser always uses
                "<string>" when reading from a string).

                If the syntax error occurred when running a compiled code (i.e. running_compile_code=True),
                longer stack trace will be displayed.
         
        """
    def showindentationerror(self):
        """
        Called by _run_cell when there's an IndentationError in code entered
                at the prompt.

                This is overridden in TerminalInteractiveShell to show a message about
                the %paste magic.
        """
    def init_readline(self):
        """
        DEPRECATED
        
                Moved to terminal subclass, here only to simplify the init logic.
        """
    def set_next_input(self, s, replace=False):
        """
         Sets the 'default' input string for the next command line.

                Example::

                    In [1]: _ip.set_next_input("Hello Word")
                    In [2]: Hello Word_  # cursor is here
        
        """
    def _indent_current_str(self):
        """
        return the current level of indentation as a string
        """
    def init_completer(self):
        """
        Initialize the completion machinery.

                This creates completion machinery that can be used by client code,
                either interactively in-process (typically triggered by the readline
                library), programmatically (such as in test suites) or out-of-process
                (typically over the network by remote frontends).
        
        """
    def complete(self, text, line=None, cursor_pos=None):
        """
        Return the completed text and a list of completions.

                Parameters
                ----------

                   text : string
                     A string of text to be completed on.  It can be given as empty and
                     instead a line/position pair are given.  In this case, the
                     completer itself will split the line like readline does.

                   line : string, optional
                     The complete line that text is part of.

                   cursor_pos : int, optional
                     The position of the cursor on the input line.

                Returns
                -------
                  text : string
                    The actual text that was completed.

                  matches : list
                    A sorted list with all possible completions.

                The optional arguments allow the completion to take more context into
                account, and are part of the low-level completion API.

                This is a wrapper around the completion mechanism, similar to what
                readline does at the command line when the TAB key is hit.  By
                exposing it as a method, it can be used by other non-readline
                environments (such as GUIs) for text completion.

                Simple usage example:

                In [1]: x = 'hello'

                In [2]: _ip.complete('x.l')
                Out[2]: ('x.l', ['x.ljust', 'x.lower', 'x.lstrip'])
        
        """
    def set_custom_completer(self, completer, pos=0) -> None:
        """
        Adds a new custom completer function.

                The position argument (defaults to 0) is the index in the completers
                list where you want the completer to be inserted.

                `completer` should have the following signature::

                    def completion(self: Completer, text: string) -> List[str]:
                        raise NotImplementedError

                It will be bound to the current Completer instance and pass some text
                and return a list with current completions to suggest to the user.
        
        """
    def set_completer_frame(self, frame=None):
        """
        Set the frame of the completer.
        """
    def init_magics(self):
        """
         Expose as public API from the magics manager

        """
    def register_magic_function(self, func, magic_kind='line', magic_name=None):
        """
        Execute the given line magic.

                Parameters
                ----------
                magic_name : str
                  Name of the desired magic function, without '%' prefix.

                line : str
                  The rest of the input line as a single string.
          
                _stack_depth : int
                  If run_line_magic() is called from magic() then _stack_depth=2.
                  This is added to ensure backward compatibility for use of 'get_ipython().magic()'
        
        """
    def get_local_scope(self, stack_depth):
        """
        Get local scope at given stack depth.

                Parameters
                ----------
                stack_depth : int
                  Depth relative to calling frame
        
        """
    def run_cell_magic(self, magic_name, line, cell):
        """
        Execute the given cell magic.

                Parameters
                ----------
                magic_name : str
                  Name of the desired magic function, without '%' prefix.

                line : str
                  The rest of the first input line as a single string.

                cell : str
                  The body of the cell as a (possibly multiline) string.
        
        """
    def find_line_magic(self, magic_name):
        """
        Find and return a line magic by name.

                Returns None if the magic isn't found.
        """
    def find_cell_magic(self, magic_name):
        """
        Find and return a cell magic by name.

                Returns None if the magic isn't found.
        """
    def find_magic(self, magic_name, magic_kind='line'):
        """
        Find and return a magic of the given type by name.

                Returns None if the magic isn't found.
        """
    def magic(self, arg_s):
        """
        DEPRECATED. Use run_line_magic() instead.

                Call a magic function by name.

                Input: a string containing the name of the magic function to call and
                any additional arguments to be passed to the magic.

                magic('name -opt foo bar') is equivalent to typing at the ipython
                prompt:

                In[1]: %name -opt foo bar

                To call a magic without arguments, simply use magic('name').

                This provides a proper Python function to call IPython's magics in any
                valid Python code you can type at the interpreter, including loops and
                compound statements.
        
        """
    def define_macro(self, name, themacro):
        """
        Define a new macro

                Parameters
                ----------
                name : str
                    The name of the macro.
                themacro : str or Macro
                    The action to do upon invoking the macro.  If a string, a new
                    Macro object is created by passing the string to it.
        
        """
    def system_piped(self, cmd):
        """
        Call the given cmd in a subprocess, piping stdout/err

                Parameters
                ----------
                cmd : str
                  Command to execute (can not end in '&', as background processes are
                  not supported.  Should not be a command that expects input
                  other than simple text.
        
        """
    def system_raw(self, cmd):
        """
        Call the given cmd in a subprocess using os.system on Windows or
                subprocess.call using the system shell on other platforms.

                Parameters
                ----------
                cmd : str
                  Command to execute.
        
        """
    def getoutput(self, cmd, split=True, depth=0):
        """
        Get output (possibly including stderr) from a subprocess.

                Parameters
                ----------
                cmd : str
                  Command to execute (can not end in '&', as background processes are
                  not supported.
                split : bool, optional
                  If True, split the output into an IPython SList.  Otherwise, an
                  IPython LSString is returned.  These are objects similar to normal
                  lists and strings, with a few convenience attributes for easier
                  manipulation of line-based output.  You can use '?' on them for
                  details.
                depth : int, optional
                  How many frames above the caller are the local variables which should
                  be expanded in the command string? The default (0) assumes that the
                  expansion variables are in the stack frame calling this function.
        
        """
    def init_alias(self):
        """
        -------------------------------------------------------------------------
         Things related to extensions
        -------------------------------------------------------------------------


        """
    def init_extension_manager(self):
        """
        -------------------------------------------------------------------------
         Things related to payloads
        -------------------------------------------------------------------------


        """
    def init_payload(self):
        """
        -------------------------------------------------------------------------
         Things related to the prefilter
        -------------------------------------------------------------------------


        """
    def init_prefilter(self):
        """
         Ultimately this will be refactored in the new interpreter code, but
         for now, we should expose the main prefilter method (there's legacy
         code out there that may rely on this).

        """
    def auto_rewrite_input(self, cmd):
        """
        Print to the screen the rewritten form of the user's command.

                This shows visual feedback by rewriting input lines that cause
                automatic calling to kick in, like::

                  /f x

                into::

                  ------> f(x)

                after the user's input prompt.  This helps the user understand that the
                input line was transformed automatically by IPython.
        
        """
    def _user_obj_error(self):
        """
        return simple exception dict
        
                for use in user_expressions
        
        """
    def _format_user_obj(self, obj):
        """
        format a user object to display dict
        
                for use in user_expressions
        
        """
    def user_expressions(self, expressions):
        """
        Evaluate a dict of expressions in the user's namespace.

                Parameters
                ----------
                expressions : dict
                  A dict with string keys and string values.  The expression values
                  should be valid Python expressions, each of which will be evaluated
                  in the user namespace.

                Returns
                -------
                A dict, keyed like the input expressions dict, with the rich mime-typed
                display_data of each value.
        
        """
    def ex(self, cmd):
        """
        Execute a normal python statement in user namespace.
        """
    def ev(self, expr):
        """
        Evaluate python expression expr in user namespace.

                Returns the result of evaluation
        
        """
    def safe_execfile(self, fname, *where, exit_ignore=False, raise_exceptions=False, shell_futures=False):
        """
        A safe version of the builtin execfile().

                This version will never throw an exception, but instead print
                helpful error messages to the screen.  This only works on pure
                Python files with the .py extension.

                Parameters
                ----------
                fname : string
                    The name of the file to be executed.
                where : tuple
                    One or two namespaces, passed to execfile() as (globals,locals).
                    If only one is given, it is passed as both.
                exit_ignore : bool (False)
                    If True, then silence SystemExit for non-zero status (it is always
                    silenced for zero status, as it is so common).
                raise_exceptions : bool (False)
                    If True raise exceptions everywhere. Meant for testing.
                shell_futures : bool (False)
                    If True, the code will share future statements with the interactive
                    shell. It will both be affected by previous __future__ imports, and
                    any __future__ imports in the code will affect the shell. If False,
                    __future__ imports are not shared in either direction.

        
        """
    def safe_execfile_ipy(self, fname, shell_futures=False, raise_exceptions=False):
        """
        Like safe_execfile, but for .ipy or .ipynb files with IPython syntax.

                Parameters
                ----------
                fname : str
                    The name of the file to execute.  The filename must have a
                    .ipy or .ipynb extension.
                shell_futures : bool (False)
                    If True, the code will share future statements with the interactive
                    shell. It will both be affected by previous __future__ imports, and
                    any __future__ imports in the code will affect the shell. If False,
                    __future__ imports are not shared in either direction.
                raise_exceptions : bool (False)
                    If True raise exceptions everywhere.  Meant for testing.
        
        """
        def get_cells():
            """
            generator for sequence of code blocks to run
            """
    def safe_run_module(self, mod_name, where):
        """
        A safe version of runpy.run_module().

                This version will never throw an exception, but instead print
                helpful error messages to the screen.

                `SystemExit` exceptions with status code 0 or None are ignored.

                Parameters
                ----------
                mod_name : string
                    The name of the module to be executed.
                where : dict
                    The globals namespace.
        
        """
    def run_cell(self, raw_cell, store_history=False, silent=False, shell_futures=True):
        """
        Run a complete IPython cell.

                Parameters
                ----------
                raw_cell : str
                  The code (including IPython code such as %magic functions) to run.
                store_history : bool
                  If True, the raw and translated cell will be stored in IPython's
                  history. For user code calling back into IPython's machinery, this
                  should be set to False.
                silent : bool
                  If True, avoid side-effects, such as implicit displayhooks and
                  and logging.  silent=True forces store_history=False.
                shell_futures : bool
                  If True, the code will share future statements with the interactive
                  shell. It will both be affected by previous __future__ imports, and
                  any __future__ imports in the code will affect the shell. If False,
                  __future__ imports are not shared in either direction.

                Returns
                -------
                result : :class:`ExecutionResult`
        
        """
    def _run_cell(self, raw_cell:str, store_history:bool, silent:bool, shell_futures:bool):
        """
        Internal method to run a complete IPython cell.
        """
2021-03-02 20:49:18,932 : INFO : tokenize_signature : --> do i ever get here?
2021-03-02 20:49:18,932 : INFO : tokenize_signature : --> do i ever get here?
    def should_run_async(
        self, raw_cell: str, *, transformed_cell=None, preprocessing_exc_tuple=None
    ) -> bool:
        """
        Return whether a cell should be run asynchronously via a coroutine runner

                Parameters
                ----------
                raw_cell: str
                    The code to be executed

                Returns
                -------
                result: bool
                    Whether the code needs to be run with a coroutine runner or not

                .. versionadded: 7.0
        
        """
2021-03-02 20:49:18,932 : INFO : tokenize_signature : --> do i ever get here?
2021-03-02 20:49:18,932 : INFO : tokenize_signature : --> do i ever get here?
2021-03-02 20:49:18,932 : INFO : tokenize_signature : --> do i ever get here?
2021-03-02 20:49:18,933 : INFO : tokenize_signature : --> do i ever get here?
2021-03-02 20:49:18,933 : INFO : tokenize_signature : --> do i ever get here?
2021-03-02 20:49:18,933 : INFO : tokenize_signature : --> do i ever get here?
2021-03-02 20:49:18,933 : INFO : tokenize_signature : --> do i ever get here?
2021-03-02 20:49:18,933 : INFO : tokenize_signature : --> do i ever get here?
2021-03-02 20:49:18,933 : INFO : tokenize_signature : --> do i ever get here?
    async def run_cell_async(
        self,
        raw_cell: str,
        store_history=False,
        silent=False,
        shell_futures=True,
        *,
        transformed_cell: Optional[str] = None,
        preprocessing_exc_tuple: Optional[Any] = None
    ) -> ExecutionResult:
            """
            Run a complete IPython cell asynchronously.

                    Parameters
                    ----------
                    raw_cell : str
                      The code (including IPython code such as %magic functions) to run.
                    store_history : bool
                      If True, the raw and translated cell will be stored in IPython's
                      history. For user code calling back into IPython's machinery, this
                      should be set to False.
                    silent : bool
                      If True, avoid side-effects, such as implicit displayhooks and
                      and logging.  silent=True forces store_history=False.
                    shell_futures : bool
                      If True, the code will share future statements with the interactive
                      shell. It will both be affected by previous __future__ imports, and
                      any __future__ imports in the code will affect the shell. If False,
                      __future__ imports are not shared in either direction.
                    transformed_cell: str
                      cell that was passed through transformers
                    preprocessing_exc_tuple:
                      trace if the transformation failed.

                    Returns
                    -------
                    result : :class:`ExecutionResult`

                    .. versionadded: 7.0
        
            """
        def error_before_exec(value):
            """
            'pre_execute'
            """
    def transform_cell(self, raw_cell):
        """
        Transform an input cell before parsing it.

                Static transformations, implemented in IPython.core.inputtransformer2,
                deal with things like ``%magic`` and ``!system`` commands.
                These run on all input.
                Dynamic transformations, for things like unescaped magics and the exit
                autocall, depend on the state of the interpreter.
                These only apply to single line inputs.

                These string-based transformations are followed by AST transformations;
                see :meth:`transform_ast`.
        
        """
    def transform_ast(self, node):
        """
        Apply the AST transformations from self.ast_transformers
        
                Parameters
                ----------
                node : ast.Node
                  The root node to be transformed. Typically called with the ast.Module
                  produced by parsing user input.
        
                Returns
                -------
                An ast.Node corresponding to the node it was called with. Note that it
                may also modify the passed object, so don't rely on references to the
                original AST.
        
        """
2021-03-02 20:49:18,937 : INFO : tokenize_signature : --> do i ever get here?
    async def run_ast_nodes(self, nodelist:ListType[AST], cell_name:str, interactivity='last_expr',
                        compiler=compile, result=None):
            """
            Run a sequence of AST nodes. The execution mode depends on the
                    interactivity parameter.

                    Parameters
                    ----------
                    nodelist : list
                      A sequence of AST nodes to run.
                    cell_name : str
                      Will be passed to the compiler as the filename of the cell. Typically
                      the value returned by ip.compile.cache(cell).
                    interactivity : str
                      'all', 'last', 'last_expr' , 'last_expr_or_assign' or 'none',
                      specifying which nodes should be run interactively (displaying output
                      from expressions). 'last_expr' will run the last node interactively
                      only if it is an expression (i.e. expressions in loops or other blocks
                      are not displayed) 'last_expr_or_assign' will run the last expression
                      or the last assignment. Other values for this parameter will raise a
                      ValueError.

                      Experimental value: 'async' Will try to run top level interactive
                      async/await code in default runner, this will not respect the
                      interactivity setting and will only run the last node if it is an
                      expression. 

                    compiler : callable
                      A function with the same interface as the built-in compile(), to turn
                      the AST nodes into code objects. Default is the built-in compile().
                    result : ExecutionResult, optional
                      An object to store exceptions that occur during execution.

                    Returns
                    -------
                    True if an exception occurred while running code, False if it finished
                    running.
        
            """
                    def compare(code):
                        """
                         refactor that to just change the mod constructor.

                        """
    def _async_exec(self, code_obj: types.CodeType, user_ns: dict):
        """

                Evaluate an asynchronous code object using a code runner

                Fake asynchronous execution of code_object in a namespace via a proxy namespace.

                Returns coroutine object, which can be executed via async loop runner

                WARNING: The semantics of `async_exec` are quite different from `exec`,
                in particular you can only pass a single namespace. It also return a
                handle to the value of the last things returned by code_object.
        
        """
    async def run_code(self, code_obj, result=None, *, async_=False):
            """
            Execute a code object.

                    When an exception occurs, self.showtraceback() is called to display a
                    traceback.

                    Parameters
                    ----------
                    code_obj : code object
                      A compiled code object, to be executed
                    result : ExecutionResult, optional
                      An object to store exceptions that occur during execution.
                    async_ :  Bool (Experimental)
                      Attempt to run top-level asynchronous code in a default loop.

                    Returns
                    -------
                    False : successful execution.
                    True : an error occurred.
        
            """
    def check_complete(self, code: str) -> Tuple[str, str]:
        """
        Return whether a block of code is ready to execute, or should be continued

                Parameters
                ----------
                source : string
                  Python input code, which can be multiline.

                Returns
                -------
                status : str
                  One of 'complete', 'incomplete', or 'invalid' if source is not a
                  prefix of valid code.
                indent : str
                  When status is 'incomplete', this is some whitespace to insert on
                  the next line of the prompt.
        
        """
    def enable_gui(self, gui=None):
        """
        'Implement enable_gui in a subclass'
        """
    def enable_matplotlib(self, gui=None):
        """
        Enable interactive matplotlib and inline figure support.
        
                This takes the following steps:
        
                1. select the appropriate eventloop and matplotlib backend
                2. set up matplotlib for interactive use with that backend
                3. configure formatters for inline figure display
                4. enable the selected gui eventloop
        
                Parameters
                ----------
                gui : optional, string
                  If given, dictates the choice of matplotlib GUI backend to use
                  (should be one of IPython's supported backends, 'qt', 'osx', 'tk',
                  'gtk', 'wx' or 'inline'), otherwise we use the default chosen by
                  matplotlib (as dictated by the matplotlib build-time options plus the
                  user's matplotlibrc configuration file).  Note that not all backends
                  make sense in all contexts, for example a terminal ipython can't
                  display figures inline.
        
        """
    def enable_pylab(self, gui=None, import_all=True, welcome_message=False):
        """
        Activate pylab support at runtime.

                This turns on support for matplotlib, preloads into the interactive
                namespace all of numpy and pylab, and configures IPython to correctly
                interact with the GUI event loop.  The GUI backend to be used can be
                optionally selected with the optional ``gui`` argument.
        
                This method only adds preloading the namespace to InteractiveShell.enable_matplotlib.

                Parameters
                ----------
                gui : optional, string
                  If given, dictates the choice of matplotlib GUI backend to use
                  (should be one of IPython's supported backends, 'qt', 'osx', 'tk',
                  'gtk', 'wx' or 'inline'), otherwise we use the default chosen by
                  matplotlib (as dictated by the matplotlib build-time options plus the
                  user's matplotlibrc configuration file).  Note that not all backends
                  make sense in all contexts, for example a terminal ipython can't
                  display figures inline.
                import_all : optional, bool, default: True
                  Whether to do `from numpy import *` and `from pylab import *`
                  in addition to module imports.
                welcome_message : deprecated
                  This argument is ignored, no welcome message will be displayed.
        
        """
    def var_expand(self, cmd, depth=0, formatter=DollarFormatter()):
        """
        Expand python variables in a string.

                The depth argument indicates how many frames above the caller should
                be walked to look for the local namespace where to expand variables.

                The global namespace for expansion is always the user's interactive
                namespace.
        
        """
    def mktempfile(self, data=None, prefix='ipython_edit_'):
        """
        Make a new tempfile and return its filename.

                This makes a call to tempfile.mkstemp (created in a tempfile.mkdtemp),
                but it registers the created filename internally so ipython cleans it up
                at exit time.

                Optional inputs:

                  - data(None): if data is given, it gets written out to the temp file
                    immediately, and the file is closed again.
        """
    def write(self,data):
        """
        DEPRECATED: Write a string to the default output
        """
    def write_err(self,data):
        """
        DEPRECATED: Write a string to the default error output
        """
    def ask_yes_no(self, prompt, default=None, interrupt=None):
        """
        Show a usage message
        """
    def extract_input_lines(self, range_str, raw=False):
        """
        Return as a string a set of input history slices.

                Parameters
                ----------
                range_str : string
                    The set of slices is given as a string, like "~5/6-~4/2 4:8 9",
                    since this function is for use by magic functions which get their
                    arguments as strings. The number before the / is the session
                    number: ~n goes n back from the current session.

                raw : bool, optional
                    By default, the processed input is used.  If this is true, the raw
                    input history is used instead.

                Notes
                -----

                Slices can be described with two notations:

                * ``N:M`` -> standard python form, means including items N...(M-1).
                * ``N-M`` -> include items N..M (closed endpoint).
        
        """
    def find_user_code(self, target, raw=True, py_only=False, skip_encoding_cookie=True, search_ns=False):
        """
        Get a code string from history, file, url, or a string or macro.

                This is mainly used by magic functions.

                Parameters
                ----------

                target : str

                  A string specifying code to retrieve. This will be tried respectively
                  as: ranges of input history (see %history for syntax), url,
                  corresponding .py file, filename, or an expression evaluating to a
                  string or Macro in the user namespace.

                raw : bool
                  If true (default), retrieve raw history. Has no effect on the other
                  retrieval mechanisms.

                py_only : bool (default False)
                  Only try to fetch python code, do not try alternative methods to decode file
                  if unicode fails.

                Returns
                -------
                A string of code.

                ValueError is raised if nothing is found, and TypeError if it evaluates
                to an object of another type. In each case, .args[0] is a printable
                message.
        
        """
    def atexit_operations(self):
        """
        This will be executed at the time of exit.

                Cleanup operations and saving of persistent data that is done
                unconditionally by IPython should be performed here.

                For things that may depend on startup flags or platform specifics (such
                as having readline or not), register a separate atexit function in the
                code that has the appropriate information, rather than trying to
                clutter
        
        """
    def cleanup(self):
        """
         Overridden in terminal subclass to change prompts

        """
    def switch_doctest_mode(self, mode):
        """
        An abstract base class for InteractiveShell.
        """
