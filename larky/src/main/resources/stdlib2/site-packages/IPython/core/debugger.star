def make_arrow(pad):
    """
    generate the leading arrow in front of traceback or debugger
    """
def BdbQuit_excepthook(et, ev, tb, excepthook=None):
    """
    Exception hook which handles `BdbQuit` exceptions.

        All other exceptions are processed using the `excepthook`
        parameter.
    
    """
def BdbQuit_IPython_excepthook(self,et,ev,tb,tb_offset=None):
    """
    `BdbQuit_IPython_excepthook` is deprecated since version 5.1
    """
def Tracer(object):
    """

        DEPRECATED

        Class for local debugging, similar to pdb.set_trace.

        Instances of this class, when called, behave like pdb.set_trace, but
        providing IPython's enhanced capabilities.

        This is implemented as a class which must be initialized in your own code
        and not as a standalone function because we need to detect at runtime
        whether IPython is already active or not.  That detection is done in the
        constructor, ensuring that this code plays nicely with a running IPython,
        while functioning acceptably (though with limitations) if outside of it.
    
    """
    def __init__(self, colors=None):
        """

                DEPRECATED

                Create a local debugger instance.

                Parameters
                ----------

                colors : str, optional
                    The name of the color scheme to use, it must be one of IPython's
                    valid color schemes.  If not given, the function will default to
                    the current IPython scheme when running inside IPython, and to
                    'NoColor' otherwise.

                Examples
                --------
                ::

                    from IPython.core.debugger import Tracer; debug_here = Tracer()

                Later in your code::

                    debug_here()  # -> will open up the debugger at that point.

                Once the debugger activates, you can use all of its regular commands to
                step through code, set breakpoints, etc.  See the pdb documentation
                from the Python standard library for usage details.
        
        """
    def __call__(self):
        """
        Starts an interactive debugger at the point where called.

                This is similar to the pdb.set_trace() function from the std lib, but
                using IPython's enhanced debugger.
        """
def strip_indentation(multiline_string):
    """
    ''
    """
def decorate_fn_with_doc(new_fn, old_fn, additional_text=""):
    """
    Make new_fn have old_fn's doc string. This is particularly useful
        for the ``do_...`` commands that hook into the help system.
        Adapted from from a comp.lang.python posting
        by Duncan Booth.
    """
    def wrapper(*args, **kw):
        """
        Modified Pdb class, does not load readline.

            for a standalone version that uses prompt_toolkit, see
            `IPython.terminal.debugger.TerminalPdb` and
            `IPython.terminal.debugger.set_trace()`
    
        """
2021-03-02 20:49:17,634 : INFO : tokenize_signature : --> do i ever get here?
    def __init__(self, color_scheme=None, completekey=None,
                 stdin=None, stdout=None, context=5, **kwargs):
        """
        Create a new IPython debugger.
        
                :param color_scheme: Deprecated, do not use.
                :param completekey: Passed to pdb.Pdb.
                :param stdin: Passed to pdb.Pdb.
                :param stdout: Passed to pdb.Pdb.
                :param context: Number of lines of source code context to show when
                    displaying stacktrace information.
                :param kwargs: Passed to pdb.Pdb.
                    The possibilities are python version dependent, see the python
                    docs for more info.
        
        """
    def set_colors(self, scheme):
        """
        Shorthand access to the color table scheme selector method.
        """
    def hidden_frames(self, stack):
        """

                Given an index in the stack return wether it should be skipped.

                This is used in up/down and where to skip frames.
        
        """
    def interaction(self, frame, traceback):
        """
        \n
        """
    def new_do_frame(self, arg):
        """
        'old_all_completions'
        """
    def new_do_restart(self, arg):
        """
        Restart command. In the context of ipython this is exactly the same
                thing as 'quit'.
        """
    def print_stack_trace(self, context=None):
        """
        Context must be a positive integer
        """
2021-03-02 20:49:17,639 : INFO : tokenize_signature : --> do i ever get here?
    def print_stack_entry(self, frame_lineno, prompt_prefix='\n-> ',
                          context=None):
        """
        Context must be a positive integer
        """
    def format_stack_entry(self, frame_lineno, lprefix=': ', context=None):
        """
        Context must be a positive integer
        """
    def __format_line(self, tpl_line, filename, lineno, line, arrow = False):
        """

        """
    def print_list_lines(self, filename, first, last):
        """
        The printing (as opposed to the parsing part of a 'list'
                command.
        """
    def do_skip_hidden(self, arg):
        """

                Change whether or not we should skip frames with the
                __tracebackhide__ attribute.
        
        """
    def do_list(self, arg):
        """
        Print lines of code from the current stack frame
        
        """
    def getsourcelines(self, obj):
        """
         must be a module frame: do not try to cut a block out of it

        """
    def do_longlist(self, arg):
        """
        Print lines of code from the current stack frame.

                Shows more lines than 'list' does.
        
        """
    def do_debug(self, arg):
        """
        debug code
                Enter a recursive debugger that steps through the code
                argument (which is an arbitrary expression or statement to be
                executed in the current environment).
        
        """
    def do_pdef(self, arg):
        """
        Print the call signature for any callable object.

                The debugger interface to %pdef
        """
    def do_pdoc(self, arg):
        """
        Print the docstring for an object.

                The debugger interface to %pdoc.
        """
    def do_pfile(self, arg):
        """
        Print (or run through pager) the file where an object is defined.

                The debugger interface to %pfile.
        
        """
    def do_pinfo(self, arg):
        """
        Provide detailed information about an object.

                The debugger interface to %pinfo, i.e., obj?.
        """
    def do_pinfo2(self, arg):
        """
        Provide extra detailed information about an object.

                The debugger interface to %pinfo2, i.e., obj??.
        """
    def do_psource(self, arg):
        """
        Print (or run through pager) the source code for an object.
        """
    def do_where(self, arg):
        """
        w(here)
                Print a stack trace, with the most recent frame at the bottom.
                An arrow indicates the "current frame", which determines the
                context of most commands. 'bt' is an alias for this command.

                Take a number as argument as an (optional) number of context line to
                print
        """
    def stop_here(self, frame):
        """
        Check if pdb should stop here
        """
    def do_up(self, arg):
        """
        u(p) [count]
                Move the current frame count (default one) levels up in the
                stack trace (to an older frame).

                Will skip hidden frames.
        
        """
    def do_down(self, arg):
        """
        d(own) [count]
                Move the current frame count (default one) levels down in the
                stack trace (to a newer frame).

                Will skip hidden frames.
        
        """
def InterruptiblePdb(Pdb):
    """
    Version of debugger where KeyboardInterrupt exits the debugger altogether.
    """
    def cmdloop(self):
        """
        Wrap cmdloop() such that KeyboardInterrupt stops the debugger.
        """
    def _cmdloop(self):
        """
         keyboard interrupts allow for an easy way to cancel
         the current command, so allow them during interactive input

        """
def set_trace(frame=None):
    """

        Start debugging from `frame`.

        If frame is not specified, debugging starts from caller's frame.
    
    """
