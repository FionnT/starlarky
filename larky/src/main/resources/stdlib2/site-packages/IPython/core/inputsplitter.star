def num_ini_spaces(s):
    """
    Return the number of initial spaces in a string.

        Note that tabs are counted as a single space.  For now, we do *not* support
        mixing of tabs and spaces in the user's input.

        Parameters
        ----------
        s : string

        Returns
        -------
        n : int
    
    """
def IncompleteString:
    """
    ''
    """
def partial_tokens(s):
    """
    Iterate over tokens from a possibly-incomplete string of code.

        This adds two special token types: INCOMPLETE_STRING and
        IN_MULTILINE_STATEMENT. These can only occur as the last token yielded, and
        represent the two main ways for code to be incomplete.
    
    """
def find_next_indent(code):
    """
    Find the number of spaces for the next line of indentation
    """
    def _add_indent(n):
        """
         If we've just opened a multiline statement (e.g. 'a = ['), indent more

        """
def last_blank(src):
    """
    Determine if the input source ends in a blank.

        A blank is either a newline or a line consisting of whitespace.

        Parameters
        ----------
        src : string
          A single or multiline string.
    
    """
def last_two_blanks(src):
    """
    Determine if the input source ends in two blanks.

        A blank is either a newline or a line consisting of whitespace.

        Parameters
        ----------
        src : string
          A single or multiline string.
    
    """
def remove_comments(src):
    """
    Remove all comments from input source.

        Note: comments are NOT recognized inside of strings!

        Parameters
        ----------
        src : string
          A single or multiline input string.

        Returns
        -------
        String with all Python comments removed.
    
    """
def get_input_encoding():
    """
    Return the default standard input encoding.

        If sys.stdin has no encoding, 'ascii' is returned.
    """
def InputSplitter(object):
    """
    r"""An object that can accumulate lines of Python source before execution.

        This object is designed to be fed python source line-by-line, using
        :meth:`push`. It will return on each push whether the currently pushed
        code could be executed already. In addition, it provides a method called
        :meth:`push_accepts_more` that can be used to query whether more input
        can be pushed into a single interactive block.

        This is a simple example of how an interactive terminal-based client can use
        this tool::

            isp = InputSplitter()
            while isp.push_accepts_more():
                indent = ' '*isp.indent_spaces
                prompt = '>>> ' + indent
                line = indent + raw_input(prompt)
                isp.push(line)
            print 'Input source was:\n', isp.source_reset(),
    
    """
    def __init__(self):
        """
        Create a new InputSplitter instance.
        
        """
    def reset(self):
        """
        Reset the input buffer and associated state.
        """
    def source_reset(self):
        """
        Return the input source and perform a full reset.
        
        """
    def check_complete(self, source):
        """
        Return whether a block of code is ready to execute, or should be continued
        
                This is a non-stateful API, and will reset the state of this InputSplitter.
        
                Parameters
                ----------
                source : string
                  Python input code, which can be multiline.
        
                Returns
                -------
                status : str
                  One of 'complete', 'incomplete', or 'invalid' if source is not a
                  prefix of valid code.
                indent_spaces : int or None
                  The number of spaces by which to indent the next line of code. If
                  status is not 'incomplete', this is None.
        
        """
    def push(self, lines:str) -> bool:
        """
        Push one or more lines of input.

                This stores the given lines and returns a status code indicating
                whether the code forms a complete Python block or not.

                Any exceptions generated in compilation are swallowed, but if an
                exception was produced, the method returns True.

                Parameters
                ----------
                lines : string
                  One or more lines of Python input.

                Returns
                -------
                is_complete : boolean
                  True if the current input source (the result of the current input
                  plus prior inputs) forms a complete Python execution block.  Note that
                  this value is also stored as a private attribute (``_is_complete``), so it
                  can be queried at any time.
        
        """
    def push_accepts_more(self):
        """
        Return whether a block of interactive input can accept more input.

                This method is meant to be used by line-oriented frontends, who need to
                guess whether a block is complete or not based solely on prior and
                current input lines.  The InputSplitter considers it has a complete
                interactive block and will not accept more input when either:
        
                * A SyntaxError is raised

                * The code is complete and consists of a single line or a single
                  non-compound statement

                * The code is complete and has a blank line at the end

                If the current input produces a syntax error, this method immediately
                returns False but does *not* raise the syntax error exception, as
                typically clients will want to send invalid syntax to an execution
                backend which might convert the invalid syntax into valid Python via
                one of the dynamic IPython mechanisms.
        
        """
    def get_indent_spaces(self):
        """
         self.source always has a trailing newline

        """
    def _store(self, lines, buffer=None, store='source'):
        """
        Store one or more lines of input.

                If input lines are not newline-terminated, a newline is automatically
                appended.
        """
    def _set_source(self, buffer):
        """
        u''
        """
def IPythonInputSplitter(InputSplitter):
    """
    An input splitter that recognizes all of IPython's special syntax.
    """
2021-03-02 20:49:19,497 : INFO : tokenize_signature : --> do i ever get here?
    def __init__(self, line_input_checker=True, physical_line_transforms=None,
                    logical_line_transforms=None, python_line_transforms=None):
        """
         We don't use any of these at present

        """
    def transforms(self):
        """
        Quick access to all transformers.
        """
    def transforms_in_use(self):
        """
        Transformers, excluding logical line transformers if we're in a
                Python line.
        """
    def reset(self):
        """
        Reset the input buffer and associated state.
        """
    def flush_transformers(self):
        """
        yield transformed lines
            
                    always strings, never None
            
                    transform: the current transform
                    outs: an iterable of previously transformed inputs.
                         Each may be multiline, which will be passed
                         one line at a time to transform.
            
        """
    def raw_reset(self):
        """
        Return raw input only and perform a full reset.
        
        """
    def source_reset(self):
        """
        Process and translate a cell of input.
        
        """
    def push(self, lines:str) -> bool:
        """
        Push one or more lines of IPython input.

                This stores the given lines and returns a status code indicating
                whether the code forms a complete Python block or not, after processing
                all input lines for special IPython syntax.

                Any exceptions generated in compilation are swallowed, but if an
                exception was produced, the method returns True.

                Parameters
                ----------
                lines : string
                  One or more lines of Python input.

                Returns
                -------
                is_complete : boolean
                  True if the current input source (the result of the current input
                  plus prior inputs) forms a complete Python execution block.  Note that
                  this value is also stored as a private attribute (_is_complete), so it
                  can be queried at any time.
        
        """
    def _transform_line(self, line):
        """
        Push a line of input code through the various transformers.
        
                Returns any output from the transformers, or None if a transformer
                is accumulating lines.
        
                Sets self.transformer_accumulating as a side effect.
        
        """
        def _accumulating(dbg):
            """
            print(dbg)

            """
