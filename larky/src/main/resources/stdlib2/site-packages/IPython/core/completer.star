def ProvisionalCompleterWarning(FutureWarning):
    """

        Exception raise by an experimental feature in this module.

        Wrap code in :any:`provisionalcompleter` context manager if you
        are certain you want to use an unstable feature.
    
    """
def provisionalcompleter(action='ignore'):
    """



        This context manager has to be used in any place where unstable completer
        behavior and API may be called.

        >>> with provisionalcompleter():
        ...     completer.do_experimental_things() # works

        >>> completer.do_experimental_things() # raises.

        .. note:: Unstable

            By using this context manager you agree that the API in use may change
            without warning, and that you won't complain if they do so.

            You also understand that, if the API is not to your liking, you should report
            a bug to explain your use case upstream.

            We'll be happy to get your feedback, feature requests, and improvements on
            any of the unstable APIs!
    
    """
def has_open_quotes(s):
    """
    Return whether a string has open quotes.

        This simply counts whether the number of quote characters of either type in
        the string is odd.

        Returns
        -------
        If there is an open quote, the quote character is returned.  Else, return
        False.
    
    """
def protect_filename(s, protectables=PROTECTABLES):
    """
    Escape a string to protect certain characters.
    """
def expand_user(path:str) -> Tuple[str, bool, str]:
    """
    Expand ``~``-style usernames in strings.

        This is similar to :func:`os.path.expanduser`, but it computes and returns
        extra information that will be useful if the input was being used in
        computing completions, and you wish to return the completions with the
        original '~' instead of its expanded value.

        Parameters
        ----------
        path : str
          String to be expanded.  If no ~ is present, the output is the same as the
          input.

        Returns
        -------
        newpath : str
          Result of ~ expansion in the input path.
        tilde_expand : bool
          Whether any expansion was performed or not.
        tilde_val : str
          The value that ~ was replaced with.
    
    """
def compress_user(path:str, tilde_expand:bool, tilde_val:str) -> str:
    """
    Does the opposite of expand_user, with its outputs.
    
    """
def completions_sorting_key(word):
    """
    key for sorting completions

        This does several things:

        - Demote any completions starting with underscores to the end
        - Insert any %magic and %%cellmagic completions in the alphabetical order
          by their name
    
    """
def _FakeJediCompletion:
    """

        This is a workaround to communicate to the UI that Jedi has crashed and to
        report a bug. Will be used only id :any:`IPCompleter.debug` is set to true.

        Added in IPython 6.0 so should likely be removed for 7.0

    
    """
    def __init__(self, name):
        """
        'crashed'
        """
    def __repr__(self):
        """
        '<Fake completion object jedi has crashed>'
        """
def Completion:
    """

        Completion object used and return by IPython completers.

        .. warning:: Unstable

            This function is unstable, API may change without warning.
            It will also raise unless use in proper context manager.

        This act as a middle ground :any:`Completion` object between the
        :any:`jedi.api.classes.Completion` object and the Prompt Toolkit completion
        object. While Jedi need a lot of information about evaluator and how the
        code should be ran/inspected, PromptToolkit (and other frontend) mostly
        need user facing information.

        - Which range should be replaced replaced by what.
        - Some metadata (like completion type), or meta information to displayed to
          the use user.

        For debugging purpose we can also store the origin of the completion (``jedi``,
        ``IPython.python_matches``, ``IPython.magics_matches``...).
    
    """
    def __init__(self, start: int, end: int, text: str, *, type: str=None, _origin='', signature='') -> None:
        """
        ``Completion`` is a provisional API (as of IPython 6.0). 
        It may change without warnings. 
        Use in corresponding context manager.
        """
    def __repr__(self):
        """
        '<Completion start=%s end=%s text=%r type=%r, signature=%r,>'
        """
    def __eq__(self, other)->Bool:
        """

                Equality and hash do not hash the type (as some completer may not be
                able to infer the type), but are use to (partially) de-duplicate
                completion.

                Completely de-duplicating completion is a bit tricker that just
                comparing as it depends on surrounding text, which Completions are not
                aware of.
        
        """
    def __hash__(self):
        """

            Deduplicate a set of completions.

            .. warning:: Unstable

                This function is unstable, API may change without warning.

            Parameters
            ----------
            text: str
                text that should be completed.
            completions: Iterator[Completion]
                iterator over the completions to deduplicate

            Yields
            ------
            `Completions` objects


            Completions coming from multiple sources, may be different but end up having
            the same effect when applied to ``text``. If this is the case, this will
            consider completions as equal and only emit the first encountered.

            Not folded in `completions()` yet for debugging purpose, and to detect when
            the IPython completer does return things that Jedi does not, but should be
            at some point.
    
        """
def rectify_completions(text: str, completions: _IC, *, _debug=False)->_IC:
    """

        Rectify a set of completions to all have the same ``start`` and ``end``

        .. warning:: Unstable

            This function is unstable, API may change without warning.
            It will also raise unless use in proper context manager.

        Parameters
        ----------
        text: str
            text that should be completed.
        completions: Iterator[Completion]
            iterator over the completions to rectify


        :any:`jedi.api.classes.Completion` s returned by Jedi may not have the same start and end, though
        the Jupyter Protocol requires them to behave like so. This will readjust
        the completion to have the same ``start`` and ``end`` by padding both
        extremities with surrounding text.

        During stabilisation should support a ``_debug`` option to log which
        completion are return by the IPython completer and not found in Jedi in
        order to make upstream bug report.
    
    """
def CompletionSplitter(object):
    """
    An object to split an input line in a manner similar to readline.

        By having our own implementation, we can expose readline-like completion in
        a uniform manner to all frontends.  This object only needs to be given the
        line of text to be split and the cursor position on said line, and it
        returns the 'word' to be completed on at the cursor after splitting the
        entire line.

        What characters are used as splitting delimiters can be controlled by
        setting the ``delims`` attribute (this is a property that internally
        automatically builds the necessary regular expression)
    """
    def __init__(self, delims=None):
        """
        Return the string of delimiter characters.
        """
    def delims(self, delims):
        """
        Set the delimiters for line splitting.
        """
    def split_line(self, line, cursor_pos=None):
        """
        Split a line of text with a cursor at the given position.
        
        """
def Completer(Configurable):
    """
    Activate greedy completion
            PENDING DEPRECTION. this is now mostly taken care of with Jedi.

            This will enable completion on elements of lists, results of function calls, etc.,
            but can be unsafe because the code is actually evaluated on TAB.
        

    """
    def __init__(self, namespace=None, global_namespace=None, **kwargs):
        """
        Create a new completer for the command line.

                Completer(namespace=ns, global_namespace=ns2) -> completer instance.

                If unspecified, the default namespace where completions are performed
                is __main__ (technically, __main__.__dict__). Namespaces should be
                given as dictionaries.

                An optional second namespace can be given.  This allows the completer
                to handle cases where both the local and global scopes need to be
                distinguished.
        
        """
    def complete(self, text, state):
        """
        Return the next possible completion for 'text'.

                This is called successively with state == 0, 1, 2, ... until it
                returns None.  The completion should begin with 'text'.

        
        """
    def global_matches(self, text):
        """
        Compute matches when text is a simple name.

                Return a list of all keywords, built-in functions and names currently
                defined in self.namespace or self.global_namespace that match.

        
        """
    def attr_matches(self, text):
        """
        Compute matches when text contains a dot.

                Assuming the text is of the form NAME.NAME....[NAME], and is
                evaluatable in self.namespace or self.global_namespace, it will be
                evaluated and its attributes (as revealed by dir()) are used as
                possible completions.  (For class instances, class members are
                also considered.)

                WARNING: this can still invoke arbitrary C code, if an object
                with a __getattr__ hook is evaluated.

        
        """
def get__all__entries(obj):
    """
    returns the strings in the __all__ attribute
    """
def match_dict_keys(keys: List[str], prefix: str, delims: str):
    """
    Used by dict_key_matches, matching the prefix to a list of keys

        Parameters
        ==========
        keys:
            list of keys in dictionary currently being completed.
        prefix:
            Part of the text already typed by the user. e.g. `mydict[b'fo`
        delims:
            String of delimiters to consider when finding the current key.

        Returns
        =======

        A tuple of three elements: ``quote``, ``token_start``, ``matched``, with
        ``quote`` being the quote that need to be used to close current string.
        ``token_start`` the position where the replacement should start occurring,
        ``matches`` a list of replacement/completion

    
    """
def cursor_to_position(text:str, line:int, column:int)->int:
    """


        Convert the (line,column) position of the cursor in text to an offset in a
        string.

        Parameters
        ----------

        text : str
            The text in which to calculate the cursor offset
        line : int
            Line of the cursor; 0-indexed
        column : int
            Column of the cursor 0-indexed

        Return
        ------
            Position of the cursor in ``text``, 0-indexed.

        See Also
        --------
        position_to_cursor: reciprocal of this function

    
    """
def position_to_cursor(text:str, offset:int)->Tuple[int, int]:
    """

        Convert the position of the cursor in text (0 indexed) to a line
        number(0-indexed) and a column number (0-indexed) pair

        Position should be a valid position in ``text``.

        Parameters
        ----------

        text : str
            The text in which to calculate the cursor offset
        offset : int
            Position of the cursor in ``text``, 0-indexed.

        Return
        ------
        (line, column) : (int, int)
            Line of the cursor; 0-indexed, column of the cursor 0-indexed


        See Also
        --------
        cursor_to_position : reciprocal of this function


    
    """
def _safe_isinstance(obj, module, class_name):
    """
    Checks if obj is an instance of module.class_name if loaded
    
    """
def back_unicode_name_matches(text):
    """
    u"""Match unicode characters back to unicode name

        This does  ``☃`` -> ``\\snowman``

        Note that snowman is not a valid python3 combining character but will be expanded.
        Though it will not recombine back to the snowman character by the completion machinery.

        This will not either back-complete standard sequences like \\n, \\b ...

        Used on Python 3 only.
    
    """
def back_latex_name_matches(text:str):
    """
    Match latex characters back to unicode name

        This does ``\\ℵ`` -> ``\\aleph``

        Used on Python 3 only.
    
    """
def _formatparamchildren(parameter) -> str:
    """

        Get parameter name and value from Jedi Private API

        Jedi does not expose a simple way to get `param=value` from its API.

        Parameter
        =========

        parameter:
            Jedi's function `Param`

        Returns
        =======

        A string like 'a', 'b=1', '*args', '**kwargs'


    
    """
def _make_signature(completion)-> str:
    """

        Make the signature from a jedi completion

        Parameter
        =========

        completion: jedi.Completion
            object does not complete a function type

        Returns
        =======

        a string consisting of the function signature, with the parenthesis but
        without the function name. example:
        `(a, *args, b=1, **kwargs)`

    
    """
def IPCompleter(Completer):
    """
    Extension of the completer class with IPython-specific features
    """
    def _greedy_changed(self, change):
        """
        update the splitter and readline delims when greedy is changed
        """
    def _limit_to_all_changed(self, change):
        """
        '`IPython.core.IPCompleter.limit_to__all__` configuration '
        'value has been deprecated since IPython 5.0, will be made to have '
        'no effects and then removed in future version of IPython.'
        """
2021-03-02 20:49:16,771 : INFO : tokenize_signature : --> do i ever get here?
    def __init__(self, shell=None, namespace=None, global_namespace=None,
                 use_readline=_deprecation_readline_sentinel, config=None, **kwargs):
        """
        IPCompleter() -> completer

                Return a completer object.

                Parameters
                ----------

                shell
                    a pointer to the ipython shell itself.  This is needed
                    because this completer knows about magic functions, and those can
                    only be accessed via the ipython instance.

                namespace : dict, optional
                    an optional dict where completions are performed.

                global_namespace : dict, optional
                    secondary optional dict for completions, to
                    handle cases (such as IPython embedded inside functions) where
                    both Python scopes are visible.

                use_readline : bool, optional
                    DEPRECATED, ignored since IPython 6.0, will have no effects
        
        """
    def matchers(self):
        """
        All active matcher routines for completion
        """
    def all_completions(self, text) -> List[str]:
        """

                Wrapper around the completion methods for the benefit of emacs.
        
        """
    def _clean_glob(self, text):
        """
        %s*
        """
    def _clean_glob_win32(self,text):
        """
        \\
        """
    def file_matches(self, text):
        """
        Match filenames, expanding ~USER type strings.

                Most of the seemingly convoluted logic in this completer is an
                attempt to handle filenames with spaces in them.  And yet it's not
                quite perfect, because Python's readline doesn't expose all of the
                GNU readline details needed for this to be done correctly.

                For a filename with a space in it, the printed completions will be
                only the parts after what's already been typed (instead of the
                full completions, as is normally done).  I don't think with the
                current (as of Python 2.3) Python readline it's possible to do
                better.
        """
    def magic_matches(self, text):
        """
        Match magics
        """
            def matches(magic):
                """

                                Filter magics, in particular remove magics that match
                                a name present in global namespace.
                
                """
            def matches(magic):
                """
                 Match class names and attributes for %config magic 
                """
    def magic_color_matches(self, text:str) -> List[str] :
        """
         Match color schemes for %colors magic
        """
    def _jedi_matches(self, cursor_column:int, cursor_line:int, text:str):
        """


                Return a list of :any:`jedi.api.Completions` object from a ``text`` and
                cursor position.

                Parameters
                ----------
                cursor_column : int
                    column position of the cursor in ``text``, 0-indexed.
                cursor_line : int
                    line position of the cursor in ``text``, 0-indexed
                text : str
                    text to complete

                Debugging
                ---------

                If ``IPCompleter.debug`` is ``True`` may return a :any:`_FakeJediCompletion`
                object containing a string with the Jedi debug information attached.
        
        """
    def python_matches(self, text):
        """
        Match attributes or global python names
        """
    def _default_arguments_from_docstring(self, doc):
        """
        Parse the first line of docstring for call signature.

                Docstring should be of the form 'min(iterable[, key=func])\n'.
                It can also parse cython docstring of the form
                'Minuit.migrad(self, int ncall=10000, resume=True, int nsplit=1)'.
        
        """
    def _default_arguments(self, obj):
        """
        Return the list of default arguments of obj if it is callable,
                or empty list otherwise.
        """
    def python_func_kw_matches(self,text):
        """
        Match named parameters (kwargs) of the last open function
        """
    def dict_key_matches(self, text):
        """
        Match string keys in a dictionary, after e.g. 'foo[' 
        """
        def get_keys(obj):
            """
             Objects can define their own completions by defining an
             _ipy_key_completions_() method.

            """
    def unicode_name_matches(self, text):
        """
        u"""Match Latex-like syntax for unicode characters base
                on the name of the character.

                This does  ``\\GREEK SMALL LETTER ETA`` -> ``η``

                Works only on valid python 3 identifier, or on combining characters that
                will combine to form a valid identifier.

                Used on Python 3 only.
        
        """
    def latex_matches(self, text):
        """
        u"""Match Latex syntax for unicode characters.

                This does both ``\\alp`` -> ``\\alpha`` and ``\\alpha`` -> ``α``
        
        """
    def dispatch_custom_completer(self, text):
        """
         Create a little structure to pass all the relevant information about
         the current completion to any custom completer.

        """
    def completions(self, text: str, offset: int)->Iterator[Completion]:
        """

                Returns an iterator over the possible completions

                .. warning:: Unstable

                    This function is unstable, API may change without warning.
                    It will also raise unless use in proper context manager.

                Parameters
                ----------

                text:str
                    Full text of the current input, multi line string.
                offset:int
                    Integer representing the position of the cursor in ``text``. Offset
                    is 0-based indexed.

                Yields
                ------
                    :any:`Completion` object


                The cursor on a text can either be seen as being "in between"
                characters or "On" a character depending on the interface visible to
                the user. For consistency the cursor being on "in between" characters X
                and Y is equivalent to the cursor being "on" character Y, that is to say
                the character the cursor is on is considered as being after the cursor.

                Combining characters may span more that one position in the
                text.


                .. note::

                    If ``IPCompleter.debug`` is :any:`True` will yield a ``--jedi/ipython--``
                    fake Completion token to distinguish completion returned by Jedi
                    and usual IPython completion.

                .. note::

                    Completions are not completely deduplicated yet. If identical
                    completions are coming from different sources this function does not
                    ensure that each completion object will only be present once.
        
        """
    def _completions(self, full_text: str, offset: int, *, _timeout)->Iterator[Completion]:
        """

                Core completion module.Same signature as :any:`completions`, with the
                extra `timeout` parameter (in seconds).


                Computing jedi's completion ``.type`` can be quite expensive (it is a
                lazy property) and can require some warm-up, more warm up than just
                computing the ``name`` of a completion. The warm-up can be :

                    - Long warm-up the first time a module is encountered after
                    install/update: actually build parse/inference tree.

                    - first time the module is encountered in a session: load tree from
                    disk.

                We don't want to block completions for tens of seconds so we give the
                completer a "budget" of ``_timeout`` seconds per invocation to compute
                completions types, the completions that have not yet been computed will
                be marked as "unknown" an will have a chance to be computed next round
                are things get cached.

                Keep in mind that Jedi is not the only thing treating the completion so
                keep the timeout short-ish as if we take more than 0.3 second we still
                have lots of processing to do.

        
        """
    def complete(self, text=None, line_buffer=None, cursor_pos=None):
        """
        Find completions for the given text and line context.

                Note that both the text and the line_buffer are optional, but at least
                one of them must be given.

                Parameters
                ----------
                  text : string, optional
                    Text to perform the completion on.  If not given, the line buffer
                    is split using the instance's CompletionSplitter object.

                  line_buffer : string, optional
                    If not given, the completer attempts to obtain the current line
                    buffer via readline.  This keyword allows clients which are
                    requesting for text completions in non-readline contexts to inform
                    the completer of the entire text.

                  cursor_pos : int, optional
                    Index of the cursor in the full line buffer.  Should be provided by
                    remote frontends where kernel has no access to frontend state.

                Returns
                -------
                text : str
                  Text that was actually used in the completion.

                matches : list
                  A list of completion matches.


                .. note::

                    This API is likely to be deprecated and replaced by
                    :any:`IPCompleter.completions` in the future.


        
        """
2021-03-02 20:49:16,789 : INFO : tokenize_signature : --> do i ever get here?
    def _complete(self, *, cursor_line, cursor_pos, line_buffer=None, text=None,
                  full_text=None) -> Tuple[str, List[str], List[str], Iterable[_FakeJediCompletion]]:
        """


                Like complete but can also returns raw jedi completions as well as the
                origin of the completion text. This could (and should) be made much
                cleaner but that will be simpler once we drop the old (and stateful)
                :any:`complete` API.


                With current provisional API, cursor_pos act both (depending on the
                caller) as the offset in the ``text`` or ``line_buffer``, or as the
                ``column`` when passing multiline strings this could/should be renamed
                but would add extra noise.
        
        """
    def fwd_unicode_match(self, text:str) -> Tuple[str, list]:
        """
        '\\'
        """
