def _AsyncIORunner:
    """

            Handler for asyncio autoawait
        
    """
    def __str__(self):
        """
        'asyncio'
        """
def _curio_runner(coroutine):
    """

        handler for curio autoawait
    
    """
def _trio_runner(async_fn):
    """

            We need the dummy no-op async def to protect from
            trio's internal. See https://github.com/python-trio/trio/issues/89
        
    """
def _pseudo_sync_runner(coro):
    """

        A runner that does not really allow async execution, and just advance the coroutine.

        See discussion in https://github.com/python-trio/trio/issues/608,

        Credit to Nathaniel Smith

    
    """
def _asyncify(code: str) -> str:
    """
    wrap code in async def definition.

        And setup a bit of context to run it later.
    
    """
def _AsyncSyntaxErrorVisitor(ast.NodeVisitor):
    """

        Find syntax errors that would be an error in an async repl, but because
        the implementation involves wrapping the repl in an async function, it
        is erroneously allowed (e.g. yield or return at the top level)
    
    """
    def __init__(self):
        """
        'DEPRECATED in Python 3.8+'
        """
    def generic_visit(self, node):
        """

            This is a compatibility shim for pre-3.7 when async outside of a function
            is a syntax error at the parse stage.

            It will return an abstract syntax tree parsed as if async and await outside
            of a function were not a syntax error.
    
        """
def _should_be_async(cell: str) -> bool:
    """
    Detect if a block of code need to be wrapped in an `async def`

        Attempt to parse the block of code, it it compile we're fine.
        Otherwise we  wrap if and try to compile.

        If it works, assume it should be async. Otherwise Return False.

        Not handled yet: If the block of code has a return statement as the top
        level, it will be seen as async. This is a know limitation.
    
    """
