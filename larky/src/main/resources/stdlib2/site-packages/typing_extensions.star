    def _tp_cache(x):
        """
         The two functions below are copies of typing internal helpers.
         They are needed by _ProtocolMeta



        """
def _no_slots_copy(dct):
    """
    '__slots__'
    """
def _check_generic(cls, parameters):
    """
    %s is not a generic class
    """
    def _generic_new(base_cls, cls, *args, **kwargs):
        """
         See https://github.com/python/typing/pull/439

        """
    def _check_methods_in_mro(C, *methods):
        """
         Please keep __all__ alphabetized within each category.

        """
    def _NoReturn(typing._FinalTypingBase, _root=True):
    """
    Special type indicating functions that never return.
            Example::

              from typing import NoReturn

              def stop() -> NoReturn:
                  raise Exception('no way')

            This type is invalid in other positions, e.g., ``List[NoReturn]``
            will fail in static type checkers.
        
    """
        def __instancecheck__(self, obj):
            """
            NoReturn cannot be used with isinstance().
            """
        def __subclasscheck__(self, cls):
            """
            NoReturn cannot be used with issubclass().
            """
    def _NoReturnMeta(typing.TypingMeta):
    """
    Metaclass for NoReturn
    """
        def __new__(cls, name, bases, namespace, _root=False):
            """
            NoReturn cannot be used with isinstance().
            """
        def __subclasscheck__(self, cls):
            """
            NoReturn cannot be used with issubclass().
            """
    def NoReturn(typing.Final, metadef=_NoReturnMeta, _root=True):
    """
    Special type indicating functions that never return.
            Example::

              from typing import NoReturn

              def stop() -> NoReturn:
                  raise Exception('no way')

            This type is invalid in other positions, e.g., ``List[NoReturn]``
            will fail in static type checkers.
        
    """
    def _ClassVar(typing._FinalTypingBase, _root=True):
    """
    Special type construct to mark class variables.

            An annotation wrapped in ClassVar indicates that a given
            attribute is intended to be used as a class variable and
            should not be set on instances of that class. Usage::

              class Starship:
                  stats: ClassVar[Dict[str, int]] = {} # class variable
                  damage: int = 10                     # instance variable

            ClassVar accepts only types and cannot be further subscribed.

            Note that ClassVar is not a class itself, and should not
            be used with isinstance() or issubclass().
        
    """
        def __init__(self, tp=None, **kwds):
            """
            '{} accepts only single type.'
            """
        def _eval_type(self, globalns, localns):
            """
            '[{}]'
            """
        def __hash__(self):
            """
            Metaclass for ClassVar
            """
        def __new__(cls, name, bases, namespace, tp=None, _root=False):
            """
            ClassVar cannot be used with isinstance().
            """
        def __subclasscheck__(self, cls):
            """
            ClassVar cannot be used with issubclass().
            """
        def __getitem__(self, item):
            """
            '{} cannot be further subscripted'

            """
        def _eval_type(self, globalns, localns):
            """
            '[{}]'
            """
        def __hash__(self):
            """
            Special type construct to mark class variables.

                    An annotation wrapped in ClassVar indicates that a given
                    attribute is intended to be used as a class variable and
                    should not be set on instances of that class. Usage::

                      class Starship:
                          stats: ClassVar[Dict[str, int]] = {} # class variable
                          damage: int = 10                     # instance variable

                    ClassVar accepts only types and cannot be further subscribed.

                    Note that ClassVar is not a class itself, and should not
                    be used with isinstance() or issubclass().
        
            """
    def _FinalForm(typing._SpecialForm, _root=True):
    """
    'typing_extensions.'
    """
        def __getitem__(self, parameters):
            """
            '{} accepts only single type'
            """
    def _Final(typing._FinalTypingBase, _root=True):
    """
    A special typing construct to indicate that a name
            cannot be re-assigned or overridden in a subclass.
            For example:

                MAX_SIZE: Final = 9000
                MAX_SIZE += 1  # Error reported by type checker

                class Connection:
                    TIMEOUT: Final[int] = 10
                class FastConnector(Connection):
                    TIMEOUT = 1  # Error reported by type checker

            There is no runtime checking of these properties.
        
    """
        def __init__(self, tp=None, **kwds):
            """
            '{} accepts only single type.'
            """
        def _eval_type(self, globalns, localns):
            """
            '[{}]'
            """
        def __hash__(self):
            """
            Metaclass for Final
            """
        def __new__(cls, name, bases, namespace, tp=None, _root=False):
            """
            Final cannot be used with isinstance().
            """
        def __subclasscheck__(self, cls):
            """
            Final cannot be used with issubclass().
            """
        def __getitem__(self, item):
            """
            '{} cannot be further subscripted'

            """
        def _eval_type(self, globalns, localns):
            """
            '[{}]'
            """
        def __hash__(self):
            """
            A special typing construct to indicate that a name
                    cannot be re-assigned or overridden in a subclass.
                    For example:

                        MAX_SIZE: Final = 9000
                        MAX_SIZE += 1  # Error reported by type checker

                        class Connection:
                            TIMEOUT: Final[int] = 10
                        class FastConnector(Connection):
                            TIMEOUT = 1  # Error reported by type checker

                    There is no runtime checking of these properties.
        
            """
    def final(f):
        """
        This decorator can be used to indicate to type checkers that
                the decorated method cannot be overridden, and decorated class
                cannot be subclassed. For example:

                    class Base:
                        @final
                        def done(self) -> None:
                            ...
                    class Sub(Base):
                        def done(self) -> None:  # Error reported by type checker
                            ...
                    @final
                    class Leaf:
                        ...
                    class Other(Leaf):  # Error reported by type checker
                        ...

                There is no runtime checking of these properties.
        
        """
def IntVar(name):
    """
    'Literal'
    """
    def _LiteralForm(typing._SpecialForm, _root=True):
    """
    'typing_extensions.'
    """
        def __getitem__(self, parameters):
            """
            'Literal'
            """
    def _Literal(typing._FinalTypingBase, _root=True):
    """
    A type that can be used to indicate to type checkers that the
            corresponding value has a value literally equivalent to the
            provided parameter. For example:

                var: Literal[4] = 4

            The type checker understands that 'var' is literally equal to the
            value 4 and no other value.

            Literal[...] cannot be subclassed. There is no runtime checking
            verifying that the parameter is actually a value instead of a type.
        
    """
        def __init__(self, values=None, **kwds):
            """
            '{} cannot be further subscripted'

            """
        def _eval_type(self, globalns, localns):
            """
            '[{}]'
            """
        def __hash__(self):
            """
            Metaclass for Literal
            """
        def __new__(cls, name, bases, namespace, values=None, _root=False):
            """
            Literal cannot be used with isinstance().
            """
        def __subclasscheck__(self, cls):
            """
            Literal cannot be used with issubclass().
            """
        def __getitem__(self, item):
            """
            '{} cannot be further subscripted'

            """
        def _eval_type(self, globalns, localns):
            """
            '[{}]'
            """
        def __hash__(self):
            """
            A type that can be used to indicate to type checkers that the
                    corresponding value has a value literally equivalent to the
                    provided parameter. For example:

                        var: Literal[4] = 4

                    The type checker understands that 'var' is literally equal to the
                    value 4 and no other value.

                    Literal[...] cannot be subclassed. There is no runtime checking
                    verifying that the parameter is actually a value instead of a type.
        
            """
def _overload_dummy(*args, **kwds):
    """
    Helper for @overload to raise when called.
    """
def overload(func):
    """
    Decorator for overloaded functions/methods.

        In a stub file, place two or more stub definitions for the same
        function in a row, each decorated with @overload.  For example:

          @overload
          def utf8(value: None) -> None: ...
          @overload
          def utf8(value: bytes) -> bytes: ...
          @overload
          def utf8(value: str) -> bytes: ...

        In a non-stub file (i.e. a regular .py file), do the same but
        follow it with an implementation.  The implementation should *not*
        be decorated with @overload.  For example:

          @overload
          def utf8(value: None) -> None: ...
          @overload
          def utf8(value: bytes) -> bytes: ...
          @overload
          def utf8(value: str) -> bytes: ...
          def utf8(value):
              # implementation goes here
    
    """
    def Type(typing.Generic[CT_co], extra=type):
    """
    A special construct usable to annotate class objects.

            For example, suppose we have the following classes::

              class User: ...  # Abstract base for User classes
              class BasicUser(User): ...
              class ProUser(User): ...
              class TeamUser(User): ...

            And a function that takes a class argument that's a subclass of
            User and returns an instance of the corresponding class::

              U = TypeVar('U', bound=User)
              def new_user(user_class: Type[U]) -> U:
                  user = user_class()
                  # (Here we could write the user object to a database)
                  return user
              joe = new_user(BasicUser)

            At this point the type checker knows that joe has type BasicUser.
        
    """
def _define_guard(type_name):
    """

        Returns True if the given type isn't defined in typing but
        is defined in collections_abc.

        Adds the type to __all__ if the collection is found in either
        typing or collection_abc.
    
    """
def _ExtensionsGenericMeta(GenericMeta):
    """
    This mimics a more modern GenericMeta.__subclasscheck__() logic
            (that does not have problems with recursion) to work around interactions
            between collections, typing, and typing_extensions on older
            versions of Python, see https://github.com/python/typing/issues/501.
        
    """
2021-03-02 20:53:31,999 : INFO : tokenize_signature : --> do i ever get here?
    def Awaitable(typing.Generic[T_co], metadef=_ExtensionsGenericMeta,
                    extra=collections_abc.Awaitable):
    """
    'Coroutine'
    """
2021-03-02 20:53:31,999 : INFO : tokenize_signature : --> do i ever get here?
2021-03-02 20:53:31,999 : INFO : tokenize_signature : --> do i ever get here?
    def Coroutine(Awaitable[V_co], typing.Generic[T_co, T_contra, V_co],
                    metaclass=_ExtensionsGenericMeta,
                    extra=collections_abc.Coroutine):
    """
    'AsyncIterable'
    """
2021-03-02 20:53:31,999 : INFO : tokenize_signature : --> do i ever get here?
2021-03-02 20:53:31,999 : INFO : tokenize_signature : --> do i ever get here?
    def AsyncIterable(typing.Generic[T_co],
                        metaclass=_ExtensionsGenericMeta,
                        extra=collections_abc.AsyncIterable):
    """
    'AsyncIterator'
    """
2021-03-02 20:53:32,000 : INFO : tokenize_signature : --> do i ever get here?
2021-03-02 20:53:32,000 : INFO : tokenize_signature : --> do i ever get here?
    def AsyncIterator(AsyncIterable[T_co],
                        metaclass=_ExtensionsGenericMeta,
                        extra=collections_abc.AsyncIterator):
    """
    'Deque'
    """
2021-03-02 20:53:32,000 : INFO : tokenize_signature : --> do i ever get here?
2021-03-02 20:53:32,000 : INFO : tokenize_signature : --> do i ever get here?
    def Deque(collections.deque, typing.MutableSequence[T],
                metaclass=_ExtensionsGenericMeta,
                extra=collections.deque):
    """
    'ContextManager'
    """
2021-03-02 20:53:32,001 : INFO : tokenize_signature : --> do i ever get here?
2021-03-02 20:53:32,001 : INFO : tokenize_signature : --> do i ever get here?
    def ContextManager(typing.Generic[T_co],
                         metaclass=_ExtensionsGenericMeta,
                         extra=contextlib.AbstractContextManager):
    """
     In Python 3.6+, it is possible to set a method to None to
     explicitly indicate that the class does not implement an ABC
     (https://bugs.python.org/issue25958), but we do not support
     that pattern here because this fallback class is only used
     in Python 3.5 and earlier.

    """
2021-03-02 20:53:32,003 : INFO : tokenize_signature : --> do i ever get here?
2021-03-02 20:53:32,003 : INFO : tokenize_signature : --> do i ever get here?
    def AsyncContextManager(typing.Generic[T_co],
                              metaclass=_ExtensionsGenericMeta,
                              extra=contextlib.AbstractAsyncContextManager):
    """
    'AsyncContextManager'
    """
2021-03-02 20:53:32,003 : INFO : tokenize_signature : --> do i ever get here?
2021-03-02 20:53:32,003 : INFO : tokenize_signature : --> do i ever get here?
    def DefaultDict(collections.defaultdict, typing.MutableMapping[KT, VT],
                      metaclass=_ExtensionsGenericMeta,
                      extra=collections.defaultdict):
    """
    'Counter'
    """
    def _CounterMeta(typing.GenericMeta):
    """
    Metaclass for Counter
    """
        def __getitem__(self, item):
            """
            'ChainMap'
            """
2021-03-02 20:53:32,006 : INFO : tokenize_signature : --> do i ever get here?
2021-03-02 20:53:32,006 : INFO : tokenize_signature : --> do i ever get here?
        def ChainMap(collections.ChainMap, typing.MutableMapping[KT, VT],
                       metaclass=_ExtensionsGenericMeta,
                       extra=collections.ChainMap):
    """
    'ChainMap'
    """
2021-03-02 20:53:32,007 : INFO : tokenize_signature : --> do i ever get here?
2021-03-02 20:53:32,007 : INFO : tokenize_signature : --> do i ever get here?
    def AsyncGenerator(AsyncIterator[T_co], typing.Generic[T_co, T_contra],
                         metaclass=_ExtensionsGenericMeta,
                         extra=collections_abc.AsyncGenerator):
    """
    'NewType'
    """
    def NewType(name, tp):
        """
        NewType creates simple unique types with almost zero
                runtime overhead. NewType(name, tp) is considered a subtype of tp
                by static type checkers. At runtime, NewType(name, tp) returns
                a dummy function that simply returns its argument. Usage::

                    UserId = NewType('UserId', int)

                    def name_by_id(user_id: UserId) -> str:
                        ...

                    UserId('user')          # Fails type check

                    name_by_id(42)          # Fails type check
                    name_by_id(UserId(42))  # OK

                    num = UserId(5) + 1     # type: int
        
        """
        def new_type(x):
            """
            'Text'
            """
def _gorg(cls):
    """
    This function exists for compatibility with old typing versions.
    """
    def _next_in_mro(cls):  # noqa
        """
         noqa
        """
def _get_protocol_attrs(cls):
    """
     without object
    """
def _is_callable_members_only(cls):
    """
    'Protocol'
    """
    def _ProtocolMeta(GenericMeta):
    """
    Internal metaclass for Protocol.

            This exists so Protocol classes can be generic without deriving
            from Generic.
        
    """
2021-03-02 20:53:32,009 : INFO : tokenize_signature : --> do i ever get here?
            def __new__(cls, name, bases, namespace,
                        tvars=None, args=None, origin=None, extra=None, orig_bases=None):
                """
                 This is just a version copied from GenericMeta.__new__ that
                 includes "Protocol" special treatment. (Comments removed for brevity.)

                """
        def __init__(cls, *args, **kwargs):
            """
            '_is_protocol'
            """
                def _no_init(self, *args, **kwargs):
                    """
                    'Protocols cannot be instantiated'
                    """
            def _proto_hook(other):
                """
                '_is_protocol'
                """
        def __instancecheck__(self, instance):
            """
             We need this method for situations where attributes are
             assigned in __init__.

            """
        def __subclasscheck__(self, cls):
            """
            '__name__'
            """
            def __getitem__(self, params):
                """
                 We also need to copy this from GenericMeta.__getitem__ to get
                 special treatment of "Protocol". (Comments removed for brevity.)

                """
    def Protocol(metadef=_ProtocolMeta):
    """
    Base class for protocol classes. Protocol classes are defined as::

              class Proto(Protocol):
                  def meth(self) -> int:
                      ...

            Such classes are primarily used with static type checkers that recognize
            structural subtyping (static duck-typing), for example::

              class C:
                  def meth(self) -> int:
                      return 0

              def func(x: Proto) -> int:
                  return x.meth()

              func(C())  # Passes static type check

            See PEP 544 for details. Protocol classes decorated with
            @typing_extensions.runtime act as simple-minded runtime protocol that checks
            only the presence of given attributes, ignoring their type signatures.

            Protocol classes can be generic, they are defined as::

              class GenProto({bases}):
                  def meth(self) -> T:
                      ...
        
    """
        def __new__(cls, *args, **kwds):
            """
            Type Protocol cannot be instantiated; 
            it can be used only as a base class
            """
    def _ProtocolMeta(abc.ABCMeta):
    """
     This metaclass is a bit unfortunate and exists only because of the lack
     of __instancehook__.

    """
        def __instancecheck__(cls, instance):
            """
             We need this method for situations where attributes are
             assigned in __init__.

            """
    def Protocol(metadef=_ProtocolMeta):
    """
     There is quite a lot of overlapping code with typing.Generic.
     Unfortunately it is hard to avoid this while these live in two different
     modules. The duplicated code will be removed when Protocol is moved to typing.

    """
        def __new__(cls, *args, **kwds):
            """
            Type Protocol cannot be instantiated; 
            it can only be used as a base class
            """
        def __class_getitem__(cls, params):
            """
            Parameter list to {}[...] cannot be empty
            """
        def __init_subclass__(cls, *args, **kwargs):
            """
            '__orig_bases__'
            """
            def _proto_hook(other):
                """
                '_is_protocol'
                """
            def _no_init(self, *args, **kwargs):
                """
                'Protocols cannot be instantiated'
                """
    def runtime_checkable(cls):
        """
        Mark a protocol class as a runtime protocol, so that it
                can be used with isinstance() and issubclass(). Raise TypeError
                if applied to a non-protocol class.

                This allows a simple-minded structural check very similar to the
                one-offs in collections.abc such as Hashable.
        
        """
    def SupportsIndex(Protocol):
    """
     The standard library TypedDict in Python 3.8 does not store runtime information
     about which (if any) keys are optional.  See https://bugs.python.org/issue38834

    """
    def _check_fails(cls, other):
        """
        '__name__'
        """
    def _dict_new(*args, **kwargs):
        """
        'TypedDict.__new__(): not enough arguments'
        """
    def _typeddict_new(*args, total=True, **kwargs):
        """
        'TypedDict.__new__(): not enough arguments'
        """
    def _TypedDictMeta(type):
    """
     Create new typed dict class object.
     This method is called directly when TypedDict is subclassed,
     or via _typeddict_new when TypedDict is instantiated. This way
     TypedDict supports all three syntaxes described in its docstring.
     Subclasses and instances of TypedDict return actual dictionaries
     via _dict_new.

    """
    def _AnnotatedAlias(typing._GenericAlias, _root=True):
    """
    Runtime representation of an annotated type.

            At its core 'Annotated[t, dec1, dec2, ...]' is an alias for the type 't'
            with extra annotations. The alias behaves like a normal typing alias,
            instantiating is the same as instantiating the underlying type, binding
            it to types is also the same.
        
    """
        def __init__(self, origin, metadata):
            """
            typing_extensions.Annotated[{}, {}]
            """
        def __reduce__(self):
            """
            Add context specific metadata to a type.

                    Example: Annotated[int, runtime_check.Unsigned] indicates to the
                    hypothetical runtime_check module that this type is an unsigned int.
                    Every other consumer of this type can ignore this metadata and treat
                    this type as int.

                    The first argument to Annotated must be a valid type (and will be in
                    the __origin__ field), the remaining arguments are kept as a tuple in
                    the __extra__ field.

                    Details:

                    - It's an error to call `Annotated` with less than two arguments.
                    - Nested Annotated are flattened::

                        Annotated[Annotated[T, Ann1, Ann2], Ann3] == Annotated[T, Ann1, Ann2, Ann3]

                    - Instantiating an annotated type is equivalent to instantiating the
                    underlying type::

                        Annotated[C, Ann1](5) == C(5)

                    - Annotated can be used as a generic type alias::

                        Optimized = Annotated[T, runtime.Optimize()]
                        Optimized[int] == Annotated[int, runtime.Optimize()]

                        OptimizedList = Annotated[List[T], runtime.Optimize()]
                        OptimizedList[int] == Annotated[List[int], runtime.Optimize()]
        
            """
        def __new__(cls, *args, **kwargs):
            """
            Type Annotated cannot be instantiated.
            """
        def __class_getitem__(cls, params):
            """
            Annotated[...] should be used 
            with at least two arguments (a type and an 
            annotation).
            """
        def __init_subclass__(cls, *args, **kwargs):
            """
            Cannot subclass {}.Annotated
            """
    def _strip_annotations(t):
        """
        Strips the annotations from a given type.
        
        """
    def get_type_hints(obj, globalns=None, localns=None, include_extras=False):
        """
        Return type hints for an object.

                This is often the same as obj.__annotations__, but it handles
                forward references encoded as string literals, adds Optional[t] if a
                default value equal to None is set and recursively replaces all
                'Annotated[T, ...]' with 'T' (unless 'include_extras=True').

                The argument may be a module, class, method, or function. The annotations
                are returned as a dictionary. For classes, annotations include also
                inherited members.

                TypeError is raised if the argument is not of a type that can contain
                annotations, and an empty dictionary is returned if no annotations are
                present.

                BEWARE -- the behavior of globalns and localns is counterintuitive
                (unless you are familiar with how eval() and exec() work).  The
                search order is locals first, then globals.

                - If no dict arguments are passed, an attempt is made to use the
                  globals from obj (or the respective module's globals for classes),
                  and these are also used as the locals.  If the object does not appear
                  to have globals, an empty dictionary is used.

                - If one dict argument is passed, it is used for both globals and
                  locals.

                - If two dict arguments are passed, they specify globals and
                  locals, respectively.
        
        """
    def _is_dunder(name):
        """
        Returns True if name is a __dunder_variable_name__.
        """
    def AnnotatedMeta(typing.GenericMeta):
    """
    Metaclass for Annotated
    """
        def __new__(cls, name, bases, namespace, **kwargs):
            """
            Cannot subclass 
            """
        def __metadata__(self):
            """
            , 
            """
        def _subs_tree(self, tvars=None, args=None):  # noqa
            """
             noqa
            """
        def _get_cons(self):
            """
            Return the class used to create instance of this type.
            """
        def __getitem__(self, params):
            """
             specializing an instantiated type
            """
        def __call__(self, *args, **kwargs):
            """
             For simplicity we just don't relay all dunder names

            """
        def __setattr__(self, attr, value):
            """
            '_abc_'
            """
        def __instancecheck__(self, obj):
            """
            Annotated cannot be used with isinstance().
            """
        def __subclasscheck__(self, cls):
            """
            Annotated cannot be used with issubclass().
            """
    def Annotated(metadef=AnnotatedMeta):
    """
    Add context specific metadata to a type.

            Example: Annotated[int, runtime_check.Unsigned] indicates to the
            hypothetical runtime_check module that this type is an unsigned int.
            Every other consumer of this type can ignore this metadata and treat
            this type as int.

            The first argument to Annotated must be a valid type, the remaining
            arguments are kept as a tuple in the __metadata__ field.

            Details:

            - It's an error to call `Annotated` with less than two arguments.
            - Nested Annotated are flattened::

                Annotated[Annotated[T, Ann1, Ann2], Ann3] == Annotated[T, Ann1, Ann2, Ann3]

            - Instantiating an annotated type is equivalent to instantiating the
            underlying type::

                Annotated[C, Ann1](5) == C(5)

            - Annotated can be used as a generic type alias::

                Optimized = Annotated[T, runtime.Optimize()]
                Optimized[int] == Annotated[int, runtime.Optimize()]

                OptimizedList = Annotated[List[T], runtime.Optimize()]
                OptimizedList[int] == Annotated[List[int], runtime.Optimize()]
        
    """
    def get_origin(tp):
        """
        Get the unsubscripted version of a type.

                This supports generic types, Callable, Tuple, Union, Literal, Final, ClassVar
                and Annotated. Return None for unsupported types. Examples::

                    get_origin(Literal[42]) is Literal
                    get_origin(int) is None
                    get_origin(ClassVar[int]) is ClassVar
                    get_origin(Generic) is Generic
                    get_origin(Generic[T]) is Generic
                    get_origin(Union[T, int]) is Union
                    get_origin(List[Tuple[T, T]][int]) == list
        
        """
    def get_args(tp):
        """
        Get type arguments with all substitutions performed.

                For unions, basic simplifications used by Union constructor are performed.
                Examples::
                    get_args(Dict[str, int]) == (str, int)
                    get_args(int) == ()
                    get_args(Union[int, Union[T, int], str][int]) == (int, str)
                    get_args(Union[int, Tuple[T, int]][str]) == (int, Tuple[str, int])
                    get_args(Callable[[], T][int]) == ([], int)
        
        """
    def _TypeAliasForm(typing._SpecialForm, _root=True):
    """
    'typing_extensions.'
    """
    def TypeAlias(self, parameters):
        """
        Special marker indicating that an assignment should
                be recognized as a proper type alias definition by type
                checkers.

                For example::

                    Predicate: TypeAlias = Callable[..., bool]

                It's invalid when used anywhere except as in the example above.
        
        """
    def _TypeAliasForm(typing._SpecialForm, _root=True):
    """
    'typing_extensions.'
    """
    def _TypeAliasMeta(typing.TypingMeta):
    """
    Metaclass for TypeAlias
    """
        def __repr__(self):
            """
            'typing_extensions.TypeAlias'
            """
    def _TypeAliasBase(typing._FinalTypingBase, metadef=_TypeAliasMeta, _root=True):
    """
    Special marker indicating that an assignment should
            be recognized as a proper type alias definition by type
            checkers.

            For example::

                Predicate: TypeAlias = Callable[..., bool]

            It's invalid when used anywhere except as in the example above.
        
    """
        def __instancecheck__(self, obj):
            """
            TypeAlias cannot be used with isinstance().
            """
        def __subclasscheck__(self, cls):
            """
            TypeAlias cannot be used with issubclass().
            """
        def __repr__(self):
            """
            'typing_extensions.TypeAlias'
            """
    def _TypeAliasMeta(typing.TypingMeta):
    """
    Metaclass for TypeAlias
    """
        def __instancecheck__(self, obj):
            """
            TypeAlias cannot be used with isinstance().
            """
        def __subclasscheck__(self, cls):
            """
            TypeAlias cannot be used with issubclass().
            """
        def __call__(self, *args, **kwargs):
            """
            Cannot instantiate TypeAlias
            """
    def TypeAlias(metadef=_TypeAliasMeta, _root=True):
    """
    Special marker indicating that an assignment should
            be recognized as a proper type alias definition by type
            checkers.

            For example::

                Predicate: TypeAlias = Callable[..., bool]

            It's invalid when used anywhere except as in the example above.
        
    """
