def _get_path_extensions():
    """

    """
def PythonInfo(object):
    """
    Contains information for a Python interpreter
    """
    def __init__(self):
        """
        utf-8
        """
        def abs_path(v):
            """
             unroll relative elements from path (e.g. ..)
            """
    def _fast_get_system_executable(self):
        """
        Try to get the system executable by just looking at properties
        """
    def _distutils_install():
        """
         follow https://github.com/pypa/pip/blob/main/src/pip/_internal/locations.py#L95
         note here we don't import Distribution directly to allow setuptools to patch it

        """
    def version_str(self):
        """
        .
        """
    def version_release_str(self):
        """
        .
        """
    def python_name(self):
        """
        python{}.{}
        """
    def is_old_virtualenv(self):
        """
        u"/
        """
    def creators(self, refresh=False):
        """
        include
        """
    def system_prefix(self):
        """
        utf-8
        """
    def __repr__(self):
        """
        {}({!r})
        """
    def __str__(self):
        """
        {}({})
        """
    def spec(self):
        """
        {}{}-{}
        """
    def clear_cache(cls, app_data):
        """
         this method is not used by itself, so here and called functions can import stuff locally

        """
    def satisfies(self, spec, impl_must_match):
        """
        check if a given specification can be satisfied by the this python interpreter instance
        """
    def current(cls, app_data=None):
        """

                This locates the current host interpreter information. This might be different than what we run into in case
                the host python has been upgraded from underneath us.
        
        """
    def current_system(cls, app_data=None):
        """

                This locates the current host interpreter information. This might be different than what we run into in case
                the host python has been upgraded from underneath us.
        
        """
    def _to_json(self):
        """
         don't save calculated paths, as these are non primitive types

        """
    def _to_dict(self):
        """
        _creators
        """
    def from_exe(cls, exe, app_data=None, raise_on_error=True, ignore_cache=False, resolve_to_host=True):
        """
        Given a path to an executable get the python information
        """
    def _from_json(cls, payload):
        """
         the dictionary unroll here is to protect against pypy bug of interpreter crashing

        """
    def _from_dict(cls, data):
        """
        version_info
        """
    def _resolve_to_system(cls, app_data, target):
        """
         if we're linking back to ourselves accept ourselves with a WARNING

        """
    def discover_exe(self, app_data, prefix, exact=True):
        """
        discover exe from cache %s - exact %s: %r
        """
    def _check_exe(self, app_data, folder, name, exact, discovered):
        """
         ignore if for some reason we can't query
        """
    def _select_most_likely(discovered, target):
        """
         no exact match found, start relaxing our requirements then to facilitate system package upgrades that
         could cause this (when using copy strategy of the host python)

        """
        def sort_by(info):
            """
             we need to setup some priority of traits, this is as follows:
             implementation, major, minor, micro, architecture, tag, serial

            """
    def _find_possible_folders(self, inside_folder):
        """
         following path pattern of the current

        """
    def _find_possible_exe_names(self):
        """
        .
        """
    def _possible_base(self):
        """
         python is always the final option as in practice is used by multiple implementation as exe name

        """
